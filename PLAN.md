# libudon Development Plan

Parser implementation using descent (~/src/descent/).

## Architecture

descent **replaces** the old parser infrastructure entirely. The old ring-buffer,
ChunkSlice, ChunkArena, genmachine architecture is gone. descent generates clean
callback-based recursive descent parsers from `.desc` specifications.

**Key insight from implementation-phase-2.md:** The streaming event model is the
foundation, not a feature. The parser emits events as it parses—no accumulation.
The tree builder (when implemented) will be just another event consumer.

## Current Status

**Branch:** `phase-3-genmachine-rewrite`

### What Works

- [x] Elements with names (`|element`)
- [x] Element identity (`|element[id].class1.class2`)
- [x] Sameline attributes (`:key value`)
- [x] Block (indented) attributes
- [x] Multiple sameline attributes (`:a 1 :b 2 :c 3`)
- [x] Typed values via context-aware parsing:
  - Integer (decimal, hex 0x, octal 0o, binary 0b)
  - Float (with decimal or exponent)
  - BoolTrue, BoolFalse (`true`, `false`)
  - Nil (`null`, `nil`)
  - BareValue (unquoted strings)
- [x] Keywords via PHF perfect hash (`|keywords` directive)
- [x] Context-aware terminators (block/sameline/embedded/array)
- [x] Proper EOF handling via `|eof` directive
- [x] Text/prose content
- [x] Basic indentation hierarchy
- [x] Nested elements

### What's Incomplete

- [ ] Element suffixes (`?`, `!`, `*`, `+`)
- [ ] Embedded elements (`|{name attrs content}`)
- [ ] Directives (`!if`, `!for`, `!include`, etc.)
- [ ] Raw blocks (`!:lang:`)
- [ ] Interpolation (`!{{expr}}`)
- [ ] Escape sequences (`'|` escapes pipe in prose)
- [ ] Comments (`;` handling in various contexts)
- [ ] Quoted strings in values
- [ ] Arrays (`[a b c]`)

## Phase 3: Build Forward (IN PROGRESS)

### 3.1 Test Infrastructure (NEXT)

Tests come first. Every grammar feature gets tests before implementation.

- [ ] Delete old tests (reference deleted infrastructure)
- [ ] Build test harness for descent event model
- [ ] Extract test cases from SPEC.md examples
- [ ] Property-based / permutation testing framework
- [ ] Tests for what already works (baseline)

### 3.2 Core Grammar Completion

Test-driven. Each feature: write tests → implement → verify.

1. **Quoted strings** - `"double"` and `'single'` quoted values
2. **Arrays** - `[item1 item2 item3]` inline lists
3. **Element suffixes** - `?`, `!`, `*`, `+` expand to attributes
4. **Embedded elements** - `|{name attrs content}` inline in prose
5. **Comments** - `;` at line start and inline (context-aware)
6. **Escape sequences** - `'|`, `'\`, etc.

### 3.3 Directive System

The parser's only directive-level knowledge is body mode (per parser-strategy.md):

| Syntax | Body | Parser Behavior |
|--------|------|-----------------|
| `!foo` | UDON | Parse body recursively as UDON |
| `!:foo:` | Raw | Capture body verbatim, tag with "foo" |

1. **Block directives** - `!if`, `!elif`, `!else`, `!for`, `!let`
2. **Inline directives** - `!name{content}` with balanced braces
3. **Raw directives** - `!:lang:` block and `!{:lang: content}` inline
4. **Interpolation** - `!{{expr}}`, `!{{expr | filter}}`

### 3.4 Cleanup

- [ ] Remove `udon-core/src/values_parser.rs` (obsolete)
- [ ] Evaluate `udon-core/src/value.rs` (post-hoc classification may be redundant)

## Phase 4: Multi-Chunk Streaming & Performance

From descent TODO #10 - resumable state machine for true streaming:

```rust
loop {
    match parser.parse(chunk, on_event) {
        ParseResult::Complete => break,
        ParseResult::NeedMoreData => {
            chunk = get_next_chunk();  // Caller controls flow
        }
    }
}
```

**Design:**
- Zero-copy for 99% of input (tokens within chunks)
- Small internal buffer (~256 bytes) for cross-boundary tokens only
- Backpressure via blocking callbacks (caller controls chunk feed rate)
- No ring buffer needed - callbacks are 2-7x faster

**Tasks:**
- [ ] Multi-chunk streaming in descent (ParseResult enum)
- [ ] Cross-boundary token handling
- [ ] Benchmark suite (criterion)
- [ ] Memory profiling on large files

## Phase 5: Tree Builder

Build arena-allocated tree from events (event consumer pattern):

- [ ] `Document` and `Node` structs with arena allocation
- [ ] Tree builder that consumes parser events
- [ ] Navigation (parent, children, siblings)
- [ ] Simple selectors
- [ ] String interning for element/attribute names

## Phase 6: Language Bindings

### Ruby (udon-ruby)
- [ ] FFI layer for streaming API
- [ ] Lazy tree projection (Ruby objects created on access)
- [ ] Update to use new callback-based parser

### Other Targets
- [ ] WASM build (`wasm32-unknown-unknown`)
- [ ] Python via PyO3
- [ ] C ABI shared library

## Key Files

| File | Purpose |
|------|---------|
| `generator/udon.desc` | Main parser grammar |
| `generator/values.desc` | Value type parsing (concatenated) |
| `udon-core/src/parser.rs` | GENERATED by descent - do not edit |
| `regenerate-parser` | Script to regenerate parser |

## descent Workflow

```bash
# Regenerate parser (concatenates .desc files, runs descent, builds)
./regenerate-parser

# Generate only (no build)
./regenerate-parser --no-build

# Debug parsing stages
descent debug generator/udon.desc
descent debug generator/udon.desc --tokens
```

## Reference

- `~/src/descent/CLAUDE.md` - descent usage guide
- `~/src/udon/SPEC.md` - Authoritative UDON specification
- `~/src/udon/implementation-phase-2.md` - Ideal streaming architecture
- `~/src/udon/parser-strategy.md` - Multi-language strategy
