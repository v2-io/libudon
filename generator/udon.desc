; UDON Parser - Main Grammar Definition
;
; This file defines the core UDON grammar: elements, attributes, nesting,
; prose, comments, directives, and embedded content.
;
; DEPENDENCIES:
;   This file is concatenated with values.desc before generation.
;   Values.desc provides: /typed_value (emits Integer or Float)
;
; GENERATION:
;   ./regenerate-parser  # concatenates *.desc files and runs descent
;
; Design:
;   1. Type system declares emit behavior
;   2. EOF handling inferred from context
;   3. No explicit emit() calls
;   4. DSL describes grammar, generator infers mechanics
;
; Type categories:
;   BRACKET  - emits Start on entry, End on exit (Element, Embedded, Directive, Array)
;   CONTENT  - emits event on return (Name, Text, Comment, Attr, Value, etc.)
;   INTERNAL - no emit, used for intermediate values (indent count, flags)

|parser udon

; ============================================================================
; Type Declarations
; ============================================================================

|type[Element]       BRACKET    ; ElementStart on entry, ElementEnd on exit
|type[Embedded]      BRACKET    ; EmbeddedStart/End
|type[Directive]     BRACKET    ; DirectiveStart/End
|type[Array]         BRACKET    ; ArrayStart/End
|type[Freeform]      BRACKET    ; FreeformStart/End

|type[Name]          CONTENT    ; emits Name event on return
|type[Text]          CONTENT    ; emits Text event
|type[Comment]       CONTENT    ; emits Comment event
|type[Attr]          CONTENT    ; emits Attr event
|type[StringValue]   CONTENT    ; emits StringValue event
|type[BareValue]     CONTENT    ; emits BareValue event
|type[BoolTrue]      CONTENT    ; emits BoolTrue event
|type[BoolFalse]     CONTENT    ; emits BoolFalse event
|type[Nil]           CONTENT    ; emits Nil event
|type[Interpolation] CONTENT    ; emits Interpolation event
|type[Reference]     CONTENT    ; emits Reference event
|type[RawContent]    CONTENT    ; emits RawContent event
|type[Raw]           CONTENT    ; emits Raw flag event
|type[Integer]       CONTENT    ; emits Integer event (from values.desc)
|type[Float]         CONTENT    ; emits Float event (from values.desc)

|type[INT]           INTERNAL   ; no emit - internal integer
|type[BOOL]          INTERNAL   ; no emit - internal boolean


; ============================================================================
; Entry Point
; ============================================================================

|entry-point /document

|function[document]
  |state[:line]
    |c[\n]                    | ->                               |>>
    |c[ ]                     | col = /count_indent              |>> :dispatch
    |c[\t]                    | /error(no_tabs) | ->[\n]         |>> :line
    |default                  | col = 0                          |>> :dispatch

  |state[:dispatch]
    |c[|]                     | ->                               |>> :check_pipe
    |c[:]                     | -> | /block_attr                 |>> :line
    |c[!]                     | -> | /block_directive(col)       |>> :line
    |c[;]                     | -> | /line_comment               |>> :line
    |c[']                     | -> | /prose(col, -1)             |>> :line
    |default                  | /prose(col, -1)                  |>> :line

  |state[:check_pipe]
    |c[LETTER'[.?!*+]         | /element(col, -1)                |>> :line
    |c[{]                     | -> | /embedded                   |>> :line
    |default                  | /prose_pipe(col, -1)             |>> :line


; ============================================================================
; Utilities
; ============================================================================

|function[count_indent:INT]  | result = 0
  |state[:main]
    |c[ ]                     | -> | result += 1                 |>>
    |default                  |                                  |return result


; NOTE: Error events are emitted inline where needed, e.g. Error(no_tabs)
; No separate error function needed - the generator handles error codes.


; ============================================================================
; Element Identity Parsing (shared between element and embedded)
; ============================================================================

; DRYed: parse_element_identity(:close) - void helper for element identity
; Parses: name[id].class.class?!*+
; :close = closer byte (} for embedded, 0 for block element)
; Returns when identity complete or closer hit. Caller handles content.
|function[parse_element_identity]  :close
  |state[:identity]
    |c[:close]                |                                  |return  ; closer hit (empty)
    |c[LETTER]                | /name                            |>> :post_name
    |c[']                     | ->                               |>> :quoted_name
    |c[<L>]                     | ->                               |>> :bracket
    |c[.]                     |                                  |>> :class
    |c[?!*+]                  | /suffix                          |return  ; identity done
    |default                  |                                  |return  ; anonymous, identity done

  |state[:quoted_name]
    |c[']                     | ->                               |>> :post_name
    |default                  | /quoted_name                     |>> :post_name

  |state[:post_name]
    |c[:close]                |                                  |return
    |c[<L>]                     | ->                               |>> :bracket
    |c[.]                     |                                  |>> :class
    |c[?!*+]                  | /suffix                          |return
    |default                  |                                  |return

  |state[:bracket]
    |c[<R>]                     | ->                               |>> :post_bracket
    |default                  | Attr($id) | /value_bracket       |>> :bracket_close

  |state[:bracket_close]
    |c[<R>]                     | ->                               |>> :post_bracket
    |default                  |                                  |return  ; unclosed

  |state[:post_bracket]
    |c[:close]                |                                  |return
    |c[.]                     |                                  |>> :class
    |c[?!*+]                  | /suffix                          |return
    |default                  |                                  |return

  |state[:class]
    |c[.]                     | ->                               |>>
    |c[LETTER]                | Attr($class) | /class_name       |>> :post_class
    |c[']                     | Attr($class) | -> | /quoted_class |>> :post_class
    |default                  |                                  |return  ; no more classes

  |state[:post_class]
    |c[:close]                |                                  |return
    |c[.]                     |                                  |>> :class
    |c[?!*+]                  | /suffix                          |return
    |default                  |                                  |return


; ============================================================================
; Element (block form - indent-based children)
; ============================================================================

|function[element:Element]  :elem_col :parent_col

  |state[:identity]
    | /parse_element_identity(0)                                 |>> :post_identity

  |state[:post_identity]
    |c[\n]                    | ->                               |>> :children
    |c[ \t]                   | ->                               |>> :pre_content
    |default                  | /sameline_text(elem_col, 0)        |>> :children

  |state[:pre_content]
    |c[\n]                    | ->                               |>> :children
    |c[ \t]                   | ->                               |>>
    |c[:]                     | -> | /sameline_attr                |>>
    |c[|]                     | ->                               |>> :check_sameline_pipe
    |c[;]                     | ->                               |>> :check_sameline_semi
    |c[!]                     | ->                               |>> :check_sameline_bang
    |default                  | /sameline_text(elem_col, 0)        |>> :children

  |state[:check_sameline_pipe]
    |c[{]                     | -> | /embedded                   |>> :post_child
    |c[LETTER'[.?!*+]         | /element(COL - 1, elem_col)      |>> :post_child
    |default                  | /sameline_text(elem_col, 124)      |>> :children

  |state[:check_sameline_semi]
    |c[{]                     | -> | /brace_comment              |>> :pre_content
    |default                  | /line_comment_content            |>> :children

  |state[:check_sameline_bang]
    |c[{]                     | -> | /inline_directive           |>> :pre_content
    |default                  | /sameline_text(elem_col, 33)       |>> :children

  |state[:post_child]
    |c[\n]                    | ->                               |>> :children
    |c[ \t]                   | ->                               |>>
    |c[|]                     | ->                               |>> :check_sameline_pipe
    |default                  | /sameline_text(elem_col, 0)        |>> :children

  ; === Children Loop ===
  ; NOTE: count_indent returns 0-based column, but COL is 1-based
  |state[:children]
    |c[\n]                    | ->                               |>>
    |c[ ]                     | col = /count_indent              |>> :check_child
    |c[\t]                    | /error(no_tabs) | ->[\n]         |>>
    |default                  | col = COL - 1                    |>> :check_child

  |state[:check_child]
    |if[col <= elem_col]                                         |return  ; dedent
    |                                                            |>> :child_dispatch

  |state[:child_dispatch]
    |c[|]                     | ->                               |>> :child_pipe
    |c[:]                     | -> | /block_attr                 |>> :children
    |c[!]                     | -> | /block_directive(col)       |>> :children
    |c[;]                     | -> | /line_comment               |>> :children
    |c[']                     | -> | /prose(col, elem_col)       |>> :children
    |default                  | /prose(col, elem_col)            |>> :children

  |state[:child_pipe]
    |c[{]                     | -> | /embedded                   |>> :after_child
    |c[LETTER'[.?!*+]         | /element(col, elem_col)          |>> :after_child
    |default                  | /prose_pipe(col, elem_col)       |>> :children

  ; After child element/embedded returns - always re-check column for potential dedent
  |state[:after_child]
    |                                                            |>> :children


; ============================================================================
; Names (element/class names)
; ============================================================================

|function[name:Name]  | MARK
  |state[:main]
    |c[LABEL_CONT]            | ->                               |>>
    |default                  | TERM                             |return


; DRYed: skip_single_quoted - void helper for '-quoted content with escapes
; Consumes up to and including closing '. Caller handles MARK/TERM/emit.
|function[skip_single_quoted]
  |state[:main]
    |c[']                     | ->                               |return
    |c[\\]                    | -> | ->                          |>>
    |default                  | ->                               |>>


|function[quoted_name:Name]  | MARK
  |state[:main]
    | /skip_single_quoted | TERM(-1)                             |return


|function[class_name:BareValue]  | MARK
  |state[:main]
    |c[LABEL_CONT]            | ->                               |>>
    |default                  | TERM                             |return


|function[quoted_class:BareValue]  | MARK
  |state[:main]
    | /skip_single_quoted | TERM(-1)                             |return


; ============================================================================
; Attributes
; ============================================================================

|function[suffix]
  |state[:main]
    |c[?]                     | Attr(?) | BoolTrue | ->          |return
    |c[!]                     | Attr(!) | BoolTrue | ->          |return
    |c[*]                     | Attr(*) | BoolTrue | ->          |return
    |c[+]                     | Attr(+) | BoolTrue | ->          |return
    |default                  |                                  |return


|function[block_attr]
  |state[:key]
    |c[LETTER]                | /attr_key                        |>> :value_start
    |c[']                     | -> | /attr_key_quoted            |>> :value_start

  |state[:value_start]
    |c[ \t]                   | ->                               |>>
    |c[\n]                    | BoolTrue                         |return
    |default                  | /value_block                     |return


|function[sameline_attr]
  |state[:key]
    |c[LETTER]                | /attr_key                        |>> :value_start
    |c[']                     | -> | /attr_key_quoted            |>> :value_start

  |state[:value_start]
    |c[ \t]                   | ->                               |>>
    |c[\n:|]                  | BoolTrue                         |return
    |default                  | /value_sameline                  |return


|function[sameline_attr_embedded]
  |state[:key]
    |c[LETTER]                | /attr_key                        |>> :value_start
    |c[']                     | -> | /attr_key_quoted            |>> :value_start

  |state[:value_start]
    |c[ \t]                   | ->                               |>>
    |c[\n:|<RB>]              | BoolTrue                         |return
    |default                  | /value_embedded                  |return


|function[attr_key:Attr]  | MARK
  |state[:main]
    |c[LABEL_CONT]            | ->                               |>>
    |default                  | TERM                             |return


|function[attr_key_quoted:Attr]  | MARK
  |state[:main]
    | /skip_single_quoted | TERM(-1)                             |return


; ============================================================================
; Values
; ============================================================================

; Value parsing uses typed_value from values.desc with context parameters:
;   :space_term = 0 (block: space is content) or 1 (space terminates)
;   :bracket = 0 (none), } (embedded), ] (array)

; Block attribute value - space is content, ` ;` starts comment
|function[value_block]
  |state[:start]
    |c["]                     | -> | /double_quoted              |return
    |c[']                     | -> | /single_quoted              |return
    |c[<L>]                   | -> | /array_block                |return
    |default                  | MARK | /typed_value(0, 0)        |return

; Sameline attribute value - space terminates
|function[value_sameline]
  |state[:start]
    |c["]                     | -> | /double_quoted              |return
    |c[']                     | -> | /single_quoted              |return
    |c[<L>]                   | -> | /array_sameline             |return
    |default                  | MARK | /typed_value(1, 0)        |return

; Embedded attribute value - space or } terminates
|function[value_embedded]
  |state[:start]
    |c["]                     | -> | /double_quoted              |return
    |c[']                     | -> | /single_quoted              |return
    |c[<L>]                   | -> | /array_embedded             |return
    |default                  | MARK | /typed_value(1, <RB>)     |return

; Bracket ID value - IDs are always BareValue (no type detection)
; Space or ] terminates
|function[value_bracket:BareValue]  | MARK
  |state[:main]
    |c[<R>]                   | TERM                             |return
    |c[ ]                     | TERM                             |return
    |default                  | ->                               |>>

; Quoted string parsing - separate functions for each quote type
; (parameterized version had scan optimization issues with :quote)
|function[double_quoted:StringValue]  | MARK
  |state[:main]
    |c["]                     | TERM | ->                        |return
    |c[\\]                    | -> | ->                          |>>
    |default                  | ->                               |>>

|function[single_quoted:StringValue]  | MARK
  |state[:main]
    |c[']                     | TERM | ->                        |return
    |c[\\]                    | -> | ->                          |>>
    |default                  | ->                               |>>

; Arrays - items are space-separated, ] terminates
|function[array_block:Array]
  |state[:items]
    |c[<R>]                   | ->                               |return
    |c[ \t\n]                 | ->                               |>>
    |default                  | MARK | /typed_value(1, <R>)      |>>

|function[array_sameline:Array]
  |state[:items]
    |c[<R>]                   | ->                               |return
    |c[ \t\n]                 | ->                               |>>
    |default                  | MARK | /typed_value(1, <R>)      |>>

|function[array_embedded:Array]
  |state[:items]
    |c[<R>]                   | ->                               |return
    |c[ \t\n]                 | ->                               |>>
    |default                  | MARK | /typed_value(1, <R>)      |>>


; ============================================================================
; Prose / Text
; ============================================================================

|function[prose]  :line_col :parent_col
  |if[parent_col >= 0 && line_col <= parent_col]             |return  ; dedent

  |state[:content]
    | /text(line_col, parent_col, 0)                             |return


|function[prose_pipe]  :line_col :parent_col
  |if[parent_col >= 0 && line_col <= parent_col]             |return  ; dedent

  |state[:content]
    | /text(line_col, parent_col, 124)                           |return


; text - block-level prose content
; Same pattern as sameline_text: advance past special chars, check what follows.
; prepend: 0 = none, 124 = '|', 33 = '!'
|function[text:Text]  :line_col :parent_col :prepend
  |state[:entry]
    |if[prepend == 124]      | PREPEND(|)                       |>> :main
    |default                  |                                  |>> :main

  |state[:main]
    |c[\n]                    | TERM                             |return
    |c[|]                     | ->                               |>> :check_pipe
    |c[;]                     | ->                               |>> :check_semi
    |c[!]                     | ->                               |>> :check_bang
    |default                  | ->                               |>>

  |state[:check_pipe]
    |c[{]                     | TERM(-1) | Text(USE_MARK) | /embedded | MARK |>> :main
    |default                  |                                  |>> :main

  |state[:check_semi]
    |c[{]                     | TERM(-1) | Text(USE_MARK) | /brace_comment | MARK |>> :main
    |default                  | TERM(-1) | Text(USE_MARK) | /line_comment_content |return

  |state[:check_bang]
    |c[{]                     | TERM(-1) | Text(USE_MARK) | /inline_directive | MARK |>> :main
    |default                  |                                  |>> :main


; sameline_text - text on same line as element
; When special chars (|;!) are encountered, we advance past them, then check
; what follows. If special construct, emit text before it and parse construct.
; If not special, just continue (char is included in text).
; prepend: 0 = none, 124 = '|', 33 = '!'
|function[sameline_text:Text]  :elem_col :prepend  | MARK
  |state[:entry]
    |if[prepend == 124]      | PREPEND(|)                       |>> :main
    |if[prepend == 33]       | PREPEND(!)                       |>> :main
    |default                  |                                  |>> :main

  |state[:main]
    |c[\n]                    | TERM                             |return
    |c[|]                     | ->                               |>> :check_pipe
    |c[;]                     | ->                               |>> :check_semi
    |c[!]                     | ->                               |>> :check_bang
    |default                  | ->                               |>>

  |state[:check_pipe]
    |c[{]                     | TERM(-1) | Text(USE_MARK) | /embedded | MARK |>> :main
    |c[LETTER'[.?!*+]         | TERM(-1) | Text(USE_MARK) | /element(COL - 1, elem_col) | MARK |>> :main
    |default                  |                                  |>> :main

  |state[:check_semi]
    |c[{]                     | TERM(-1) | Text(USE_MARK) | /brace_comment | MARK |>> :main
    |default                  | TERM(-1) | Text(USE_MARK) | /line_comment_content |return

  |state[:check_bang]
    |c[{]                     | TERM(-1) | Text(USE_MARK) | /inline_directive | MARK |>> :main
    |default                  |                                  |>> :main


; ============================================================================
; Comments
; ============================================================================

|function[line_comment]
  |state[:check]
    |c[{]                     | -> | /brace_comment              |return
    |default                  | /line_comment_content            |return


; DRYed: line_comment_content - captures content to newline, emits Comment
; Used by all line comment variants (they were 100% identical)
|function[line_comment_content:Comment]  | MARK
  |state[:main]
    |c[\n]                    | TERM                             |return
    |default                  | ->                               |>>


; DRYed: skip_brace_balanced - void helper for {}-counting
; Caller handles MARK/TERM and emit type. Assumes opening { already consumed.
|function[skip_brace_balanced]  | depth = 1
  |state[:main]
    |c[{]                     | -> | depth += 1                  |>>
    |c[}]                     | -> | depth -= 1                  |>> :check
    |default                  | ->                               |>>

  |state[:check]
    |if[depth == 0]                                              |return
    |                                                            |>> :main


|function[brace_comment:Comment]  | MARK
  |state[:main]
    | /skip_brace_balanced | TERM(-1)                            |return


; ============================================================================
; Embedded |{...}
; ============================================================================

; DRYed: embedded uses shared parse_element_identity with } as closer
|function[embedded:Embedded]

  |state[:identity]
    | /parse_element_identity(<RB>)                              |>> :post_identity

  |state[:post_identity]
    |c[}]                     | ->                               |return  ; empty or identity-only
    |c[ \t]                   | ->                               |>> :pre_content
    |default                  | /embed_content                   |return

  |state[:pre_content]
    |c[}]                     | ->                               |return
    |c[ \t]                   | ->                               |>>
    |c[:]                     | -> | /sameline_attr_embedded      |>>
    |default                  | /embed_content                   |return


|function[embed_content:Text]  | MARK | EXPECTS(})
  |state[:main]
    |c[}]                     | TERM | ->                        |return
    |c[|]                     | TERM | ->                        |>> :check_pipe
    |c[;]                     | TERM | ->                        |>> :check_semi
    |c[!]                     | TERM | ->                        |>> :check_bang
    |default                  | ->                               |>>

  |state[:check_pipe]
    ; Inside embedded, only |{...} allowed
    |c[{]                     | -> | /embedded | MARK            |>> :main
    |default                  | MARK | PREPEND(|)                |>> :main

  |state[:check_semi]
    |c[{]                     | -> | /brace_comment | MARK       |>> :main
    |default                  | MARK | PREPEND(;)                |>> :main

  |state[:check_bang]
    |c[{]                     | -> | /inline_directive | MARK    |>> :main
    |default                  | MARK | PREPEND(!)                |>> :main


; ============================================================================
; Directives (stub)
; ============================================================================

|function[block_directive:Directive]  :line_col
  ; TODO: full implementation
  |state[:main]
    |c[\n]                    |                                  |return
    |default                  | ->                               |>>


|function[inline_directive:Directive]
  ; TODO: full implementation with !{{...}}, !{:kind: ...}, !{name ...}
  ; Uses shared skip_brace_balanced helper
  |state[:main]
    | /skip_brace_balanced                                       |return


; ============================================================================
; DSL Features Used
; ============================================================================
;
; Type declarations:
;   |type[Name]  BRACKET|CONTENT|INTERNAL
;
; Function with return type (parsed content):
;   |function[name:ReturnType]  | MARK
;     ... | TERM | return    ; emits ReturnType with accumulated content
;
; Inline literal events:
;   TypeName              ; emit event with no payload (BoolTrue, Nil)
;   TypeName(literal)     ; emit event with literal value (Attr($id), Attr(?))
;   TypeName(USE_MARK)    ; emit event using current MARK/TERM content
;
; Inferred EOF:
;   - MARK active → TERM
;   - EXPECTS(x) → emit unclosed error for x
;   - Return (BRACKET types emit End, CONTENT types emit event)
;
; EXPECTS(x):
;   Declares this state/function expects closing delimiter x
;   On EOF: emit(Error:unclosed_x)
;
; Other features:
;   MARK, TERM, TERM(-N), PREPEND(x)
;   |if[cond] | actions | transition
;   /function(args) - call with args
;   variable = value, variable += 1
;   COL - current column
;
