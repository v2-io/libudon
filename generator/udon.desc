; UDON Parser - Main Grammar Definition
;
; This file defines the core UDON grammar: elements, attributes, nesting,
; prose, comments, directives, and embedded content.
;
; DEPENDENCIES:
;   This file is concatenated with values.desc before generation.
;   Values.desc provides: /typed_value (emits Integer or Float)
;
; GENERATION:
;   ./regenerate-parser  # concatenates *.desc files and runs descent
;
; Design:
;   1. Type system declares emit behavior
;   2. EOF handling inferred from context
;   3. No explicit emit() calls
;   4. DSL describes grammar, generator infers mechanics
;
; Type categories:
;   BRACKET  - emits Start on entry, End on exit (Element, Embedded, Directive, Array)
;   CONTENT  - emits event on return (Name, Text, Comment, Attr, Value, etc.)
;   INTERNAL - no emit, used for intermediate values (indent count, flags)

|parser udon

; ============================================================================
; Type Declarations
; ============================================================================

|type[Element]       BRACKET    ; ElementStart on entry, ElementEnd on exit
|type[Embedded]      BRACKET    ; EmbeddedStart/End
|type[Directive]     BRACKET    ; DirectiveStart/End
|type[Array]         BRACKET    ; ArrayStart/End
|type[Freeform]      BRACKET    ; FreeformStart/End

|type[Name]          CONTENT    ; emits Name event on return
|type[Text]          CONTENT    ; emits Text event
|type[Comment]       CONTENT    ; emits Comment event
|type[Attr]          CONTENT    ; emits Attr event
|type[StringValue]   CONTENT    ; emits StringValue event
|type[BareValue]     CONTENT    ; emits BareValue event
|type[BoolTrue]      CONTENT    ; emits BoolTrue event
|type[BoolFalse]     CONTENT    ; emits BoolFalse event
|type[Nil]           CONTENT    ; emits Nil event
|type[Interpolation] CONTENT    ; emits Interpolation event
|type[Reference]     CONTENT    ; emits Reference event
|type[RawContent]    CONTENT    ; emits RawContent event
|type[Raw]           CONTENT    ; emits Raw flag event
|type[Integer]       CONTENT    ; emits Integer event (from values.desc)
|type[Float]         CONTENT    ; emits Float event (from values.desc)
|type[Rational]      CONTENT    ; emits Rational event (1/3r)
|type[Complex]       CONTENT    ; emits Complex event (3+4i, 5i)

|type[INT]           INTERNAL   ; no emit - internal integer
|type[BOOL]          INTERNAL   ; no emit - internal boolean


; ============================================================================
; Entry Point
; ============================================================================

|entry-point /document

|function[document]
  |state[:line]
    |c['\n']                  | ->                               |>>
    |c[' ']                   | col = /count_indent              |>> :dispatch
    |c['\t']                  | /error(no_tabs) | ->['\n']       |>> :line
    |default                  | col = COL - 1                    |>> :dispatch  ; use actual column

  |state[:dispatch]
    |c['|']                   | ->                               |>> :check_pipe
    |c[':']                   | -> | /block_attr                 |>> :line
    |c['!']                   | -> | /block_directive(col)       |>> :line
    |c[';']                   | -> | /line_comment               |>> :line
    |c['`']                   | ->                               |>> :check_freeform
    |c[<SQ>]                  | ->                               |>> :check_apos
    |default                  | /prose(col, -1, <>)              |>> :line

  ; Block-level escape: ' followed by marker char outputs that char literally
  ; Per FULL-SPEC.md lines 104-124: '+ |;:!' = escape, else preserve '
  |state[:check_apos]
    |c['|']                   | -> | /prose(col, -1, '|')        |>> :line
    |c[';']                   | -> | /prose(col, -1, ';')        |>> :line
    |c[':']                   | -> | /prose(col, -1, ':')        |>> :line
    |c['!']                   | -> | /prose(col, -1, '!')        |>> :line
    |c[<SQ>]                  | -> | /prose(col, -1, <SQ>)       |>> :line
    |default                  | /prose(col, -1, <SQ>)            |>> :line  ; not escape, preserve '

  |state[:check_freeform]
    |c['`']                   | ->                               |>> :check_freeform2
    |default                  | /prose(col, -1, '`')             |>> :line

  |state[:check_freeform2]
    |c['`']                   | -> | /freeform                   |>> :line
    |default                  | /prose_backticks(col, -1)        |>> :line

  |state[:check_pipe]
    |c[<XLBL_START SQ '[' '.?!*+'>]  | /element(col, -1)               |>> :line
    |c['{']                   | -> | /embedded                   |>> :line
    |default                  | /prose(col, -1, '|')             |>> :line


; ============================================================================
; Utilities
; ============================================================================

|function[count_indent:INT]  | result = 0
  |state[:main]
    |c[' ']                   | -> | result += 1                 |>>
    |default                  |                                  |return result


; NOTE: Error events are emitted inline where needed, e.g. Error(no_tabs)
; No separate error function needed - the generator handles error codes.


; ============================================================================
; Element Identity Parsing (shared between element and embedded)
; ============================================================================

; DRYed: parse_element_identity(:close) - void helper for element identity
; Parses: name[id].class.class?!*+
; :close = closer byte (} for embedded, 0 for block element)
; Returns when identity complete or closer hit. Caller handles content.
|function[parse_element_identity]  :close
  |state[:identity]
    |c[:close]                |                                  |return  ; closer hit (empty)
    |c[XLBL_START]                | /name                            |>> :post_name
    |c[<SQ>]                  | ->                               |>> :quoted_name
    |c['[']                   | ->                               |>> :bracket
    |c['.']                   |                                  |>> :class
    |c['?!*+']                | /suffix                          |return  ; identity done
    |default                  |                                  |return  ; anonymous, identity done

  |state[:quoted_name]
    |c[<SQ>]                  | ->                               |>> :post_name
    |default                  | /quoted_name                     |>> :post_name

  |state[:post_name]
    |c[:close]                |                                  |return
    |c['[']                   | ->                               |>> :bracket
    |c['.']                   |                                  |>> :class
    |c['?!*+']                | /suffix                          |return
    |default                  |                                  |return

  |state[:bracket]
    |c[']']                   | ->                               |>> :post_bracket
    |default                  | Attr($id) | /value_bracket       |>> :bracket_close

  |state[:bracket_close]
    |c[']']                   | ->                               |>> :post_bracket
    |default                  |                                  |return  ; unclosed

  |state[:post_bracket]
    |c[:close]                |                                  |return
    |c['.']                   |                                  |>> :class
    |c['?!*+']                | /suffix                          |return
    |default                  |                                  |return

  |state[:class]
    |c['.']                   | ->                               |>>
    |c[XLBL_START]                | Attr($class) | /class_name       |>> :post_class
    |c[<SQ>]                  | Attr($class) | -> | /quoted_class |>> :post_class
    |default                  |                                  |return  ; no more classes

  |state[:post_class]
    |c[:close]                |                                  |return
    |c['.']                   |                                  |>> :class
    |c['?!*+']                | /suffix                          |return
    |default                  |                                  |return


; ============================================================================
; Element (block form - indent-based children)
; ============================================================================

|function[element:Element]  :elem_col :parent_col

  |state[:identity]
    | /parse_element_identity(<>)                                |>> :post_identity

  |state[:post_identity]
    |c['\n']                  | ->                               |>> :children
    |c[' \t']                 | ->                               |>> :pre_content
    |default                  | /sameline_text(:elem_col, <>)     |>> :children

  |state[:pre_content]
    |c['\n']                  | ->                               |>> :children
    |c[' \t']                 | ->                               |>>
    |c[':']                   | -> | /sameline_attr              |>>
    |c['|']                   | ->                               |>> :check_sameline_pipe
    |c[';']                   | ->                               |>> :check_sameline_semi
    |c['!']                   | ->                               |>> :check_sameline_bang
    |default                  | /sameline_text(:elem_col, <>)     |>> :children

  |state[:check_sameline_pipe]
    |c['{']                   | -> | /embedded                   |>> :post_child
    |c[<XLBL_START SQ '[' '.?!*+'>]  | /element(COL - 1, :elem_col)    |>> :post_child
    |default                  | /sameline_text(:elem_col, '|')   |>> :children

  |state[:check_sameline_semi]
    |c['{']                   | -> | /brace_comment              |>> :pre_content
    |default                  | /line_comment_content            |>> :children

  |state[:check_sameline_bang]
    |c['{']                   | -> | /sameline_directive           |>> :post_sameline_inline
    |default                  | /sameline_text(:elem_col, '!')   |>> :children

  ; After inline directive on sameline - don't skip spaces, they're content now
  |state[:post_sameline_inline]
    |c['\n']                  | ->                               |>> :children
    |eof                      |                                  |return
    |default                  | /sameline_text(:elem_col, <>)    |>> :children

  |state[:post_child]
    |c['\n']                  | ->                               |>> :children
    |c[' \t']                 | ->                               |>>
    |c['|']                   | ->                               |>> :check_sameline_pipe
    |default                  | /sameline_text(:elem_col, <>)     |>> :children

  ; === Children Loop ===
  ; NOTE: count_indent returns 0-based column, but COL is 1-based
  |state[:children]
    |c['\n']                  | ->                               |>>
    |c[' ']                   | col = /count_indent              |>> :check_child
    |c['\t']                  | /error(no_tabs) | ->['\n']       |>>
    |default                  | col = COL - 1                    |>> :check_child

  |state[:check_child]
    |if[col <= :elem_col]                                        |return  ; dedent
    |                                                            |>> :child_dispatch

  |state[:child_dispatch]
    |c['|']                   | ->                               |>> :child_pipe
    |c[':']                   | -> | /block_attr                 |>> :children
    |c['!']                   | -> | /block_directive(col)       |>> :children
    |c[';']                   | -> | /line_comment               |>> :children
    |c[<SQ>]                  | ->                               |>> :child_apos
    |default                  | /prose(col, :elem_col, <>)       |>> :children

  ; Block-level escape inside element children (same as document-level)
  |state[:child_apos]
    |c['|']                   | -> | /prose(col, :elem_col, '|') |>> :children
    |c[';']                   | -> | /prose(col, :elem_col, ';') |>> :children
    |c[':']                   | -> | /prose(col, :elem_col, ':') |>> :children
    |c['!']                   | -> | /prose(col, :elem_col, '!') |>> :children
    |c[<SQ>]                  | -> | /prose(col, :elem_col, <SQ>)|>> :children
    |default                  | /prose(col, :elem_col, <SQ>)     |>> :children

  |state[:child_pipe]
    |c['{']                   | -> | /embedded                   |>> :after_child
    |c[<XLBL_START SQ '[' '.?!*+'>] | /element(col, :elem_col)         |>> :after_child
    |default                  | /prose(col, :elem_col, '|')      |>> :children

  ; After child element/embedded returns - always re-check column for potential dedent
  |state[:after_child]
    |                                                            |>> :children


; ============================================================================
; Names (element/class names)
; ============================================================================

|function[name:Name]  | MARK
  |state[:main]
    |c[XLBL_CONT]             | ->                               |>>
    |default                  | TERM                             |return


; DRYed: skip_single_quoted - void helper for '-quoted content with escapes
; Consumes up to and including closing '. Caller handles MARK/TERM/emit.
|function[skip_single_quoted]
  |state[:main]
    |c[<SQ>]                  | ->                               |return
    |c[<BS>]                  | -> | ->                          |>>
    |default                  | ->                               |>>


|function[quoted_name:Name]  | MARK
  |state[:main]
    | /skip_single_quoted | TERM(-1)                             |return


|function[class_name:BareValue]  | MARK
  |state[:main]
    |c[XLBL_CONT]             | ->                               |>>
    |default                  | TERM                             |return


|function[quoted_class:BareValue]  | MARK
  |state[:main]
    | /skip_single_quoted | TERM(-1)                             |return


; ============================================================================
; Attributes
; ============================================================================

|function[suffix]
  |state[:main]
    |c['?']                   | Attr(?) | BoolTrue | ->          |return
    |c['!']                   | Attr(!) | BoolTrue | ->          |return
    |c['*']                   | Attr(*) | BoolTrue | ->          |return
    |c['+']                   | Attr(+) | BoolTrue | ->          |return
    |default                  |                                  |return


|function[block_attr]
  |state[:key]
    |c[XLBL_START]                | /attr_key                        |>> :value_start
    |c[<SQ>]                  | -> | /attr_key_quoted            |>> :value_start

  |state[:value_start]
    |c[' \t']                 | ->                               |>>
    |c['\n']                  | BoolTrue                         |return
    |default                  | /value(0, '\0')                  |return


|function[sameline_attr]
  |state[:key]
    |c[XLBL_START]                | /attr_key                        |>> :value_start
    |c[<SQ>]                  | -> | /attr_key_quoted            |>> :value_start

  |state[:value_start]
    |c[' \t']                 | ->                               |>>
    |c['\n:|']                | BoolTrue                         |return
    |default                  | /value(1, '\0')                  |return


|function[sameline_attr_embedded]
  |state[:key]
    |c[XLBL_START]                | /attr_key                        |>> :value_start
    |c[<SQ>]                  | -> | /attr_key_quoted            |>> :value_start

  |state[:value_start]
    |c[' \t']                 | ->                               |>>
    |c[<'\n:|' '}'>]           | BoolTrue                         |return
    |default                  | /value(1, '}')                   |return


|function[attr_key:Attr]  | MARK
  |state[:main]
    |c[XLBL_CONT]             | ->                               |>>
    |default                  | TERM                             |return


|function[attr_key_quoted:Attr]  | MARK
  |state[:main]
    | /skip_single_quoted | TERM(-1)                             |return


; ============================================================================
; Values
; ============================================================================

; Value parsing - unified function with context parameters
;   :space_term = 0 (block: space is content) or 1 (space terminates)
;   :bracket = 0 (none), '}' (embedded), ']' (array)
|function[value]  :space_term :bracket
  |state[:start]
    |c[<DQ>]                  | -> | /double_quoted              |return
    |c[<SQ>]                  | -> | /single_quoted              |return
    |c['[']                   | /array                           |return  ; array owns its delimiter
    |default                  | MARK | /typed_value(:space_term, :bracket) |return

; Bracket ID value - IDs are always BareValue (no type detection)
; Space or ] terminates
|function[value_bracket:BareValue]  | MARK
  |state[:main]
    |c[']']                   | TERM                             |return
    |c[' ']                   | TERM                             |return
    |default                  | ->                               |>>

; Quoted string parsing - separate functions for each quote type
; (parameterized version had scan optimization issues with :quote)
|function[double_quoted:StringValue]  | MARK
  |state[:main]
    |c[<DQ>]                  | TERM | ->                        |return
    |c[<BS>]                  | -> | ->                          |>>
    |default                  | ->                               |>>

|function[single_quoted:StringValue]  | MARK
  |state[:main]
    |c[<SQ>]                  | TERM | ->                        |return
    |c[<BS>]                  | -> | ->                          |>>
    |default                  | ->                               |>>

; Array - items are space-separated, ] terminates
; Array owns its delimiter; items are values (quotes, nested arrays, typed values)
|function[array:Array]
  |state[:entry]
    |c['[']  | ->                                                 |>> :items
  |state[:items]
    |c[']']  | ->                                                 |return
    |c[' \t\n'] | ->                                              |>>
    |default | /value(1, ']')                                     |>>


; ============================================================================
; Prose / Text
; ============================================================================

; prose - block-level text content with optional prepend character
; :prepend = <> (none), '|' (pipe prefix), '`' (backtick prefix)
|function[prose]  :line_col :parent_col :prepend
  |if[:parent_col >= 0 && :line_col <= :parent_col]          |return  ; dedent

  |state[:content]
    | /text(:line_col, :parent_col, :prepend)                    |return


; prose_backticks - two backticks (not freeform, just text starting with ``)
|function[prose_backticks]  :line_col :parent_col
  |if[:parent_col >= 0 && :line_col <= :parent_col]          |return

  |state[:content]
    | /text_backticks(:line_col, :parent_col)                    |return


; text_backticks - text that starts with `` (for non-freeform case)
; Manual emit control, no :Text auto-emit
|function[text_backticks]  :line_col :parent_col
  |state[:entry]
    | MARK | PREPEND('`') | PREPEND('`')                         |>> :main

  |state[:main]
    |eof                      | TERM | Text(USE_MARK)            |return
    |c['\n']                  | TERM | Text(USE_MARK)            |return
    |c['|']                   | ->                               |>> :check_pipe
    |c[';']                   | ->                               |>> :check_semi
    |c['!']                   | ->                               |>> :check_bang
    |default                  | ->                               |>>

  |state[:check_pipe]
    |eof                      | TERM | Text(USE_MARK)            |return  ; include | in text
    |c['{']                   | TERM(-1) | Text(USE_MARK) | -> | /embedded |>> :after_inline
    |default                  |                                  |>> :main

  |state[:check_semi]
    |eof                      | TERM | Text(USE_MARK)            |return  ; include ; in text
    |c['{']                   | TERM(-1) | Text(USE_MARK) | -> | /brace_comment |>> :after_inline
    |default                  | TERM(-1) | Text(USE_MARK) | /line_comment_content |return

  |state[:check_bang]
    |eof                      | TERM | Text(USE_MARK)            |return  ; include ! in text
    |c['{']                   | TERM(-1) | Text(USE_MARK) | -> | /sameline_directive |>> :after_inline
    |default                  |                                  |>> :main

  ; After inline construct - only set MARK if more content follows
  |state[:after_inline]
    |c['\n']                  |                                  |return  ; at end, no emit
    |eof                      |                                  |return  ; at end, no emit
    |default                  | MARK                             |>> :main


; ============================================================================
; Freeform Blocks (```)
; ============================================================================

; Freeform block - captures content until closing ```
|function[freeform:Freeform]
  |state[:lang]
    |c['\n']                  | ->                               |>> :content
    |c[XLBL_START]                | /name                            |>> :eol
    |default                  |                                  |>> :content

  |state[:eol]
    |c['\n']                  | ->                               |>> :content
    |default                  | ->                               |>>  ; consume rest of line

  |state[:content]
    |c['\n']                  | ->                               |>>
    |c['`']                   |                                  |>> :maybe_end
    |default                  | MARK                             |>> :line

  |state[:line]
    |c['\n']                  | TERM | RawContent(USE_MARK) | -> |>> :content
    |default                  | ->                               |>>

  |state[:maybe_end]
    |c['`']                   | ->                               |>> :maybe_end2
    |default                  | MARK | PREPEND('`')              |>> :line

  |state[:maybe_end2]
    |c['`']                   | -> | ->                          |return  ; consume final `
    |default                  | MARK | PREPEND('``')             |>> :line


; text - block-level prose content (manual emit control, no :Text auto-emit)
; Same pattern as sameline_text: advance past special chars, check what follows.
; :prepend = <> (none), '|' (pipe prefix), '`' (backtick prefix)
|function[text]  :line_col :parent_col :prepend
  |state[:entry]
    | MARK | PREPEND(:prepend)                                   |>> :main

  |state[:main]
    |eof                      | TERM | Text(USE_MARK)            |return
    |c['\n']                  | TERM | Text(USE_MARK)            |return
    |c['|']                   | ->                               |>> :check_pipe
    |c[';']                   | ->                               |>> :check_semi
    |c['!']                   | ->                               |>> :check_bang
    |default                  | ->                               |>>

  |state[:check_pipe]
    |eof                      | TERM | Text(USE_MARK)            |return  ; include | in text
    |c['{']                   | TERM(-1) | Text(USE_MARK) | -> | /embedded |>> :after_inline
    |default                  |                                  |>> :main

  |state[:check_semi]
    |eof                      | TERM | Text(USE_MARK)            |return  ; include ; in text
    |c['{']                   | TERM(-1) | Text(USE_MARK) | -> | /brace_comment |>> :after_inline
    |default                  | TERM(-1) | Text(USE_MARK) | /line_comment_content |return

  |state[:check_bang]
    |eof                      | TERM | Text(USE_MARK)            |return  ; include ! in text
    |c['{']                   | TERM(-1) | Text(USE_MARK) | -> | /sameline_directive |>> :after_inline
    |default                  |                                  |>> :main

  ; After inline construct - only set MARK if more content follows
  |state[:after_inline]
    |c['\n']                  |                                  |return  ; at end, no emit
    |eof                      |                                  |return  ; at end, no emit
    |default                  | MARK                             |>> :main


; sameline_text - text on same line as element (manual emit control, no :Text auto-emit)
; When special chars (|;!) are encountered, we advance past them, then check
; what follows. If special construct, emit text before it and parse construct.
; If not special, just continue (char is included in text).
; :prepend = <> (none), '|' (pipe prefix), '!' (bang prefix)
|function[sameline_text]  :elem_col :prepend
  |state[:entry]
    | MARK | PREPEND(:prepend)                                   |>> :main

  |state[:main]
    |eof                      | TERM | Text(USE_MARK)            |return
    |c['\n']                  | TERM | Text(USE_MARK)            |return
    |c['|']                   | ->                               |>> :check_pipe
    |c[';']                   | ->                               |>> :check_semi
    |c['!']                   | ->                               |>> :check_bang
    |default                  | ->                               |>>

  |state[:check_pipe]
    |eof                      | TERM | Text(USE_MARK)            |return  ; include | in text
    |c['{']                   | TERM(-1) | Text(USE_MARK) | -> | /embedded |>> :after_inline
    |c[<XLBL_START SQ '[' '.?!*+'>] | TERM(-1) | Text(USE_MARK) | /element(COL - 1, :elem_col) |>> :after_inline
    |default                  |                                  |>> :main

  |state[:check_semi]
    |eof                      | TERM | Text(USE_MARK)            |return  ; include ; in text
    |c['{']                   | TERM(-1) | Text(USE_MARK) | -> | /brace_comment |>> :after_inline
    |default                  | TERM(-1) | Text(USE_MARK) | /line_comment_content |return

  |state[:check_bang]
    |eof                      | TERM | Text(USE_MARK)            |return  ; include ! in text
    |c['{']                   | TERM(-1) | Text(USE_MARK) | -> | /sameline_directive |>> :after_inline
    |default                  |                                  |>> :main

  ; After inline construct - only set MARK if more content follows
  |state[:after_inline]
    |c['\n']                  |                                  |return  ; at end, no emit
    |eof                      |                                  |return  ; at end, no emit
    |default                  | MARK                             |>> :main


; ============================================================================
; Comments
; ============================================================================

|function[line_comment]
  |state[:check]
    |c['{']                   | -> | /brace_comment              |return
    |default                  | /line_comment_content            |return


; DRYed: line_comment_content - captures content to newline or EOF, emits Comment
; Used by all line comment variants (they were 100% identical)
|function[line_comment_content:Comment]  | MARK
  |state[:main]
    |eof                      | TERM                             |return  ; EOF is valid end
    |c['\n']                  | TERM                             |return
    |default                  | ->                               |>>


; DRYed: skip_brace_balanced - void helper for {}-counting
; Caller handles MARK/TERM and emit type. Assumes opening { already consumed.
; Returns with position AT the closing } (not consumed)
|function[skip_brace_balanced]  | depth = 1
  |state[:main]
    |c['{']                   | -> | depth += 1                  |>>
    |c['}']                   | depth -= 1                       |>> :check
    |default                  | ->                               |>>

  |state[:check]
    |if[depth == 0]                                              |return  ; stop before }
    | ->                                                         |>> :main  ; consume } and continue


|function[brace_comment:Comment]  | MARK
  |state[:main]
    | /skip_brace_balanced | TERM | ->                           |return  ; consume the }


; ============================================================================
; Embedded |{...}
; ============================================================================

; DRYed: embedded uses shared parse_element_identity with } as closer
|function[embedded:Embedded]

  |state[:identity]
    | /parse_element_identity('}')                               |>> :post_identity

  |state[:post_identity]
    |c['}']                  | ->                               |return  ; empty or identity-only
    |c[' \t']                 | ->                               |>> :pre_content
    |default                  | /embed_content                   |return

  |state[:pre_content]
    |c['}']                  | ->                               |return
    |c[' \t']                 | ->                               |>>
    |c[':']                   | -> | /sameline_attr_embedded     |>>
    |default                  | /embed_content                   |return


; embed_content - text content inside |{...}
; Handles: text, embedded elements, comments, directives, quoted strings
; Quoted strings are emitted as StringValue to avoid brace confusion
|function[embed_content:Text]  | MARK
  |state[:main]
    |c['}']                  | TERM | ->                        |return
    |c['|']                   | TERM | ->                        |>> :check_pipe
    |c[';']                   | TERM | ->                        |>> :check_semi
    |c['!']                   | TERM | ->                        |>> :check_bang
    |c[<DQ>]                  | TERM | Text(USE_MARK) | -> | /double_quoted | MARK |>> :main
    |c[<SQ>]                  | TERM | Text(USE_MARK) | -> | /single_quoted | MARK |>> :main
    |default                  | ->                               |>>

  |state[:check_pipe]
    ; Inside embedded, only |{...} allowed
    |c['{']                   | -> | /embedded | MARK            |>> :main
    |default                  | MARK | PREPEND('|')              |>> :main

  |state[:check_semi]
    |c['{']                   | -> | /brace_comment | MARK       |>> :main
    |default                  | MARK | PREPEND(';')              |>> :main

  |state[:check_bang]
    |c['{']                   | -> | /sameline_directive | MARK    |>> :main
    |default                  | MARK | PREPEND('!')              |>> :main


; ============================================================================
; Block Directives
; ============================================================================

; Block directive - !name or !:lang: for raw, or !{...} inline at document level
|function[block_directive:Directive]  :line_col
  |state[:dispatch]
    |c[':']                   | ->                               |>> :raw_kind
    |c['{']                   | -> | /sameline_directive            |return  ; !{...} inline form
    |c[XLBL_START]                | /name                            |>> :after_name
    |default                  |                                  |return  ; malformed

  ; Raw block !:lang: - parse kind name
  |state[:raw_kind]
    |c[XLBL_START]                | /name | Raw                      |>> :raw_colon
    |default                  |                                  |return  ; malformed !:

  |state[:raw_colon]
    |c[':']                   | ->                               |>> :raw_eol
    |default                  |                                  |return  ; missing second :

  |state[:raw_eol]
    |c['\n']                  | ->                               |>> :raw_content
    |c[' \t']                 | ->                               |>>
    |default                  | ->                               |>>  ; consume rest of line

  ; Raw content - capture everything at greater indent
  |state[:raw_content]
    |c['\n']                  | ->                               |>>
    |c[' ']                   | col = /count_indent              |>> :raw_check
    |default                  |                                  |return  ; non-indented, done

  |state[:raw_check]
    |if[col <= :line_col]                                         |return  ; dedent
    |default                  | MARK                             |>> :raw_line

  |state[:raw_line]
    |eof                      | TERM | RawContent(USE_MARK)      |return
    |c['\n']                  | TERM | RawContent(USE_MARK) | -> |>> :raw_content
    |default                  | ->                               |>>

  ; Regular directive - parse condition/args and children
  |state[:after_name]
    |c['\n']                  | ->                               |>> :children
    |c[' \t']                 | ->                               |>> :condition
    |default                  |                                  |>> :children

  |state[:condition]
    |c['\n']                  | ->                               |>> :children
    |default                  | MARK | /directive_args           |>> :children

  ; Children at greater indent
  |state[:children]
    |c['\n']                  | ->                               |>>
    |c[' ']                   | col = /count_indent              |>> :check_child
    |c['\t']                  | /error(no_tabs) | ->['\n']       |>>
    |default                  | col = COL - 1                    |>> :check_child

  |state[:check_child]
    |if[col <= :line_col]                                         |return
    |                                                            |>> :child_dispatch

  |state[:child_dispatch]
    |c['|']                   | ->                               |>> :child_pipe
    |c[':']                   | -> | /block_attr                 |>> :children
    |c['!']                   | -> | /block_directive(col)       |>> :children
    |c[';']                   | -> | /line_comment               |>> :children
    |c[<SQ>]                  | ->                               |>> :child_apos
    |default                  | /prose(col, :line_col, <>)       |>> :children

  ; Block-level escape inside directive children
  |state[:child_apos]
    |c['|']                   | -> | /prose(col, :line_col, '|') |>> :children
    |c[';']                   | -> | /prose(col, :line_col, ';') |>> :children
    |c[':']                   | -> | /prose(col, :line_col, ':') |>> :children
    |c['!']                   | -> | /prose(col, :line_col, '!') |>> :children
    |c[<SQ>]                  | -> | /prose(col, :line_col, <SQ>)|>> :children
    |default                  | /prose(col, :line_col, <SQ>)     |>> :children

  |state[:child_pipe]
    |c['{']                   | -> | /embedded                   |>> :children
    |c[<XLBL_START SQ '[' '.?!*+'>] | /element(col, :line_col)         |>> :children
    |default                  | /prose(col, :line_col, '|')      |>> :children


; Directive arguments - capture until newline or EOF
|function[directive_args:Text]
  |state[:main]
    |eof                      | TERM                             |return
    |c['\n']                  | TERM                             |return
    |default                  | ->                               |>>


; Inline dynamics - dispatch based on first char after {
; Called with position at first char inside braces
|function[sameline_directive]
  |state[:dispatch]
    |c['{']                   | -> | /interpolation              |return  ; !{{expr}}
    |c[':']                   | -> | /sameline_raw                 |return  ; !{:kind: content}
    |default                  | /sameline_dir_body                 |return  ; !{name args}


; Interpolation !{{expr}} - double-brace
|function[interpolation:Interpolation]  | MARK
  |state[:main]
    |c['}']                  | TERM | -> | ->                   |return  ; consume }}
    |default                  | ->                               |>>


; Inline raw !{:kind: content}
; sameline_raw - raw content inside !{:kind:...}
; Per FULL-SPEC.md lines 796-797: uses brace-counting for nested {} pairs
|function[sameline_raw:Directive]  | depth = 0
  |state[:kind]
    |c[':']                   | ->                               |>> :content
    |default                  | /name                            |>>  ; kind name

  |state[:content]
    | MARK                                                       |>> :scan

  |state[:scan]
    |c['{']                   | -> | depth += 1                  |>>  ; nested open
    |c['}']                   |                                  |>> :check_close
    |default                  | ->                               |>>

  |state[:check_close]
    |if[depth > 0]            | -> | depth -= 1                  |>> :scan  ; nested close
    |default                  | TERM | RawContent(USE_MARK) | -> |return    ; final close


; Regular inline directive !{name args}
|function[sameline_dir_body:Directive]
  |state[:name]
    |c[XLBL_START]                | /name                            |>> :after_name
    |default                  | /skip_brace_balanced             |return  ; malformed

  |state[:after_name]
    |c['}']                  | ->                               |return
    |c[' \t']                 | ->                               |>> :args
    |default                  | /skip_brace_balanced             |return

  |state[:args]
    |c['}']                  | ->                               |return
    |default                  | /skip_brace_balanced             |return  ; TODO: parse args properly
