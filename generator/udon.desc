; UDON Parser - Clean Recursive Descent (v4)
;
; Design:
;   1. Type system declares emit behavior
;   2. EOF handling inferred from context
;   3. No explicit emit() calls
;   4. DSL describes grammar, generator infers mechanics
;
; Type categories:
;   BRACKET  - emits Start on entry, End on exit (Element, Embedded, Directive, Array)
;   CONTENT  - emits event on return (Name, Text, Comment, Attr, Value, etc.)
;   INTERNAL - no emit, used for intermediate values (indent count, flags)

|parser udon

; ============================================================================
; Type Declarations
; ============================================================================

|type[Element]       BRACKET    ; ElementStart on entry, ElementEnd on exit
|type[Embedded]      BRACKET    ; EmbeddedStart/End
|type[Directive]     BRACKET    ; DirectiveStart/End
|type[Array]         BRACKET    ; ArrayStart/End
|type[Freeform]      BRACKET    ; FreeformStart/End

|type[Name]          CONTENT    ; emits Name event on return
|type[Text]          CONTENT    ; emits Text event
|type[Comment]       CONTENT    ; emits Comment event
|type[Attr]          CONTENT    ; emits Attr event
|type[StringValue]   CONTENT    ; emits StringValue event
|type[BareValue]     CONTENT    ; emits BareValue event
|type[BoolTrue]      CONTENT    ; emits BoolTrue event
|type[BoolFalse]     CONTENT    ; emits BoolFalse event
|type[Nil]           CONTENT    ; emits Nil event
|type[Interpolation] CONTENT    ; emits Interpolation event
|type[Reference]     CONTENT    ; emits Reference event
|type[RawContent]    CONTENT    ; emits RawContent event
|type[Raw]           CONTENT    ; emits Raw flag event

|type[INT]           INTERNAL   ; no emit - internal integer
|type[BOOL]          INTERNAL   ; no emit - internal boolean


; ============================================================================
; Entry Point
; ============================================================================

|entry-point /document

|function[document]
  |state[:line]
    |c[\n]                    | ->                               |>>
    |c[ ]                     | col = /count_indent              |>> :dispatch
    |c[\t]                    | Error(no_tabs) | ->[\n]          |>> :line
    |default                  | col = 0                          |>> :dispatch

  |state[:dispatch]
    |c[|]                     | ->                               |>> :check_pipe
    |c[:]                     | -> | /block_attr                 |>> :line
    |c[!]                     | -> | /block_directive(col)       |>> :line
    |c[;]                     | -> | /line_comment               |>> :line
    |c[']                     | -> | /prose(col, -1)             |>> :line
    |default                  | /prose(col, -1)                  |>> :line

  |state[:check_pipe]
    |c[LETTER'[.?!*+]         | /element(col, -1)                |>> :line
    |c[{]                     | /embedded                        |>> :line
    |default                  | /prose_pipe(col, -1)             |>> :line


; ============================================================================
; Utilities
; ============================================================================

|function[count_indent:INT]  | result = 0
  |state[:main]
    |c[ ]                     | -> | result += 1                 |>>
    |default                  |                                  |return result


; NOTE: Error events are emitted inline where needed, e.g. Error(no_tabs)
; No separate error function needed - the generator handles error codes.


; ============================================================================
; Element Identity Parsing (shared between element and embedded)
; ============================================================================

; DRYed: parse_element_identity(:close) - void helper for element identity
; Parses: name[id].class.class?!*+
; :close = closer byte (} for embedded, 0 for block element)
; Returns when identity complete or closer hit. Caller handles content.
|function[parse_element_identity]  :close
  |state[:identity]
    |c[:close]                |                                  |return  ; closer hit (empty)
    |c[LETTER]                | /name                            |>> :post_name
    |c[']                     | ->                               |>> :quoted_name
    |c[<L>]                     |                                  |>> :bracket
    |c[.]                     |                                  |>> :class
    |c[?!*+]                  | /suffix                          |return  ; identity done
    |default                  |                                  |return  ; anonymous, identity done

  |state[:quoted_name]
    |c[']                     | ->                               |>> :post_name
    |default                  | /quoted_name                     |>> :post_name

  |state[:post_name]
    |c[:close]                |                                  |return
    |c[<L>]                     | ->                               |>> :bracket
    |c[.]                     |                                  |>> :class
    |c[?!*+]                  | /suffix                          |return
    |default                  |                                  |return

  |state[:bracket]
    |c[<R>]                     | ->                               |>> :post_bracket
    |default                  | Attr($id) | /value               |>> :bracket_close

  |state[:bracket_close]
    |c[<R>]                     | ->                               |>> :post_bracket
    |default                  |                                  |return  ; unclosed

  |state[:post_bracket]
    |c[:close]                |                                  |return
    |c[.]                     |                                  |>> :class
    |c[?!*+]                  | /suffix                          |return
    |default                  |                                  |return

  |state[:class]
    |c[.]                     | ->                               |>>
    |c[LETTER]                | Attr($class) | /class_name       |>> :post_class
    |c[']                     | Attr($class) | -> | /quoted_class |>> :post_class
    |default                  |                                  |return  ; no more classes

  |state[:post_class]
    |c[:close]                |                                  |return
    |c[.]                     |                                  |>> :class
    |c[?!*+]                  | /suffix                          |return
    |default                  |                                  |return


; ============================================================================
; Element (block form - indent-based children)
; ============================================================================

|function[element:Element]  :elem_col :parent_col

  |state[:identity]
    | /parse_element_identity(0)                                 |>> :post_identity

  |state[:post_identity]
    |c[\n]                    | ->                               |>> :children
    |c[ \t]                   | ->                               |>> :pre_content
    |default                  | /inline_text(elem_col)           |>> :children

  |state[:pre_content]
    |c[\n]                    | ->                               |>> :children
    |c[ \t]                   | ->                               |>>
    |c[:]                     | -> | /inline_attr                |>>
    |c[|]                     | ->                               |>> :check_inline_pipe
    |c[;]                     | ->                               |>> :check_inline_semi
    |c[!]                     | ->                               |>> :check_inline_bang
    |default                  | /inline_text(elem_col)           |>> :children

  |state[:check_inline_pipe]
    |c[{]                     | /embedded                        |>> :post_child
    |c[LETTER'[.?!*+]         | /element(COL, elem_col)          |>> :post_child
    |default                  | /inline_text_pipe(elem_col)      |>> :children

  |state[:check_inline_semi]
    |c[{]                     | /brace_comment                   |>> :pre_content
    |default                  | /line_comment_content            |>> :children

  |state[:check_inline_bang]
    |c[{]                     | -> | /inline_directive           |>> :pre_content
    |default                  | /inline_text_bang(elem_col)      |>> :children

  |state[:post_child]
    |c[\n]                    | ->                               |>> :children
    |c[ \t]                   | ->                               |>>
    |c[|]                     | ->                               |>> :check_inline_pipe
    |default                  | /inline_text(elem_col)           |>> :children

  ; === Children Loop ===
  |state[:children]
    |c[\n]                    | ->                               |>>
    |c[ ]                     | col = /count_indent              |>> :check_child
    |c[\t]                    | Error(no_tabs) | ->[\n]          |>>
    |default                  | col = 0                          |>> :check_child

  |state[:check_child]
    |if[col <= elem_col]                                         |return  ; dedent
    |                                                            |>> :child_dispatch

  |state[:child_dispatch]
    |c[|]                     | ->                               |>> :child_pipe
    |c[:]                     | -> | /block_attr                 |>> :children
    |c[!]                     | -> | /block_directive(col)       |>> :children
    |c[;]                     | -> | /line_comment               |>> :children
    |c[']                     | -> | /prose(col, elem_col)       |>> :children
    |default                  | /prose(col, elem_col)            |>> :children

  |state[:child_pipe]
    |c[{]                     | /embedded                        |>> :children
    |c[LETTER'[.?!*+]         | /element(col, elem_col)          |>> :children
    |default                  | /prose_pipe(col, elem_col)       |>> :children


; ============================================================================
; Names (element/class names)
; ============================================================================

|function[name:Name]  | MARK
  |state[:main]
    |c[LABEL_CONT]            | ->                               |>>
    |default                  | TERM                             |return


; DRYed: skip_single_quoted - void helper for '-quoted content with escapes
; Consumes up to and including closing '. Caller handles MARK/TERM/emit.
|function[skip_single_quoted]
  |state[:main]
    |c[']                     | ->                               |return
    |c[\\]                    | -> | ->                          |>>
    |default                  | ->                               |>>


|function[quoted_name:Name]  | MARK
  |state[:main]
    | /skip_single_quoted | TERM(-1)                             |return


|function[class_name:StringValue]  | MARK
  |state[:main]
    |c[LABEL_CONT]            | ->                               |>>
    |default                  | TERM                             |return


|function[quoted_class:StringValue]  | MARK
  |state[:main]
    | /skip_single_quoted | TERM(-1)                             |return


; ============================================================================
; Attributes
; ============================================================================

|function[suffix]
  |state[:main]
    |c[?]                     | Attr(?) | BoolTrue | ->          |return
    |c[!]                     | Attr(!) | BoolTrue | ->          |return
    |c[*]                     | Attr(*) | BoolTrue | ->          |return
    |c[+]                     | Attr(+) | BoolTrue | ->          |return
    |default                  |                                  |return


|function[block_attr]
  |state[:key]
    |c[LETTER]                | /attr_key                        |>> :value_start
    |c[']                     | -> | /attr_key_quoted            |>> :value_start

  |state[:value_start]
    |c[ \t]                   | ->                               |>>
    |c[\n]                    | BoolTrue                         |return
    |default                  | /value                           |return


|function[inline_attr]
  |state[:key]
    |c[LETTER]                | /attr_key                        |>> :value_start
    |c[']                     | -> | /attr_key_quoted            |>> :value_start

  |state[:value_start]
    |c[ \t]                   | ->                               |>>
    |c[\n:|]}]                | BoolTrue                         |return
    |default                  | /value_inline                    |return


|function[attr_key:Attr]  | MARK
  |state[:main]
    |c[LABEL_CONT]            | ->                               |>>
    |default                  | TERM                             |return


|function[attr_key_quoted:Attr]  | MARK
  |state[:main]
    | /skip_single_quoted | TERM(-1)                             |return


; ============================================================================
; Values
; ============================================================================

; Value parsing is minimal here - type detection delegated to values parser
; udon.desc handles structure (arrays, quoted strings), values.desc handles types

|function[value]
  |state[:start]
    |c["]                     | -> | /quoted_string(")           |return
    |c[']                     | -> | /quoted_string(')           |return
    |c[<L>]                   | /array                           |return
    |default                  | /bare_value                      |return


|function[value_inline]
  |state[:start]
    |c["]                     | -> | /quoted_string(")           |return
    |c[']                     | -> | /quoted_string(')           |return
    |c[<L>]                   | /array_inline                    |return
    |default                  | /bare_value_inline               |return


; DRYed: quoted_string(:quote) - parameterized by quote character
|function[quoted_string:StringValue]  :quote  | MARK
  |state[:main]
    |c[:quote]                | TERM | ->                        |return
    |c[\\]                    | -> | ->                          |>>
    |default                  | ->                               |>>


|function[bare_value:BareValue]  | MARK
  |state[:main]
    |c[\n ]}]                 | TERM                             |return
    |default                  | ->                               |>>


|function[bare_value_inline:BareValue]  | MARK
  |state[:main]
    |c[\n :|]}]               | TERM                             |return
    |default                  | ->                               |>>


; NOTE: Type detection (true/false/null/numbers) moved to values.desc
; BareValue events are post-processed by values parser for type classification

|function[array:Array]
  |state[:items]
    |c[<R>]                     | ->                               |return
    |c[ \t\n]                 | ->                               |>>
    |default                  | /value                           |>>


|function[array_inline:Array]
  |state[:items]
    |c[<R>]                     | ->                               |return
    |c[ \t\n]                 | ->                               |>>
    |default                  | /value_inline                    |>>


; ============================================================================
; Prose / Text
; ============================================================================

|function[prose]  :line_col :parent_col
  |if[parent_col >= 0 && line_col <= parent_col]             |return  ; dedent

  |state[:content]
    | /text(line_col, parent_col)                                |return


|function[prose_pipe]  :line_col :parent_col
  |if[parent_col >= 0 && line_col <= parent_col]             |return  ; dedent

  |state[:content]
    | /text_pipe(line_col, parent_col)                           |return


; NOTE: text and text_pipe have identical check states. text_pipe differs
; only in PREPEND(|) at entry. Keep them in sync!

|function[text:Text]  :line_col :parent_col  | MARK
  |state[:main]
    |c[\n]                    | TERM                             |return
    |c[|]                     | TERM | ->                        |>> :check_pipe
    |c[;]                     | TERM | ->                        |>> :check_semi
    |c[!]                     | TERM | ->                        |>> :check_bang
    |default                  | ->                               |>>

  |state[:check_pipe]
    |c[{]                     | /embedded | MARK                 |>> :main
    |default                  | MARK | PREPEND(|)                |>> :main

  |state[:check_semi]
    |c[{]                     | /brace_comment | MARK            |>> :main
    |default                  | /line_comment_content            |return

  |state[:check_bang]
    |c[{]                     | -> | /inline_directive | MARK    |>> :main
    |default                  | MARK | PREPEND(!)                |>> :main


|function[text_pipe:Text]  :line_col :parent_col  | MARK | PREPEND(|)
  |state[:main]
    |c[\n]                    | TERM                             |return
    |c[|]                     | TERM | ->                        |>> :check_pipe
    |c[;]                     | TERM | ->                        |>> :check_semi
    |c[!]                     | TERM | ->                        |>> :check_bang
    |default                  | ->                               |>>

  |state[:check_pipe]
    |c[{]                     | /embedded | MARK                 |>> :main
    |default                  | MARK | PREPEND(|)                |>> :main

  |state[:check_semi]
    |c[{]                     | /brace_comment | MARK            |>> :main
    |default                  | /line_comment_content            |return

  |state[:check_bang]
    |c[{]                     | -> | /inline_directive | MARK    |>> :main
    |default                  | MARK | PREPEND(!)                |>> :main


|function[inline_text:Text]  :elem_col  | MARK
  |state[:main]
    |c[\n]                    | TERM                             |return
    |c[|]                     | TERM | ->                        |>> :check_pipe
    |c[;]                     | TERM | ->                        |>> :check_semi
    |c[!]                     | TERM | ->                        |>> :check_bang
    |default                  | ->                               |>>

  |state[:check_pipe]
    |c[{]                     | /embedded | MARK                 |>> :main
    |c[LETTER'[.?!*+]         | /element(COL, elem_col) | MARK   |>> :main
    |default                  | MARK | PREPEND(|)                |>> :main

  |state[:check_semi]
    |c[{]                     | /brace_comment | MARK            |>> :main
    |default                  | TERM | /line_comment_content     |return

  |state[:check_bang]
    |c[{]                     | -> | /inline_directive | MARK    |>> :main
    |default                  | MARK | PREPEND(!)                |>> :main


; NOTE: inline_text_pipe and inline_text_bang are clones of inline_text
; with different PREPEND. The DSL doesn't support caller-side PREPEND or
; shared states, so we maintain these as separate functions. Keep in sync!

|function[inline_text_pipe:Text]  :elem_col  | MARK | PREPEND(|)
  |state[:main]
    |c[\n]                    | TERM                             |return
    |c[|]                     | TERM | ->                        |>> :check_pipe
    |c[;]                     | TERM | ->                        |>> :check_semi
    |c[!]                     | TERM | ->                        |>> :check_bang
    |default                  | ->                               |>>

  |state[:check_pipe]
    |c[{]                     | /embedded | MARK                 |>> :main
    |c[LETTER'[.?!*+]         | /element(COL, elem_col) | MARK   |>> :main
    |default                  | MARK | PREPEND(|)                |>> :main

  |state[:check_semi]
    |c[{]                     | /brace_comment | MARK            |>> :main
    |default                  | TERM | /line_comment_content     |return

  |state[:check_bang]
    |c[{]                     | -> | /inline_directive | MARK    |>> :main
    |default                  | MARK | PREPEND(!)                |>> :main


|function[inline_text_bang:Text]  :elem_col  | MARK | PREPEND(!)
  |state[:main]
    |c[\n]                    | TERM                             |return
    |c[|]                     | TERM | ->                        |>> :check_pipe
    |c[;]                     | TERM | ->                        |>> :check_semi
    |c[!]                     | TERM | ->                        |>> :check_bang
    |default                  | ->                               |>>

  |state[:check_pipe]
    |c[{]                     | /embedded | MARK                 |>> :main
    |c[LETTER'[.?!*+]         | /element(COL, elem_col) | MARK   |>> :main
    |default                  | MARK | PREPEND(|)                |>> :main

  |state[:check_semi]
    |c[{]                     | /brace_comment | MARK            |>> :main
    |default                  | TERM | /line_comment_content     |return

  |state[:check_bang]
    |c[{]                     | -> | /inline_directive | MARK    |>> :main
    |default                  | MARK | PREPEND(!)                |>> :main


; ============================================================================
; Comments
; ============================================================================

|function[line_comment]
  |state[:check]
    |c[{]                     | /brace_comment                   |return
    |default                  | /line_comment_content            |return


; DRYed: line_comment_content - captures content to newline, emits Comment
; Used by all line comment variants (they were 100% identical)
|function[line_comment_content:Comment]  | MARK
  |state[:main]
    |c[\n]                    | TERM                             |return
    |default                  | ->                               |>>


; DRYed: skip_brace_balanced - void helper for {}-counting
; Caller handles MARK/TERM and emit type. Assumes opening { already consumed.
|function[skip_brace_balanced]  | depth = 1
  |state[:main]
    |c[{]                     | -> | depth += 1                  |>>
    |c[}]                     | -> | depth -= 1                  |>> :check
    |default                  | ->                               |>>

  |state[:check]
    |if[depth == 0]                                              |return
    |                                                            |>> :main


|function[brace_comment:Comment]  | MARK
  |state[:main]
    | /skip_brace_balanced | TERM(-1)                            |return


; ============================================================================
; Embedded |{...}
; ============================================================================

; DRYed: embedded uses shared parse_element_identity with } as closer
|function[embedded:Embedded]

  |state[:identity]
    | /parse_element_identity(<RB>)                              |>> :post_identity

  |state[:post_identity]
    |c[}]                     | ->                               |return  ; empty or identity-only
    |c[ \t]                   | ->                               |>> :pre_content
    |default                  | /embed_content                   |return

  |state[:pre_content]
    |c[}]                     | ->                               |return
    |c[ \t]                   | ->                               |>>
    |c[:]                     | -> | /inline_attr                |>>
    |default                  | /embed_content                   |return


|function[embed_content:Text]  | MARK | EXPECTS(})
  |state[:main]
    |c[}]                     | TERM                             |return
    |c[|]                     | TERM | ->                        |>> :check_pipe
    |c[;]                     | TERM | ->                        |>> :check_semi
    |c[!]                     | TERM | ->                        |>> :check_bang
    |default                  | ->                               |>>

  |state[:check_pipe]
    ; Inside embedded, only |{...} allowed
    |c[{]                     | /embedded | MARK                 |>> :main
    |default                  | MARK | PREPEND(|)                |>> :main

  |state[:check_semi]
    |c[{]                     | /brace_comment | MARK            |>> :main
    |default                  | MARK | PREPEND(;)                |>> :main

  |state[:check_bang]
    |c[{]                     | -> | /inline_directive | MARK    |>> :main
    |default                  | MARK | PREPEND(!)                |>> :main


; ============================================================================
; Directives (stub)
; ============================================================================

|function[block_directive:Directive]  :line_col
  ; TODO: full implementation
  |state[:main]
    |c[\n]                    |                                  |return
    |default                  | ->                               |>>


|function[inline_directive:Directive]
  ; TODO: full implementation with !{{...}}, !{:kind: ...}, !{name ...}
  ; Uses shared skip_brace_balanced helper
  |state[:main]
    | /skip_brace_balanced                                       |return


; ============================================================================
; DSL Features Used
; ============================================================================
;
; Type declarations:
;   |type[Name]  BRACKET|CONTENT|INTERNAL
;
; Function with return type (parsed content):
;   |function[name:ReturnType]  | MARK
;     ... | TERM | return    ; emits ReturnType with accumulated content
;
; Inline literal events:
;   TypeName              ; emit event with no payload (BoolTrue, Nil)
;   TypeName(literal)     ; emit event with literal value (Attr($id), Attr(?))
;   TypeName(USE_MARK)    ; emit event using current MARK/TERM content
;
; Inferred EOF:
;   - MARK active → TERM
;   - EXPECTS(x) → emit unclosed error for x
;   - Return (BRACKET types emit End, CONTENT types emit event)
;
; EXPECTS(x):
;   Declares this state/function expects closing delimiter x
;   On EOF: emit(Error:unclosed_x)
;
; Other features:
;   MARK, TERM, TERM(-N), PREPEND(x)
;   |if[cond] | actions | transition
;   /function(args) - call with args
;   variable = value, variable += 1
;   COL - current column
;
