//! UDON Streaming Parser - Generated by genmachine
//!
//! This is a generated file. Do not edit directly.
//! Source: {{ machine_file }}
//!
//! This parser uses a ring buffer architecture for true streaming:
//! - Input arrives in chunks via feed()
//! - Events emit to a ring buffer as they're parsed
//! - Backpressure when buffer is full
//! - Chunk arena for zero-copy string references

use crate::span::Span;
use crate::streaming::{ChunkArena, ChunkSlice, EventRing, FeedResult, StreamingEvent};

/// Parser state enum - persists across feed() calls.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ParserState {
    /// Initial state / document level
    Document,
    /// Need more input to complete current token
    NeedInput,
    /// Finished parsing (got finish() call)
    Finished,
    /// Inside a specific parse function
    InFunction { function: FunctionId, state: u16 },
}

/// Function identifiers for nested parsing.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FunctionId {
    Document,
    Element,
    Array,
    // Add more as needed based on DSL functions
}

/// Streaming parser with ring buffer output.
///
/// # Example
///
/// ```ignore
/// let mut parser = StreamingParser::new(1024); // 1024 event capacity
///
/// // Feed chunks of input
/// parser.feed(b"|div Hello");
/// parser.feed(b" World\n");
/// parser.finish();
///
/// // Read events
/// while let Some(event) = parser.read() {
///     println!("{:?}", event);
/// }
/// ```
pub struct StreamingParser {
    // ========== State Machine ==========

    /// Current parser state
    state: ParserState,

    /// Call stack for nested function calls (element within element, etc.)
    /// Each entry is (function_id, local_state, return_state)
    call_stack: Vec<(FunctionId, u16, ParserState)>,

    // ========== Input Management ==========

    /// Arena storing input chunks
    chunks: ChunkArena,

    /// Current chunk index being parsed
    current_chunk: u32,

    /// Position within current chunk
    pos: usize,

    /// Partial token buffer (for tokens split across chunks)
    partial: Vec<u8>,

    /// Whether we're continuing a partial token
    in_partial: bool,

    // ========== Position Tracking ==========

    /// Current line number (1-indexed)
    line: u32,

    /// Current column (1-indexed)
    column: u32,

    /// Position of line start (for column calculation)
    line_start: usize,

    /// Global byte offset (across all chunks)
    global_offset: u64,

    // ========== Accumulation ==========

    /// Mark position for MARK/TERM pattern
    mark_chunk: u32,
    mark_pos: u32,

    // ========== Indentation Tracking ==========

    /// Element stack for indentation-based hierarchy
    /// Each entry is (column, has_children)
    element_stack: Vec<(i32, bool)>,

    // ========== Output ==========

    /// Ring buffer for output events
    events: EventRing,

    /// Whether finish() has been called
    finished: bool,
}

impl StreamingParser {
    /// Create a new streaming parser with the given event buffer capacity.
    pub fn new(event_capacity: usize) -> Self {
        Self {
            state: ParserState::Document,
            call_stack: Vec::with_capacity(16),
            chunks: ChunkArena::new(),
            current_chunk: 0,
            pos: 0,
            partial: Vec::with_capacity(256),
            in_partial: false,
            line: 1,
            column: 1,
            line_start: 0,
            global_offset: 0,
            mark_chunk: 0,
            mark_pos: 0,
            element_stack: Vec::with_capacity(32),
            events: EventRing::new(event_capacity),
            finished: false,
        }
    }

    /// Create with default capacity (1024 events).
    pub fn with_default_capacity() -> Self {
        Self::new(1024)
    }

    // ========== Public API ==========

    /// Feed a chunk of input to the parser.
    ///
    /// Returns information about how much was consumed and how many events were generated.
    /// If the ring buffer fills up, parsing pauses (backpressure).
    pub fn feed(&mut self, chunk: &[u8]) -> FeedResult {
        if self.finished {
            return FeedResult {
                bytes_consumed: 0,
                events_written: 0,
                buffer_full: false,
            };
        }

        // Add chunk to arena
        let chunk_idx = self.chunks.push(chunk.to_vec());
        self.current_chunk = chunk_idx;
        self.pos = 0;

        let events_before = self.events.available();

        // Resume parsing
        self.parse_continue();

        let events_written = self.events.available() - events_before;

        FeedResult {
            bytes_consumed: self.pos,
            events_written,
            buffer_full: self.events.is_full(),
        }
    }

    /// Signal end of input stream.
    ///
    /// Flushes any pending partial tokens and emits final events.
    pub fn finish(&mut self) -> FeedResult {
        if self.finished {
            return FeedResult {
                bytes_consumed: 0,
                events_written: 0,
                buffer_full: false,
            };
        }

        self.finished = true;
        let events_before = self.events.available();

        // Emit any pending element ends
        while !self.element_stack.is_empty() {
            self.emit_element_end();
        }

        FeedResult {
            bytes_consumed: 0,
            events_written: self.events.available() - events_before,
            buffer_full: self.events.is_full(),
        }
    }

    /// Read the next event from the ring buffer.
    ///
    /// Returns None if no events are available.
    pub fn read(&mut self) -> Option<StreamingEvent> {
        self.events.pop()
    }

    /// Peek at the next event without consuming it.
    pub fn peek_event(&self) -> Option<&StreamingEvent> {
        self.events.peek()
    }

    /// Number of events available to read.
    pub fn available(&self) -> usize {
        self.events.available()
    }

    /// Check if parsing is complete (finish called and buffer drained).
    pub fn is_done(&self) -> bool {
        self.finished && self.events.is_empty()
    }

    /// Check if the ring buffer is full (backpressure).
    pub fn is_buffer_full(&self) -> bool {
        self.events.is_full()
    }

    /// Get access to the chunk arena (for resolving ChunkSlice to bytes).
    pub fn arena(&self) -> &ChunkArena {
        &self.chunks
    }

    // ========== Internal Helpers ==========
    //
    // These methods provide compatibility with the generated state machine code.

    /// Check if at end of current chunk (compatibility alias for generated code).
    #[inline]
    fn eof(&self) -> bool {
        self.pos >= self.current_chunk_data().len()
    }

    /// Get current byte without advancing (compatibility alias for generated code).
    #[inline]
    fn peek(&self) -> Option<u8> {
        self.current_chunk_data().get(self.pos).copied()
    }

    /// Get current chunk's data.
    #[inline]
    fn current_chunk_data(&self) -> &[u8] {
        self.chunks.get(self.current_chunk)
            .map(|c| c.data())
            .unwrap_or(&[])
    }

    /// Advance one byte.
    #[inline]
    fn advance(&mut self) {
        if let Some(&b) = self.current_chunk_data().get(self.pos) {
            if b == b'\n' {
                self.line += 1;
                self.column = 1;
                self.pos += 1;
                self.line_start = self.pos;
            } else {
                self.column += 1;
                self.pos += 1;
            }
            self.global_offset += 1;
        }
    }

    /// Mark current position for accumulation.
    #[inline]
    fn mark(&mut self) {
        self.mark_chunk = self.current_chunk;
        self.mark_pos = self.pos as u32;
    }

    /// Get accumulated slice from mark to current position.
    #[inline]
    fn term(&self) -> ChunkSlice {
        // For now, assume mark and current are in same chunk
        // TODO: Handle cross-chunk terms via partial buffer
        ChunkSlice::new(self.mark_chunk, self.mark_pos, self.pos as u32)
    }

    /// Get current column (0-indexed from line start).
    #[inline]
    fn current_column(&self) -> i32 {
        (self.pos - self.line_start) as i32
    }

    /// Create a span from mark to current position.
    #[inline]
    fn span_from_mark(&self) -> Span {
        let start = self.chunks.get(self.mark_chunk)
            .map(|c| c.stream_offset() as usize + self.mark_pos as usize)
            .unwrap_or(0);
        let end = self.chunks.get(self.current_chunk)
            .map(|c| c.stream_offset() as usize + self.pos)
            .unwrap_or(0);
        Span::new(start, end)
    }

    /// Emit an event to the ring buffer.
    #[inline]
    fn emit(&mut self, event: StreamingEvent) {
        // If buffer is full, we'd need to handle backpressure
        // For now, just push (will panic if full)
        let _ = self.events.try_push(event);
    }

    /// Emit ElementEnd event.
    fn emit_element_end(&mut self) {
        if self.element_stack.pop().is_some() {
            self.emit(StreamingEvent::ElementEnd {
                span: Span::new(self.global_offset as usize, self.global_offset as usize),
            });
        }
    }

    /// Emit special attribute for identity parsing ($id, $class, suffixes).
    /// These are synthetic keys that don't come from the input.
    fn emit_special_attribute(&mut self, key: &str) {
        // For special attributes, we need to handle them differently
        // since the key is a static string, not from input.
        // We'll create a synthetic ChunkSlice pointing to the current position.
        let span = self.span_from_mark();
        // For now, use a workaround - store the key somehow
        // TODO: Better solution for static attribute keys
        self.emit(StreamingEvent::Attribute {
            key: self.term(), // Use the actual term for now
            span,
        });
    }

    /// Check if byte can start a LABEL.
    #[inline]
    fn is_label_start(&self, b: u8) -> bool {
        matches!(b, b'a'..=b'z' | b'A'..=b'Z' | b'_') ||
        (b >= 0x80 && self.is_unicode_letter_at(self.pos))
    }

    /// Check if byte can continue a LABEL.
    #[inline]
    fn is_label_continue(&self, b: u8) -> bool {
        matches!(b, b'a'..=b'z' | b'A'..=b'Z' | b'0'..=b'9' | b'_' | b'-') ||
        (b >= 0x80 && self.is_unicode_letter_or_number_at(self.pos))
    }

    /// Check for Unicode letter at position.
    fn is_unicode_letter_at(&self, pos: usize) -> bool {
        if let Some(slice) = self.current_chunk_data().get(pos..) {
            if let Ok(s) = std::str::from_utf8(slice) {
                if let Some(c) = s.chars().next() {
                    return unicode_xid::UnicodeXID::is_xid_start(c);
                }
            }
        }
        false
    }

    /// Check for Unicode letter or number at position.
    fn is_unicode_letter_or_number_at(&self, pos: usize) -> bool {
        if let Some(slice) = self.current_chunk_data().get(pos..) {
            if let Ok(s) = std::str::from_utf8(slice) {
                if let Some(c) = s.chars().next() {
                    return unicode_xid::UnicodeXID::is_xid_continue(c);
                }
            }
        }
        false
    }

    /// Emit a typed value based on accumulated content.
    fn emit_typed_value(&mut self) {
        let slice = self.term();
        let span = self.span_from_mark();

        // Resolve slice to check content
        if let Some(bytes) = self.chunks.resolve(slice) {
            // Check for nil
            if bytes == b"null" || bytes == b"nil" || bytes == b"~" {
                self.emit(StreamingEvent::NilValue { span });
                return;
            }

            // Check for bool
            if bytes == b"true" {
                self.emit(StreamingEvent::BoolValue { value: true, span });
                return;
            }
            if bytes == b"false" {
                self.emit(StreamingEvent::BoolValue { value: false, span });
                return;
            }

            // Try to parse as number
            if let Some(event) = self.try_parse_number(bytes, span) {
                self.emit(event);
                return;
            }
        }

        // Default to string
        self.emit(StreamingEvent::StringValue { value: slice, span });
    }

    /// Try to parse bytes as a number.
    fn try_parse_number(&self, bytes: &[u8], span: Span) -> Option<StreamingEvent> {
        use crate::Value;
        match Value::parse(bytes) {
            Value::Integer(i) => Some(StreamingEvent::IntegerValue { value: i, span }),
            Value::Float(f) => Some(StreamingEvent::FloatValue { value: f, span }),
            Value::Rational { numerator, denominator } => {
                Some(StreamingEvent::RationalValue { numerator, denominator, span })
            }
            Value::Complex { real, imag } => {
                Some(StreamingEvent::ComplexValue { real, imag, span })
            }
            _ => None,
        }
    }

    // ========== State Machine Entry Point ==========

    /// Continue parsing from current state.
    fn parse_continue(&mut self) {
        // For now, just run the document parser
        // TODO: Proper state restoration for streaming
        self.parse_{{ entry_function }}();
    }

    // ========== Generated State Machine ==========

{{ functions }}
}

// ========== Batch Parser (for backwards compatibility) ==========

/// Simple batch parser that parses entire input at once.
///
/// This is a convenience wrapper around StreamingParser for simple use cases.
pub struct Parser<'a> {
    input: &'a [u8],
    pos: usize,
    line: u32,
    column: u32,
    line_start: usize,
    mark_start: usize,
    events: Vec<crate::event::Event<'a>>,
}

impl<'a> Parser<'a> {
    /// Create a new parser for the given input.
    pub fn new(input: &'a [u8]) -> Self {
        let event_capacity = (input.len() / 50).max(16);
        Self {
            input,
            pos: 0,
            line: 1,
            column: 1,
            line_start: 0,
            mark_start: 0,
            events: Vec::with_capacity(event_capacity),
        }
    }

    /// Parse the entire input and return all events.
    pub fn parse(&mut self) -> Vec<crate::event::Event<'a>> {
        self.parse_{{ entry_function }}();
        std::mem::take(&mut self.events)
    }

    // Minimal implementation for batch mode
    #[inline] fn eof(&self) -> bool { self.pos >= self.input.len() }
    #[inline] fn peek(&self) -> Option<u8> { self.input.get(self.pos).copied() }
    #[inline] fn advance(&mut self) {
        if let Some(b) = self.input.get(self.pos) {
            if *b == b'\n' { self.line += 1; self.column = 1; self.pos += 1; self.line_start = self.pos; }
            else { self.column += 1; self.pos += 1; }
        }
    }
    #[inline] fn mark(&mut self) { self.mark_start = self.pos; }
    #[inline] fn term(&self) -> &'a [u8] { &self.input[self.mark_start..self.pos] }
    #[inline] fn current_column(&self) -> i32 { (self.pos - self.line_start) as i32 }
    #[inline] fn span_from_mark(&self) -> Span { Span::new(self.mark_start, self.pos) }
    #[inline] fn emit(&mut self, event: crate::event::Event<'a>) { self.events.push(event); }

    fn is_label_start(&self, b: u8) -> bool {
        matches!(b, b'a'..=b'z' | b'A'..=b'Z' | b'_') ||
        (b >= 0x80 && self.is_unicode_letter_at(self.pos))
    }
    fn is_label_continue(&self, b: u8) -> bool {
        matches!(b, b'a'..=b'z' | b'A'..=b'Z' | b'0'..=b'9' | b'_' | b'-') ||
        (b >= 0x80 && self.is_unicode_letter_or_number_at(self.pos))
    }
    fn is_unicode_letter_at(&self, pos: usize) -> bool {
        if let Some(slice) = self.input.get(pos..) {
            if let Ok(s) = std::str::from_utf8(slice) {
                if let Some(c) = s.chars().next() {
                    return unicode_xid::UnicodeXID::is_xid_start(c);
                }
            }
        }
        false
    }
    fn is_unicode_letter_or_number_at(&self, pos: usize) -> bool {
        if let Some(slice) = self.input.get(pos..) {
            if let Ok(s) = std::str::from_utf8(slice) {
                if let Some(c) = s.chars().next() {
                    return unicode_xid::UnicodeXID::is_xid_continue(c);
                }
            }
        }
        false
    }

    fn emit_typed_value(&mut self) {
        let bytes = self.term();
        let span = self.span_from_mark();
        if bytes == b"null" || bytes == b"nil" || bytes == b"~" {
            self.emit(crate::event::Event::NilValue { span });
            return;
        }
        if bytes == b"true" {
            self.emit(crate::event::Event::BoolValue { value: true, span });
            return;
        }
        if bytes == b"false" {
            self.emit(crate::event::Event::BoolValue { value: false, span });
            return;
        }
        if let Some(event) = self.try_parse_number_event(bytes, span) {
            self.emit(event);
            return;
        }
        self.emit(crate::event::Event::StringValue { value: bytes, span });
    }

    fn try_parse_number_event(&self, bytes: &'a [u8], span: Span) -> Option<crate::event::Event<'a>> {
        use crate::Value;
        match Value::parse(bytes) {
            Value::Integer(i) => Some(crate::event::Event::IntegerValue { value: i, span }),
            Value::Float(f) => Some(crate::event::Event::FloatValue { value: f, span }),
            Value::Rational { numerator, denominator } => {
                Some(crate::event::Event::RationalValue { numerator, denominator, span })
            }
            Value::Complex { real, imag } => {
                Some(crate::event::Event::ComplexValue { real, imag, span })
            }
            _ => None,
        }
    }

    // The batch parser will include the same generated state machine functions
    // but operating on the batch types. For now, we'll keep this as a stub
    // and implement it properly once the streaming version works.
    fn parse_{{ entry_function }}(&mut self) {
        // TODO: Generate batch version of state machine
        // For now, this is a placeholder that will need to be filled in
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_streaming_parser_creation() {
        let parser = StreamingParser::new(64);
        assert!(parser.is_done() == false);
        assert_eq!(parser.available(), 0);
    }

    #[test]
    fn test_streaming_parser_simple_text() {
        let mut parser = StreamingParser::new(64);

        // Feed some simple text
        let result = parser.feed(b"Hello world\n");
        println!("Feed result: {:?}", result);
        println!("Events available: {}", parser.available());

        // Finish parsing
        parser.finish();

        // Check what events we got
        let mut events = Vec::new();
        while let Some(event) = parser.read() {
            println!("Event: {:?}", event);
            events.push(event);
        }

        println!("Total events: {}", events.len());
        assert!(!events.is_empty(), "Should have at least one event");
    }

    #[test]
    fn test_streaming_parser_element() {
        let mut parser = StreamingParser::new(64);

        // Feed an element
        let result = parser.feed(b"|div Hello\n");
        println!("Feed result: {:?}", result);

        parser.finish();

        let mut events = Vec::new();
        while let Some(event) = parser.read() {
            println!("Event: {:?}", event);
            events.push(event);
        }

        println!("Total events: {}", events.len());

        // Should have ElementStart, Text, ElementEnd
        let has_element_start = events.iter().any(|e| matches!(e, StreamingEvent::ElementStart { .. }));
        assert!(has_element_start, "Should have ElementStart event");
    }
}
