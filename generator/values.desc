; UDON Value Type Parser Functions
;
; This file provides typed value parsing for UDON. It is concatenated
; with udon.desc during parser generation.
;
; CONCATENATED WITH:
;   udon.desc - Main UDON grammar (provides type declarations, entry point)
;
; GENERATION:
;   ./regenerate-parser  # concatenates *.desc files and runs descent
;
; PROVIDES:
;   /typed_value(:space_term, :bracket) - Main entry point
;     :space_term = 0 (block: space is content) or 1 (space terminates)
;     :bracket = 0 (none), } (embedded), or ] (array)
;
; EMITS:
;   BoolTrue   - true
;   BoolFalse  - false
;   Nil        - null, nil
;   Integer    - decimal, hex (0x), octal (0o), binary (0b)
;   Float      - with decimal point or exponent
;   Rational   - integer/integer + r (e.g., 1/3r, 22/7r)
;   Complex    - number +/- number + i, or number + i (e.g., 3+4i, 5i)
;   BareValue  - unrecognized (string)

; ============================================================================
; Keyword Lookup (phf perfect hash)
; ============================================================================

; O(1) keyword lookup for boolean/nil literals
|keywords[bare_kw] :fallback /emit_bare_value
  | true   => BoolTrue
  | false  => BoolFalse
  | null   => Nil
  | nil    => Nil

; Fallback: emit accumulated content as BareValue
; MUST be void - uses caller's MARK, not its own
|function[emit_bare_value]
  |state[:main]
    |eof                      | BareValue(USE_MARK)              |return
    |default                  | BareValue(USE_MARK)              |return

; ============================================================================
; Main Entry - Context-Aware Value Parser
; ============================================================================

; typed_value parses a bare (unquoted) value with context-aware termination.
; Void function - emits polymorphic types (Integer, Float, BoolTrue, etc.)
; All emits are explicit inline; no auto-emit on return.
|function[typed_value]  :space_term :bracket  | MARK
  |state[:main]
    |eof                      | BareValue(USE_MARK)              |return
    |c['\n']                  | BareValue(USE_MARK)              |return
    |c[' ']                   |                                  |>> :check_space
    |c[:bracket]              | BareValue(USE_MARK)              |return
    |c['@']                   | ->                               |>> :maybe_ref
    |c['0']                   | ->                               |>> :num_zero
    |c['123456789']           |                                  |>> :num_dec
    |c['+-']                  | ->                               |>> :num_sign
    |LETTER                   | ->                               |>> :accumulate
    |default                  | ->                               |>>

  ; === Reference @[name] ===
  |state[:maybe_ref]
    |c[<L>]                   | -> | MARK                        |>> :reference
    |default                  |                                  |>> :string

  |state[:reference]
    |c[<R>]                   | TERM | Reference(USE_MARK) | ->  |return
    |default                  | ->                               |>>

  |state[:check_space]
    |if[space_term == 0]     | ->                               |>> :block_space
    |default                  | BareValue(USE_MARK)              |return

  |state[:block_space]
    |c[';']                | TERM(-1) | BareValue(USE_MARK)   |return  ; comment (;)
    |default                  |                                  |>> :main

  ; === Accumulate identifier for keyword lookup ===
  ; If we see non-label chars (like .), it's not a keyword - continue as string
  |state[:accumulate]
    |eof                      | TERM | KEYWORDS(bare_kw)         |return
    |c['\n']                  | TERM | KEYWORDS(bare_kw)         |return
    |c[' ']                   |                                  |>> :accum_space
    |c[:bracket]              | TERM | KEYWORDS(bare_kw)         |return
    |LABEL_CONT               | ->                               |>>
    |default                  | ->                               |>> :string
  |state[:accum_space]
    |if[space_term == 0]     | ->                               |>> :accum_block
    |default                  | TERM | KEYWORDS(bare_kw)         |return
  |state[:accum_block]
    |c[';']                | TERM(-1) | KEYWORDS(bare_kw)     |return
    |default                  |                                  |>> :accumulate

  ; === Numbers: after sign ===
  |state[:num_sign]
    |c['0']                   | ->                               |>> :num_zero
    |c['123456789']           |                                  |>> :num_dec
    |default                  |                                  |>> :accumulate

  ; === Numbers: zero prefix (check for 0x, 0o, 0b) ===
  |state[:num_zero]
    |eof                      | Integer(USE_MARK)                |return
    |c['xX']                  | ->                               |>> :num_hex
    |c['oO']                  | ->                               |>> :num_oct
    |c['bB']                  | ->                               |>> :num_bin
    |c['.']                   | ->                               |>> :num_float_frac
    |c['eE']                  | ->                               |>> :num_float_exp
    |c[<0-9 '_'>]              | ->                               |>> :num_dec
    |c['\n']                  | Integer(USE_MARK)                |return
    |c[' ']                   |                                  |>> :num_zero_space
    |c[:bracket]              | Integer(USE_MARK)                |return
    |default                  |                                  |>> :string
  |state[:num_zero_space]
    |if[space_term == 0]     | ->                               |>> :num_zero_block
    |default                  | Integer(USE_MARK)                |return
  |state[:num_zero_block]
    |c[';']                | Integer(USE_MARK)                |return
    |default                  |                                  |>> :string

  ; === Numbers: decimal digits ===
  |state[:num_dec]
    |eof                      | Integer(USE_MARK)                |return
    |c[<0-9 '_'>]             | ->                               |>>
    |c['.']                   | ->                               |>> :num_float_frac
    |c['eE']                  | ->                               |>> :num_float_exp
    |c['/']                   | ->                               |>> :num_rational_denom
    |c['i']                   | -> | Complex(USE_MARK)           |return
    |c['+-']                  | ->                               |>> :num_complex_sign
    |c['\n']                  | Integer(USE_MARK)                |return
    |c[' ']                   |                                  |>> :num_dec_space
    |c[:bracket]              | Integer(USE_MARK)                |return
    |default                  |                                  |>> :string
  |state[:num_dec_space]
    |if[space_term == 0]     | ->                               |>> :num_dec_block
    |default                  | Integer(USE_MARK)                |return
  |state[:num_dec_block]
    |c[';']                | Integer(USE_MARK)                |return
    |default                  |                                  |>> :string

  ; === Numbers: hex (0xFF) ===
  |state[:num_hex]
    |eof                      | Integer(USE_MARK)                |return
    |c[<0-9 a-f A-F '_'>]     | ->                               |>>
    |c['\n']                  | Integer(USE_MARK)                |return
    |c[' ']                   |                                  |>> :num_hex_space
    |c[:bracket]              | Integer(USE_MARK)                |return
    |default                  |                                  |>> :string
  |state[:num_hex_space]
    |if[space_term == 0]     | ->                               |>> :num_hex_block
    |default                  | Integer(USE_MARK)                |return
  |state[:num_hex_block]
    |c[';']                | Integer(USE_MARK)                |return
    |default                  |                                  |>> :string

  ; === Numbers: octal (0o755) ===
  |state[:num_oct]
    |eof                      | Integer(USE_MARK)                |return
    |c[<0-7 '_'>]              | ->                               |>>
    |c['\n']                  | Integer(USE_MARK)                |return
    |c[' ']                   |                                  |>> :num_oct_space
    |c[:bracket]              | Integer(USE_MARK)                |return
    |default                  |                                  |>> :string
  |state[:num_oct_space]
    |if[space_term == 0]     | ->                               |>> :num_oct_block
    |default                  | Integer(USE_MARK)                |return
  |state[:num_oct_block]
    |c[';']                | Integer(USE_MARK)                |return
    |default                  |                                  |>> :string

  ; === Numbers: binary (0b1010) ===
  |state[:num_bin]
    |eof                      | Integer(USE_MARK)                |return
    |c[<0-1 '_'>]              | ->                               |>>
    |c['\n']                  | Integer(USE_MARK)                |return
    |c[' ']                   |                                  |>> :num_bin_space
    |c[:bracket]              | Integer(USE_MARK)                |return
    |default                  |                                  |>> :string
  |state[:num_bin_space]
    |if[space_term == 0]     | ->                               |>> :num_bin_block
    |default                  | Integer(USE_MARK)                |return
  |state[:num_bin_block]
    |c[';']                | Integer(USE_MARK)                |return
    |default                  |                                  |>> :string

  ; === Numbers: float fractional part ===
  |state[:num_float_frac]
    |eof                      | Float(USE_MARK)                  |return
    |c[<0-9 '_'>]             | ->                               |>>
    |c['eE']                  | ->                               |>> :num_float_exp
    |c['i']                   | -> | Complex(USE_MARK)           |return
    |c['+-']                  | ->                               |>> :num_complex_sign
    |c['\n']                  | Float(USE_MARK)                  |return
    |c[' ']                   |                                  |>> :num_float_frac_space
    |c[:bracket]              | Float(USE_MARK)                  |return
    |default                  |                                  |>> :string
  |state[:num_float_frac_space]
    |if[space_term == 0]     | ->                               |>> :num_float_frac_block
    |default                  | Float(USE_MARK)                  |return
  |state[:num_float_frac_block]
    |c[';']                | Float(USE_MARK)                  |return
    |default                  |                                  |>> :string

  ; === Numbers: float exponent ===
  |state[:num_float_exp]
    |eof                      | Float(USE_MARK)                  |return
    |c['+-']                  | ->                               |>> :num_float_exp_digits
    |c[<0-9>]                  |                                  |>> :num_float_exp_digits
    |c['\n']                  | Float(USE_MARK)                  |return
    |c[' ']                   |                                  |>> :num_float_exp_space
    |c[:bracket]              | Float(USE_MARK)                  |return
    |default                  |                                  |>> :string
  |state[:num_float_exp_space]
    |if[space_term == 0]     | ->                               |>> :num_float_exp_block
    |default                  | Float(USE_MARK)                  |return
  |state[:num_float_exp_block]
    |c[';']                | Float(USE_MARK)                  |return
    |default                  |                                  |>> :string

  |state[:num_float_exp_digits]
    |eof                      | Float(USE_MARK)                  |return
    |c[<0-9 '_'>]             | ->                               |>>
    |c['i']                   | -> | Complex(USE_MARK)           |return
    |c['+-']                  | ->                               |>> :num_complex_sign
    |c['\n']                  | Float(USE_MARK)                  |return
    |c[' ']                   |                                  |>> :num_float_exp_d_space
    |c[:bracket]              | Float(USE_MARK)                  |return
    |default                  |                                  |>> :string
  |state[:num_float_exp_d_space]
    |if[space_term == 0]     | ->                               |>> :num_float_exp_d_block
    |default                  | Float(USE_MARK)                  |return
  |state[:num_float_exp_d_block]
    |c[';']                | Float(USE_MARK)                  |return
    |default                  |                                  |>> :string

  ; === Rational: integer/integer + r (e.g., 1/3r, 22/7r) ===
  ; After seeing '/' following an integer, accumulate denominator digits
  ; MUST end with 'r' to be valid rational, otherwise falls back to string
  |state[:num_rational_denom]
    |eof                      | BareValue(USE_MARK)              |return  ; no 'r', not rational
    |c[<0-9 '_'>]             | ->                               |>>
    |c['r']                   | -> | Rational(USE_MARK)          |return
    |c['\n']                  | BareValue(USE_MARK)              |return  ; no 'r', not rational
    |c[' ']                   |                                  |>> :num_rational_space
    |c[:bracket]              | BareValue(USE_MARK)              |return  ; no 'r', not rational
    |default                  |                                  |>> :string
  |state[:num_rational_space]
    |if[space_term == 0]     | ->                               |>> :num_rational_block
    |default                  | BareValue(USE_MARK)              |return
  |state[:num_rational_block]
    |c[';']                   | BareValue(USE_MARK)              |return
    |default                  |                                  |>> :string

  ; === Complex: number +/- number + i (e.g., 3+4i, 3.5-2i) ===
  ; After seeing '+' or '-' following a number, accumulate imaginary part
  ; MUST end with 'i' to be valid complex, otherwise falls back to string
  |state[:num_complex_sign]
    |c[<0-9>]                 |                                  |>> :num_complex_imag
    |default                  |                                  |>> :string
  |state[:num_complex_imag]
    |eof                      | BareValue(USE_MARK)              |return  ; no 'i', not complex
    |c[<0-9 '_'>]             | ->                               |>>
    |c['.']                   | ->                               |>> :num_complex_imag_frac
    |c['eE']                  | ->                               |>> :num_complex_imag_exp
    |c['i']                   | -> | Complex(USE_MARK)           |return
    |c['\n']                  | BareValue(USE_MARK)              |return  ; no 'i', not complex
    |c[' ']                   |                                  |>> :num_complex_imag_space
    |c[:bracket]              | BareValue(USE_MARK)              |return  ; no 'i', not complex
    |default                  |                                  |>> :string
  |state[:num_complex_imag_space]
    |if[space_term == 0]     | ->                               |>> :num_complex_imag_block
    |default                  | BareValue(USE_MARK)              |return
  |state[:num_complex_imag_block]
    |c[';']                   | BareValue(USE_MARK)              |return
    |default                  |                                  |>> :string

  ; === Complex imaginary part: fractional (3+4.5i) ===
  |state[:num_complex_imag_frac]
    |eof                      | BareValue(USE_MARK)              |return
    |c[<0-9 '_'>]             | ->                               |>>
    |c['eE']                  | ->                               |>> :num_complex_imag_exp
    |c['i']                   | -> | Complex(USE_MARK)           |return
    |c['\n']                  | BareValue(USE_MARK)              |return
    |c[' ']                   |                                  |>> :num_complex_imag_frac_space
    |c[:bracket]              | BareValue(USE_MARK)              |return
    |default                  |                                  |>> :string
  |state[:num_complex_imag_frac_space]
    |if[space_term == 0]     | ->                               |>> :num_complex_imag_frac_block
    |default                  | BareValue(USE_MARK)              |return
  |state[:num_complex_imag_frac_block]
    |c[';']                   | BareValue(USE_MARK)              |return
    |default                  |                                  |>> :string

  ; === Complex imaginary part: exponent (3+4e2i) ===
  |state[:num_complex_imag_exp]
    |eof                      | BareValue(USE_MARK)              |return
    |c['+-']                  | ->                               |>> :num_complex_imag_exp_d
    |c[<0-9>]                 |                                  |>> :num_complex_imag_exp_d
    |c['\n']                  | BareValue(USE_MARK)              |return
    |c[' ']                   |                                  |>> :num_complex_imag_exp_space
    |c[:bracket]              | BareValue(USE_MARK)              |return
    |default                  |                                  |>> :string
  |state[:num_complex_imag_exp_space]
    |if[space_term == 0]     | ->                               |>> :num_complex_imag_exp_block
    |default                  | BareValue(USE_MARK)              |return
  |state[:num_complex_imag_exp_block]
    |c[';']                   | BareValue(USE_MARK)              |return
    |default                  |                                  |>> :string
  |state[:num_complex_imag_exp_d]
    |eof                      | BareValue(USE_MARK)              |return
    |c[<0-9 '_'>]             | ->                               |>>
    |c['i']                   | -> | Complex(USE_MARK)           |return
    |c['\n']                  | BareValue(USE_MARK)              |return
    |c[' ']                   |                                  |>> :num_complex_imag_exp_d_space
    |c[:bracket]              | BareValue(USE_MARK)              |return
    |default                  |                                  |>> :string
  |state[:num_complex_imag_exp_d_space]
    |if[space_term == 0]     | ->                               |>> :num_complex_imag_exp_d_block
    |default                  | BareValue(USE_MARK)              |return
  |state[:num_complex_imag_exp_d_block]
    |c[';']                   | BareValue(USE_MARK)              |return
    |default                  |                                  |>> :string

  ; === String fallback (anything not keyword/number) ===
  |state[:string]
    |eof                      | BareValue(USE_MARK)              |return
    |c['\n']                  | BareValue(USE_MARK)              |return
    |c[' ']                   |                                  |>> :string_space
    |c[:bracket]              | BareValue(USE_MARK)              |return
    |default                  | ->                               |>>
  |state[:string_space]
    |if[space_term == 0]     | ->                               |>> :string_block
    |default                  | BareValue(USE_MARK)              |return
  |state[:string_block]
    |c[';']                | TERM(-1) | BareValue(USE_MARK)   |return
    |default                  |                                  |>> :string
