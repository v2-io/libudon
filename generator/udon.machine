|parser udon

; UDON Parser - Full Grammar via DSL
;
; Uses recursive function calls for element nesting:
;   /element(ACTUAL_COL) - call pushes element, return pops + emits ElementEnd
;
; CALLs only for:
;   - parse_element_identity: complex unicode label parsing
;   - parse_indented_attribute: typed value parsing

|entry-point /document

;==============================================================================
; ROOT DOCUMENT - Fully Generated
;==============================================================================
|function[document]
  |state[:start]
    |eof                                                |return
    |c[\n]      |.newline     | ->               |>> :start
    |c[ ]       |.space       | ->              |>> :start
    |c[\t]      |.tab         | -> | emit(Error:no_tabs) |>> :skip_line
    |c[']       |.escape      | ->                      |>> :escaped
    |c[;]       |.comment     | -> | MARK               |>> :block_comment
    |c[<P>]     |.pipe        | ->                         |>> /element(ACTUAL_COL) :start
    |c[`]       |.backtick    | ->                      |>> :maybe_freeform
    |c[!]       |.directive   | ->                      |>> :directive
    |default    |.text        | MARK                    |>> :prose

  |state[:escaped]
    ; Line started with ' - rest is literal, no special chars
    |eof                       | emit(Text)             |return
    |c[\n]      |.done        | emit(Text)      |>> :start
    |default    |.first       | MARK                    |>> :escaped_text

  |state[:escaped_text] SCAN(\n)
    ; Collect escaped text - no special char handling (| ; ! are literal)
    ; SCAN-first: bulk scan to newline before checking
    |eof                       | emit(Text)             |return
    |c[\n]      |.done        | emit(Text)      |>> :start

  |state[:prose] SCAN(\n;<P>)
    ; SCAN-first: bulk scan to newline, semicolon, or pipe before checking
    |eof                       | emit(Text)             |return
    |c[\n]      |.done        | emit(Text)      |>> :start
    |c[;]       |.semi        | emit(Text) | ->         |>> :check_inline_comment
    |c[<P>]     |.pipe        | emit(Text) | ->         |>> /element(ACTUAL_COL) :start

  |state[:check_inline_comment]
    ; After ; in prose - is it ;{...} or rest-of-line comment?
    |eof                       |                        |return
    |c[{]       |.inline      | ->                      |>> :inline_comment
    |default    |.block       | MARK                    |>> :line_comment

  |state[:inline_comment]
    ; ;{...} - balanced braces stripped from output
    |eof                       | emit(Error:unclosed_comment) |return
    |c[}]       |.close       | ->                      |>> :prose
    |c[{]       |.nest        | ->                      |>> :inline_comment_nested
    |default    |.collect     | ->                      |>>

  |state[:inline_comment_nested]
    ; Nested braces in inline comment - simple nesting (one level)
    |eof                       | emit(Error:unclosed_comment) |return
    |c[}]       |.close       | ->                      |>> :inline_comment
    |default    |.collect     | ->                      |>>

  |state[:line_comment] SCAN(\n)
    ; Rest of line after ; (not ;{)
    ; SCAN-first: bulk scan to newline before checking
    |eof                       | emit(Comment)          |return
    |c[\n]      |.done        | emit(Comment)   |>> :start

  |state[:block_comment] SCAN(\n)
    ; Full line comment starting with ;
    ; SCAN-first: bulk scan to newline before checking
    |eof                       | emit(Comment)          |return
    |c[\n]      |.done        | emit(Comment)   |>> :start

  |state[:maybe_freeform]
    ; Saw one ` - check for ```
    |eof                       | emit(Text)             |return
    |c[`]       |.second      | ->                      |>> :maybe_freeform2
    |default    |.not         | MARK                    |>> :prose

  |state[:maybe_freeform2]
    ; Saw `` - check for third
    |eof                       | emit(Text)             |return
    |c[`]       |.third       | MARK                    |>> :freeform
    |default    |.not         | MARK                    |>> :prose

  |state[:freeform]
    ; Inside ``` block - preserve exact whitespace
    |eof                       | emit(Error:unclosed_freeform) |return
    |c[`]       |.maybe_end   | ->                      |>> :freeform_end1
    |default    |.collect     | ->                      |>>

  |state[:freeform_end1]
    |eof                       | emit(Error:unclosed_freeform) |return
    |c[`]       |.second      | ->                      |>> :freeform_end2
    |default    |.not         | ->                      |>> :freeform

  |state[:freeform_end2]
    |eof                       | emit(Error:unclosed_freeform) |return
    |c[`]       |.close       | emit(RawContent)  |>> :start
    |default    |.not         | ->                      |>> :freeform

  |state[:directive]
    ; After ! - could be !{expr} or !name
    |eof                       | emit(Error:incomplete_directive) |return
    |c[{]       |.interp      | MARK                    |>> :directive_interp
    |default    |.name        | MARK                    |>> :directive_name

  |state[:directive_interp]
    ; !{...} interpolation
    |eof                       | emit(Error:unclosed_directive) |return
    |c[}]       |.close       | emit(Interpolation)    |>> :prose_after_directive
    |default    |.collect     | ->                      |>>

  |state[:directive_name]
    ; !name...
    |eof                       | emit(Directive)        |return
    |c[\n]      |.block       | emit(Directive)  |>> :start
    |c[{]       |.inline      | emit(Directive)        |>> :directive_body
    |c[ \t]     |.space       | emit(Directive)        |>> :prose_after_directive
    |default    |.collect     | ->                      |>>

  |state[:directive_body]
    ; !name{...} inline directive body
    |eof                       | emit(Error:unclosed_directive) |return
    |c[}]       |.close       | emit(DirectiveBody)    |>> :prose_after_directive
    |default    |.collect     | ->                      |>>

  |state[:prose_after_directive]
    ; Continue prose after inline directive
    |eof                       | emit(Text)             |return
    |c[\n]      |.done        | emit(Text)      |>> :start
    |c[;]       |.semi        | emit(Text) | ->         |>> :check_inline_comment
    |c[<P>]     |.pipe        | emit(Text) | ->         |>> /element(ACTUAL_COL) :start
    |default    |.collect     | MARK                    |>> :prose

  |state[:skip_line]
    ; Error recovery - skip to next line
    |eof                                                |return
    |c[\n]      |.done                           |>> :start
    |default    |.skip        | ->                      |>>

;==============================================================================
; ELEMENT FUNCTION
; SPEC.md:43-105, 645-662
;
; Called when we see | at some column. The element function handles:
;   1. Identity parsing (name, [id], .class, suffix)
;   2. Inline content (text, nested elements)
;   3. Indented children (via dedent detection)
;
; Entering = implicit stack push
; Returning = implicit stack pop + ElementEnd event
;==============================================================================
|function[element] :elem_col
  ;============================================================================
  ; ELEMENT IDENTITY PARSING
  ; SPEC.md:654 - element = "|" [ name ] [ suffix ] [ id [ suffix ] ] { class }*
  ;                         [ SPACE suffix ] { attribute }* { inline_child }*
  ;
  ; Key insight: Each piece of identity syntax desugars to attributes:
  ;   [id]     → :'$id' value      (SPEC.md:60-68)
  ;   .class   → :'$class' name    (SPEC.md:572-576)
  ;   ?!*+     → :'<char>' true    (SPEC.md:74-88)
  ;
  ; Events are emitted immediately as each piece is parsed - no accumulation.
  ;============================================================================

  |state[:identity]
    ; SPEC.md:645-651 - Element recognition rules
    ; "|" is element when followed by: letter, [, ., {, ', or suffix
    ; Otherwise "|" is prose (Markdown table compatibility)
    ;
    ; Examples:
    ;   |foo     → ElementStart("foo")
    ;   |[id]    → ElementStartAnon, Attribute("$id"), StringValue("id")
    ;   |.class  → ElementStartAnon, Attribute("$class"), StringValue("class")
    ;   |?       → ElementStartAnon, Attribute("?"), BoolValue(true)
    ;   |'name'  → ElementStart("name")
    |eof                     | emit(ElementStartAnon) | emit(ElementEnd) |return
    |c[LETTER]    |.name     | MARK                              |>> :id_name
    |c[<L>]       |.bracket  | ->                                |>> :id_anon_bracket
    |c[.]         |.dot      | emit(ElementStartAnon) | ->       |>> :id_class_start
    |c[?]         |.q        | emit(ElementStartAnon) | emit(Attribute:?) | emit(BoolValue:true) | -> |>> :id_check_more
    |c[!]         |.bang     | emit(ElementStartAnon) | emit(Attribute:!) | emit(BoolValue:true) | -> |>> :id_check_more
    |c[*]         |.star     | emit(ElementStartAnon) | emit(Attribute:*) | emit(BoolValue:true) | -> |>> :id_check_more
    |c[+]         |.plus     | emit(ElementStartAnon) | emit(Attribute:+) | emit(BoolValue:true) | -> |>> :id_check_more
    |c[']         |.quote    | ->                                |>> :id_quoted_name
    |default      |.anon     | emit(ElementStartAnon)            |>> :after_identity

  |state[:id_name]
    ; SPEC.md:656 - name = LABEL | quoted_label
    ; LABEL = /[\p{L}_][\p{L}\p{N}_-]*/
    ;
    ; Example: |foo-bar → scans "foo-bar", emits ElementStart("foo-bar")
    |eof           |.done    | emit(ElementStart)                |>> :after_identity
    |c[LABEL_CONT] |.cont    | ->                                |>>
    |default       |.done    | emit(ElementStart)                |>> :id_after_name

  |state[:id_after_name]
    ; After element name - check for suffix, [id], or .class
    ; SPEC.md:89-98 - Suffix allowed positions
    ;
    ; Examples:
    ;   |foo?      → ..., Attribute("?"), BoolValue(true)
    ;   |foo[id]   → ..., Attribute("$id"), StringValue("id")
    ;   |foo.bar   → ..., Attribute("$class"), StringValue("bar")
    |eof                                                        |>> :after_identity
    |c[?]         |.q        | emit(Attribute:?) | emit(BoolValue:true) | -> |>> :id_check_bracket
    |c[!]         |.bang     | emit(Attribute:!) | emit(BoolValue:true) | -> |>> :id_check_bracket
    |c[*]         |.star     | emit(Attribute:*) | emit(BoolValue:true) | -> |>> :id_check_bracket
    |c[+]         |.plus     | emit(Attribute:+) | emit(BoolValue:true) | -> |>> :id_check_bracket
    |c[<L>]       |.bracket  | ->                                |>> :id_bracket_start
    |c[.]         |.dot      | ->                                |>> :id_class_start
    |default      |.done     |                                   |>> :after_identity

  |state[:id_check_bracket]
    ; After name+suffix - can still have [id] or .class
    ; Example: |foo?[id] → suffix already emitted, now parse [id]
    |eof                                                        |>> :after_identity
    |c[<L>]       |.bracket  | ->                                |>> :id_bracket_start
    |c[.]         |.dot      | ->                                |>> :id_class_start
    |default      |.done     |                                   |>> :after_identity

  |state[:id_bracket_start]
    ; SPEC.md:60-68 - [id] syntax desugars to :'$id' value
    ; Called after ElementStart already emitted
    ;
    ; Example: |foo[myid] → Attribute("$id"), StringValue("myid")
    |eof                     | emit(Error:unclosed_bracket)      |>> :after_identity
    |c[<R>]       |.empty    | ->                                |>> :id_after_bracket
    |default      |.value    | emit(Attribute:$id) | MARK        |>> :id_bracket_value

  |state[:id_anon_bracket]
    ; Anonymous element starting with [
    ; Must emit ElementStartAnon before the $id attribute
    ;
    ; Example: |[myid] → ElementStartAnon, Attribute("$id"), StringValue("myid")
    |eof                     | emit(ElementStartAnon) | emit(Error:unclosed_bracket) |>> :after_identity
    |c[<R>]       |.empty    | emit(ElementStartAnon)            |>> :id_after_bracket
    |default      |.value    | emit(ElementStartAnon) | emit(Attribute:$id) | MARK |>> :id_bracket_value

  |state[:id_bracket_value] SCAN(<R>)
    ; SPEC.md:657-658 - id_value = typed_value | bare_string
    ; SCAN-first: bulk scan to closing bracket
    ;
    ; Example: |foo[123] → StringValue("123") (consumer may parse as int)
    |eof                     | emit(Error:unclosed_bracket)      |>> :after_identity
    |c[<R>]       |.close    | emit(StringValue) | ->            |>> :id_after_bracket

  |state[:id_after_bracket]
    ; After [id] - check for suffix or .class
    ; SPEC.md:95 - |name[id]? is valid (suffix after id)
    |eof                                                        |>> :after_identity
    |c[?]         |.q        | emit(Attribute:?) | emit(BoolValue:true) | -> |>> :id_check_class
    |c[!]         |.bang     | emit(Attribute:!) | emit(BoolValue:true) | -> |>> :id_check_class
    |c[*]         |.star     | emit(Attribute:*) | emit(BoolValue:true) | -> |>> :id_check_class
    |c[+]         |.plus     | emit(Attribute:+) | emit(BoolValue:true) | -> |>> :id_check_class
    |c[.]         |.dot      | ->                                |>> :id_class_start
    |default      |.done     |                                   |>> :after_identity

  |state[:id_check_class]
    ; After [id]+suffix - can still have .class
    |eof                                                        |>> :after_identity
    |c[.]         |.dot      | ->                                |>> :id_class_start
    |default      |.done     |                                   |>> :after_identity

  |state[:id_class_start]
    ; SPEC.md:572-576 - Classes desugar to :'$class' [names...]
    ; Each .class emits: Attribute("$class"), StringValue("classname")
    ;
    ; Example: |foo.bar → Attribute("$class"), StringValue("bar")
    ; Example: |foo.'odd name' → Attribute("$class"), QuotedStringValue("odd name")
    |eof                     | emit(Error:expected_class_name)   |>> :after_identity
    |c[LETTER]    |.name     | emit(Attribute:$class) | MARK     |>> :id_class_name
    |c[']         |.quote    | emit(Attribute:$class) | ->       |>> :id_class_quoted
    |default      |.err      | emit(Error:expected_class_name)   |>> :after_identity

  |state[:id_class_name]
    ; SPEC.md:659 - class = "." LABEL
    ; Scanning class name until non-LABEL char
    |eof           |.done    | emit(StringValue)                 |>> :after_identity
    |c[LABEL_CONT] |.cont    | ->                                |>>
    |default       |.done    | emit(StringValue)                 |>> :id_class_check_more

  |state[:id_class_check_more]
    ; After class name - check for more .class or space+suffix
    ; SPEC.md:100-105 - suffix directly on class is RESERVED (not allowed)
    ;
    ; Example: |foo.bar.baz → multiple classes, each emits separately
    ; Example: |foo.bar ? → space-separated suffix (allowed)
    |eof                                                        |>> :after_identity
    |c[.]         |.more     | ->                                |>> :id_class_start
    |c[ ]         |.space    | ->                                |>> :id_space_suffix
    |default      |.done     |                                   |>> :after_identity

  |state[:id_space_suffix]
    ; SPEC.md:97 - |name[id].class ? (space-separated suffix at end)
    ; Only suffix chars valid here, otherwise back to content parsing
    |eof                                                        |>> :after_identity
    |c[?]         |.q        | emit(Attribute:?) | emit(BoolValue:true) | -> |>> :after_identity
    |c[!]         |.bang     | emit(Attribute:!) | emit(BoolValue:true) | -> |>> :after_identity
    |c[*]         |.star     | emit(Attribute:*) | emit(BoolValue:true) | -> |>> :after_identity
    |c[+]         |.plus     | emit(Attribute:+) | emit(BoolValue:true) | -> |>> :after_identity
    |c[ ]         |.more     | ->                                |>>
    |default      |.nosuffix |                                   |>> :after_identity

  |state[:id_quoted_name]
    ; Quoted element name: |'has spaces'
    ; After opening ' consumed - now at content
    |eof                     | emit(ElementStart) | emit(Error:unclosed_quote) |>> :after_identity
    |c[']         |.empty    | MARK | emit(ElementStart) | ->     |>> :id_after_name
    |default      |.content  | MARK                               |>> :id_quoted_name_content

  |state[:id_quoted_name_content] SCAN('<BS>)
    ; Inside quoted name - collect until closing quote
    ; SCAN-first: bulk scan to quote or escape
    ; On error, still emit ElementStart (with partial name) to maintain balance
    |eof                     | emit(ElementStart) | emit(Error:unclosed_quote) |>> :after_identity
    |c[']         |.close    | emit(ElementStart) | ->           |>> :id_after_name
    |c[<BS>]      |.escape   | ->                                |>> :id_quoted_name_escape

  |state[:id_quoted_name_escape]
    ; After backslash - next char is literal
    ; On error, still emit ElementStart to maintain balance
    |eof                     | emit(ElementStart) | emit(Error:unclosed_quote) |>> :after_identity
    |default      |.char     | ->                                |>> :id_quoted_name_content

  |state[:id_class_quoted]
    ; Quoted class name: |foo.'has spaces'
    ; After opening ' consumed - now at content
    |eof                     | emit(Error:unclosed_quote)        |>> :after_identity
    |c[']         |.empty    | MARK | emit(QuotedStringValue) | -> |>> :id_class_check_more
    |default      |.content  | MARK                               |>> :id_class_quoted_content

  |state[:id_class_quoted_content] SCAN('<BS>)
    ; Inside quoted class name
    ; SCAN-first: bulk scan to quote or escape
    |eof                     | emit(Error:unclosed_quote)        |>> :after_identity
    |c[']         |.close    | emit(QuotedStringValue) | ->      |>> :id_class_check_more
    |c[<BS>]      |.escape   | ->                                |>> :id_class_quoted_escape

  |state[:id_class_quoted_escape]
    ; After backslash in quoted class
    |eof                     | emit(Error:unclosed_quote)        |>> :after_identity
    |default      |.char     | ->                                |>> :id_class_quoted_content

  |state[:id_check_more]
    ; After suffix on anonymous element - can still have [id] or .class
    ; Example: |?[id] → suffix emitted, now parse id
    |eof                                                        |>> :after_identity
    |c[<L>]       |.bracket  | ->                                |>> :id_bracket_start
    |c[.]         |.dot      | ->                                |>> :id_class_start
    |default      |.done     |                                   |>> :after_identity

  ;============================================================================
  ; AFTER IDENTITY - Inline content and transition to children
  ;============================================================================

  |state[:after_identity]
    |eof                                   | emit(ElementEnd)  |return
    |c[\n]      |.newline  | ->                         |>> :children
    |c[ \t]     |.space    | ->                        |>> :inline_content
    |c[;]       |.comment  | ->                                |>> :elem_comment_check
    |c[:]       |.attr     | ->                                |>> :inline_attr_key
    |c[<P>]     |.nested   | ->                                |>> /element(ACTUAL_COL) :inline_content
    |default    |.text     | MARK                              |>> :inline_text

  |state[:inline_content]
    ; Inline content after element identity
    |eof                   | emit(ElementEnd)                  |return
    |c[\n]      |.newline  | ->                         |>> :children
    |c[ \t]     |.space    | ->                                |>>
    |c[;]       |.comment  | ->                                |>> :elem_comment_check
    |c[:]       |.attr     | ->                                |>> :inline_attr_key
    |c[<P>]     |.nested   | ->                                |>> /element(ACTUAL_COL) :inline_content
    |default    |.text     | MARK                              |>> :inline_text

  |state[:inline_text] SCAN(\n;<P>)
    ; SCAN-first: bulk scan to newline, semicolon, or pipe
    |eof                   | emit(Text) | emit(ElementEnd)     |return
    |c[\n]      |.done     | emit(Text) | ->            |>> :children
    |c[;]       |.semi     | emit(Text) | ->                   |>> :elem_comment_check
    |c[<P>]     |.pipe     | emit(Text) | ->                   |>> /element(ACTUAL_COL) :inline_content

  |state[:elem_comment_check]
    |eof                   | emit(ElementEnd)                  |return
    |c[{]       |.inline   | ->                                |>> :elem_inline_comment
    |default    |.line     | MARK                              |>> :elem_line_comment

  |state[:elem_inline_comment]
    |eof                   | emit(ElementEnd)                  |return
    |c[}]       |.close    | ->                                |>> :inline_content
    |default    |.collect  | ->                                |>>

  |state[:elem_line_comment] SCAN(\n)
    ; SCAN-first: bulk scan to newline
    |eof                   | emit(Comment) | emit(ElementEnd)  |return
    |c[\n]      |.done     | emit(Comment) | ->         |>> :children

  ;============================================================================
  ; INLINE ATTRIBUTE PARSING - Inline attributes on same line as element
  ; Same as indented attributes but returns to :inline_content instead of :children
  ;============================================================================

  |state[:inline_attr_key]
    ; Parse inline attribute key (LABEL or quoted)
    ; Example: |div :foo-bar value → Attribute("foo-bar"), then value
    |eof                     | emit(Error:expected_attr_key) | emit(ElementEnd) |return
    |c[LETTER]    |.name    | MARK                              |>> :inline_attr_key_scan
    |c[']         |.quoted  | ->                                |>> :inline_attr_key_quoted
    |default      |.err     | emit(Error:expected_attr_key)     |>> :inline_content

  |state[:inline_attr_key_scan]
    ; Scanning inline attribute key label
    |eof           |.done   | emit(Attribute)                   |>> :inline_attr_ws
    |c[LABEL_CONT] |.cont   | ->                                |>>
    |default       |.done   | emit(Attribute)                   |>> :inline_attr_ws

  |state[:inline_attr_key_quoted]
    ; Quoted inline attribute key: :'odd key'
    |eof                     | emit(Error:unclosed_quote) | emit(ElementEnd) |return
    |c[']         |.empty   | MARK | emit(Attribute) | ->       |>> :inline_attr_ws
    |default      |.content | MARK                              |>> :inline_attr_key_quoted_content

  |state[:inline_attr_key_quoted_content]
    |eof                     | emit(Error:unclosed_quote) | emit(ElementEnd) |return
    |c[']         |.close   | emit(Attribute)                   |>> :inline_attr_ws
    |c[\\]        |.escape  | ->                                |>> :inline_attr_key_quoted_esc
    |default      |.collect | ->                                |>>

  |state[:inline_attr_key_quoted_esc]
    |eof                     | emit(Error:unclosed_quote) | emit(ElementEnd) |return
    |default      |.char    | ->                                |>> :inline_attr_key_quoted_content

  |state[:inline_attr_ws]
    ; Skip whitespace before value
    |eof                                                        |>> :inline_attr_value
    |c[ \t]       |.space   | ->                                |>>
    |default      |.done    |                                   |>> :inline_attr_value

  |state[:inline_attr_value]
    ; Dispatch on value type for inline attributes
    ; Flag attribute (no value) → emit BoolValue(true)
    |eof                      | emit(BoolValue:true)            |>> :inline_content
    |c[\n]        |.flag     | emit(BoolValue:true)      |>> :children
    |c[;]         |.flag     | emit(BoolValue:true)             |>> :elem_comment_check
    |c[:]         |.flag     | emit(BoolValue:true)             |>> :inline_attr_key
    |c[<L>]       |.array    | emit(ArrayStart) | ->            |>> /array :inline_attr_after_value
    |c["]         |.dquote   | ->                               |>> :inline_attr_dquote
    |c[']         |.squote   | ->                               |>> :inline_attr_squote
    |default      |.bare     | MARK                             |>> :inline_attr_bare

  |state[:inline_attr_dquote]
    ; Double-quoted string value in inline attribute
    |eof                      | emit(Error:unclosed_string) | emit(ElementEnd) |return
    |c["]         |.empty    | MARK | emit(QuotedStringValue) | -> |>> :inline_attr_after_value
    |default      |.content  | MARK                             |>> :inline_attr_dquote_content

  |state[:inline_attr_dquote_content] SCAN("<BS>)
    ; SCAN-first: bulk scan to quote or escape
    |eof                      | emit(Error:unclosed_string)     |>> :inline_content
    |c["]         |.close    | emit(QuotedStringValue) | ->     |>> :inline_attr_after_value
    |c[<BS>]      |.escape   | ->                               |>> :inline_attr_dquote_esc

  |state[:inline_attr_dquote_esc]
    |eof                      | emit(Error:unclosed_string)     |>> :inline_content
    |default      |.char     | ->                               |>> :inline_attr_dquote_content

  |state[:inline_attr_squote]
    ; Single-quoted string value in inline attribute
    |eof                      | emit(Error:unclosed_string) | emit(ElementEnd) |return
    |c[']         |.empty    | MARK | emit(QuotedStringValue) | -> |>> :inline_attr_after_value
    |default      |.content  | MARK                             |>> :inline_attr_squote_content

  |state[:inline_attr_squote_content] SCAN('<BS>)
    ; SCAN-first: bulk scan to quote or escape
    |eof                      | emit(Error:unclosed_string)     |>> :inline_content
    |c[']         |.close    | emit(QuotedStringValue) | ->     |>> :inline_attr_after_value
    |c[<BS>]      |.escape   | ->                               |>> :inline_attr_squote_esc

  |state[:inline_attr_squote_esc]
    |eof                      | emit(Error:unclosed_string)     |>> :inline_content
    |default      |.char     | ->                               |>> :inline_attr_squote_content

  |state[:inline_attr_bare]
    ; Bare (unquoted) value for inline attribute
    ; Collect until space, newline, semicolon, colon, or pipe
    |eof                      | emit(TypedValue)                |>> :inline_content
    |c[\n]        |.done     | emit(TypedValue)          |>> :children
    |c[ \t]       |.done     | emit(TypedValue)                 |>> :inline_attr_after_value
    |c[;]         |.done     | emit(TypedValue)                 |>> :elem_comment_check
    |c[:]         |.done     | emit(TypedValue)                 |>> :inline_attr_key
    |c[<P>]       |.done     | emit(TypedValue)                 |>> /element(ACTUAL_COL) :inline_content
    |default      |.collect  | ->                               |>>

  |state[:inline_attr_after_value]
    ; After quoted/array value - continue inline content
    |eof                      |                                 |>> :inline_content
    |c[\n]        |.done                                 |>> :children
    |c[;]         |.comment  |                                  |>> :elem_comment_check
    |c[:]         |.attr     |                                  |>> :inline_attr_key
    |c[ \t]       |.space    | ->                               |>>
    |c[<P>]       |.pipe     |                                  |>> /element(ACTUAL_COL) :inline_content
    |default      |.text     | MARK                             |>> :inline_text

  ;----------------------------------------------------------------------------
  ; CHILDREN - indented content after element
  ; Split into whitespace counting and content handling for correct dedent check
  ;----------------------------------------------------------------------------
  |state[:children]
    |eof                                   | emit(ElementEnd)  |return
    |c[\n]      |.blank    | ->                         |>> :children
    |c[ ]       |.space    | ->                        |>> :children
    |c[\t]      |.tab      | -> | emit(Error:no_tabs)          |>> :skip_child
    |default               |                                   |>> :children_content

  |state[:children_content]
    ; DEDENT CHECK: use actual column from line_start
    |eof                                   | emit(ElementEnd)  |return
    |if[ACTUAL_COL <= elem_col]            | emit(ElementEnd)  |return
    ; Still inside this element - handle actual content
    |c[']       |.escape   | ->                                |>> :child_escaped
    |c[;]       |.comment  | -> | MARK                         |>> :child_block_comment
    |c[<P>]     |.element  | ->                                |>> /element(ACTUAL_COL) :children_after_element
    |c[:]       |.attr     | ->                                |>> :attr_key
    |c[`]       |.backtick | ->                                |>> :child_freeform_check
    |c[!]       |.directive| ->                                |>> :child_directive
    |default    |.prose    | MARK                              |>> :child_prose

  |state[:children_after_element]
    ; After child element returns - child already consumed this line's whitespace
    ; We're at the first non-whitespace char (or newline).
    |eof                                   | emit(ElementEnd)  |return
    |c[\n]      |.newline  | ->                         |>> :children
    |c[ ]       |.space    | ->                         |>> :children_count_ws
    |c[\t]      |.tab      | -> | emit(Error:no_tabs)          |>> :skip_child
    |default                                            |>> :children_content

  |state[:children_count_ws]
    ; Counting whitespace after seeing first space in :children_after_element
    |eof                                   | emit(ElementEnd)  |return
    |c[\n]      |.newline  | ->                         |>> :children
    |c[ ]       |.space    | ->                        |>> :children_count_ws
    |c[\t]      |.tab      | -> | emit(Error:no_tabs)          |>> :skip_child
    |default               |                                   |>> :children_content

  |state[:child_escaped]
    |eof                   | emit(Text) | emit(ElementEnd)     |return
    |c[\n]      |.done     | emit(Text) | ->            |>> :children
    |default    |.first    | MARK                              |>> :child_escaped_text

  |state[:child_escaped_text] SCAN(\n)
    ; Collect escaped text - no special char handling (| ; ! are literal)
    ; SCAN-first: bulk scan to newline
    |eof                   | emit(Text) | emit(ElementEnd)     |return
    |c[\n]      |.done     | emit(Text) | ->            |>> :children

  |state[:child_prose] SCAN(\n;<P>)
    ; SCAN-first: bulk scan to newline, semicolon, or pipe
    |eof                   | emit(Text) | emit(ElementEnd)     |return
    |c[\n]      |.done     | emit(Text) | ->            |>> :children
    |c[;]       |.semi     | emit(Text) | ->                   |>> :child_comment_check
    |c[<P>]     |.pipe     | emit(Text) | ->                   |>> /element(ACTUAL_COL) :children_after_element

  |state[:child_comment_check]
    |eof                   | emit(ElementEnd)                  |return
    |c[{]       |.inline   | ->                                |>> :child_inline_comment
    |default    |.line     | MARK                              |>> :child_line_comment

  |state[:child_inline_comment]
    |eof                   | emit(ElementEnd)                  |return
    |c[}]       |.close    | ->                                |>> :child_prose
    |default    |.collect  | ->                                |>>

  |state[:child_line_comment] SCAN(\n)
    ; SCAN-first: bulk scan to newline
    |eof                   | emit(Comment) | emit(ElementEnd)  |return
    |c[\n]      |.done     | emit(Comment) | ->         |>> :children

  |state[:child_block_comment] SCAN(\n)
    ; SCAN-first: bulk scan to newline
    |eof                   | emit(Comment) | emit(ElementEnd)  |return
    |c[\n]      |.done     | emit(Comment) | ->         |>> :children

  |state[:child_freeform_check]
    |eof                   | emit(Text) | emit(ElementEnd)     |return
    |c[`]       |.second   | ->                                |>> :child_freeform_check2
    |default    |.not      | MARK                              |>> :child_prose

  |state[:child_freeform_check2]
    |eof                   | emit(Text) | emit(ElementEnd)     |return
    |c[`]       |.third    | MARK                              |>> :child_freeform
    |default    |.not      | MARK                              |>> :child_prose

  |state[:child_freeform]
    |eof                   | emit(Error:unclosed_freeform) | emit(ElementEnd) |return
    |c[`]       |.maybe    | ->                                |>> :child_freeform_end1
    |default    |.collect  | ->                                |>>

  |state[:child_freeform_end1]
    |eof                   | emit(Error:unclosed_freeform) | emit(ElementEnd) |return
    |c[`]       |.second   | ->                                |>> :child_freeform_end2
    |default    |.not      | ->                                |>> :child_freeform

  |state[:child_freeform_end2]
    |eof                   | emit(Error:unclosed_freeform) | emit(ElementEnd) |return
    |c[`]       |.close    | emit(RawContent)           |>> :children
    |default    |.not      | ->                                |>> :child_freeform

  |state[:child_directive]
    |eof                   | emit(Directive) | emit(ElementEnd)|return
    |c[{]       |.interp   | MARK                              |>> :child_directive_interp
    |default    |.name     | MARK                              |>> :child_directive_name

  |state[:child_directive_interp]
    |eof                   | emit(Error:unclosed) | emit(ElementEnd) |return
    |c[}]       |.close    | emit(Interpolation)              |>> :child_prose
    |default    |.collect  | ->                                |>>

  |state[:child_directive_name]
    |eof                   | emit(Directive) | emit(ElementEnd)|return
    |c[\n]      |.block    | emit(Directive) | ->       |>> :children
    |c[{]       |.body     | emit(Directive)                   |>> :child_directive_body
    |c[ \t]     |.end      | emit(Directive)                   |>> :child_prose
    |default    |.collect  | ->                                |>>

  |state[:child_directive_body]
    |eof                   | emit(Error:unclosed) | emit(ElementEnd) |return
    |c[}]       |.close    | emit(DirectiveBody)              |>> :child_prose
    |default    |.collect  | ->                                |>>

  |state[:skip_child]
    |eof                   | emit(ElementEnd)                  |return
    |c[\n]      |.done     | ->                         |>> :children
    |default    |.skip     | ->                                |>>

  ;============================================================================
  ; ATTRIBUTE PARSING - Indented attributes `:key value`
  ; SPEC.md:670 - attribute = ":" ( LABEL | quoted_label ) [ value ]
  ;
  ; Called after `:` consumed. Emits:
  ;   Attribute { key } followed by value event(s)
  ;
  ; Value types:
  ;   - Missing/newline/semicolon → BoolValue(true) (flag attribute)
  ;   - [...]  → ArrayStart, values..., ArrayEnd
  ;   - "..."  → QuotedStringValue
  ;   - '...'  → QuotedStringValue
  ;   - other  → typed value (int/float/bool/nil/string)
  ;============================================================================

  |state[:attr_key]
    ; SPEC.md:670 - Parse attribute key (LABEL or quoted)
    ; Example: :foo-bar value → Attribute("foo-bar"), then value
    |eof                     | emit(Error:expected_attr_key) | emit(ElementEnd) |return
    |c[LETTER]    |.name    | MARK                              |>> :attr_key_scan
    |c[']         |.quoted  | ->                                |>> :attr_key_quoted
    |default      |.err     | emit(Error:expected_attr_key)     |>> :children

  |state[:attr_key_scan]
    ; Scanning attribute key label
    |eof           |.done   | emit(Attribute)                   |>> :attr_ws
    |c[LABEL_CONT] |.cont   | ->                                |>>
    |default       |.done   | emit(Attribute)                   |>> :attr_ws

  |state[:attr_key_quoted]
    ; Quoted attribute key: :'odd key'
    ; After opening ' consumed - now at content
    |eof                     | emit(Error:unclosed_quote) | emit(ElementEnd) |return
    |c[']         |.empty   | MARK | emit(Attribute) | ->       |>> :attr_ws
    |default      |.content | MARK                              |>> :attr_key_quoted_content

  |state[:attr_key_quoted_content]
    |eof                     | emit(Error:unclosed_quote) | emit(ElementEnd) |return
    |c[']         |.close   | emit(Attribute)                   |>> :attr_ws
    |c[\\]        |.escape  | ->                                |>> :attr_key_quoted_esc
    |default      |.collect | ->                                |>>

  |state[:attr_key_quoted_esc]
    |eof                     | emit(Error:unclosed_quote) | emit(ElementEnd) |return
    |default      |.char    | ->                                |>> :attr_key_quoted_content

  |state[:attr_ws]
    ; Skip whitespace before value
    |eof                                                        |>> :attr_value
    |c[ \t]       |.space   | ->                                |>>
    |default      |.done    |                                   |>> :attr_value

  |state[:attr_value]
    ; SPEC.md:671-680 - Dispatch on value type
    ; Flag attribute (no value) → emit BoolValue(true)
    |eof                      | emit(BoolValue:true)            |>> :children
    |c[\n]        |.flag     | emit(BoolValue:true)      |>> :children
    |c[;]         |.flag     | emit(BoolValue:true)             |>> :attr_comment
    |c[<L>]       |.array    | emit(ArrayStart) | ->            |>> /array :attr_after_value
    |c["]         |.dquote   | ->                               |>> :attr_dquote
    |c[']         |.squote   | ->                               |>> :attr_squote
    |default      |.bare     | MARK                             |>> :attr_bare

  |state[:attr_comment]
    ; Comment after flag attribute - rest of line is comment
    |eof                      |                                 |>> :children
    |c[\n]        |.done                                 |>> :children
    |default      |.skip     | ->                               |>>

  |state[:attr_dquote]
    ; Double-quoted string value: :key "value"
    ; After opening " consumed - now at content
    ; Example: :msg "hello world" → QuotedStringValue("hello world")
    |eof                      | emit(Error:unclosed_string) | emit(ElementEnd) |return
    |c["]         |.empty    | MARK | emit(QuotedStringValue) | -> |>> :attr_after_value
    |default      |.content  | MARK                             |>> :attr_dquote_content

  |state[:attr_dquote_content] SCAN("<BS>)
    ; SCAN-first: bulk scan to quote or escape
    |eof                      | emit(Error:unclosed_string)     |>> :children
    |c["]         |.close    | emit(QuotedStringValue) | ->     |>> :attr_after_value
    |c[<BS>]      |.escape   | ->                               |>> :attr_dquote_esc

  |state[:attr_dquote_esc]
    |eof                      | emit(Error:unclosed_string)     |>> :children
    |default      |.char     | ->                               |>> :attr_dquote_content

  |state[:attr_squote]
    ; Single-quoted string value: :key 'value'
    ; After opening ' consumed - now at content
    |eof                      | emit(Error:unclosed_string) | emit(ElementEnd) |return
    |c[']         |.empty    | MARK | emit(QuotedStringValue) | -> |>> :attr_after_value
    |default      |.content  | MARK                             |>> :attr_squote_content

  |state[:attr_squote_content] SCAN('<BS>)
    ; SCAN-first: bulk scan to quote or escape
    |eof                      | emit(Error:unclosed_string)     |>> :children
    |c[']         |.close    | emit(QuotedStringValue) | ->     |>> :attr_after_value
    |c[<BS>]      |.escape   | ->                               |>> :attr_squote_esc

  |state[:attr_squote_esc]
    |eof                      | emit(Error:unclosed_string)     |>> :children
    |default      |.char     | ->                               |>> :attr_squote_content

  |state[:attr_bare] SCAN(\n;)
    ; Bare (unquoted) value - collect until ; or newline
    ; SCAN-first: bulk scan to newline or semicolon
    ; Type determined by content: true/false/null/nil/~/number/string
    ; Example: :count 42 → TypedValue(emits IntegerValue or StringValue)
    |eof                      | emit(TypedValue)                |>> :children
    |c[\n]        |.done     | emit(TypedValue)          |>> :children
    |c[;]         |.done     | emit(TypedValue)                 |>> :attr_comment

  |state[:attr_after_value]
    ; After quoted value - skip to end of attribute
    |eof                      |                                 |>> :children
    |c[\n]        |.done                                 |>> :children
    |c[;]         |.comment  |                                  |>> :attr_comment
    |c[ \t]       |.space    | ->                               |>>
    |default      |.extra    | emit(Error:unexpected_after_value) |>> :attr_skip_line

  |state[:attr_skip_line]
    ; Error recovery - skip to newline
    |eof                      |                                 |>> :children
    |c[\n]        |.done                                 |>> :children
    |default      |.skip     | ->                               |>>

;==============================================================================
; ARRAY FUNCTION - [value value ...]
; SPEC.md:696-700 - list = "[" { value }* "]"
;
; Proper recursive descent: /array is called after seeing [, returns after ].
; Nested [ calls /array recursively - the call stack handles depth naturally.
;==============================================================================
|function[array]

  |state[:values]
    ; Inside array - looking for values or ]
    ; Example: [a b c] → StringValue(a), StringValue(b), StringValue(c), ArrayEnd
    |eof                     | emit(Error:unclosed_array)       |return
    |c[ \t]       |.space    | ->                               |>>
    |c[\n]        |.newline  | ->                               |>>
    |c[<R>]       |.close    | emit(ArrayEnd) | ->              |return
    |c["]         |.dquote   | ->                               |>> :dquote
    |c[']         |.squote   | ->                               |>> :squote
    |c[<L>]       |.nested   | emit(ArrayStart) | ->            |>> /array :values
    |default      |.bare     | MARK                             |>> :bare

  |state[:dquote]
    ; Double-quoted string in array
    ; After opening " consumed - now at content
    |eof                      | emit(Error:unclosed_string)     |return
    |c["]         |.empty    | MARK | emit(QuotedStringValue) | -> |>> :values
    |default      |.content  | MARK                             |>> :dquote_content

  |state[:dquote_content]
    |eof                      | emit(Error:unclosed_string)     |return
    |c["]         |.close    | emit(QuotedStringValue) | ->     |>> :values
    |c[\\]        |.escape   | ->                               |>> :dquote_esc
    |default      |.collect  | ->                               |>>

  |state[:dquote_esc]
    |eof                      | emit(Error:unclosed_string)     |return
    |default      |.char     | ->                               |>> :dquote_content

  |state[:squote]
    ; Single-quoted string in array
    ; After opening ' consumed - now at content
    |eof                      | emit(Error:unclosed_string)     |return
    |c[']         |.empty    | MARK | emit(QuotedStringValue) | -> |>> :values
    |default      |.content  | MARK                             |>> :squote_content

  |state[:squote_content]
    |eof                      | emit(Error:unclosed_string)     |return
    |c[']         |.close    | emit(QuotedStringValue) | ->     |>> :values
    |c[\\]        |.escape   | ->                               |>> :squote_esc
    |default      |.collect  | ->                               |>>

  |state[:squote_esc]
    |eof                      | emit(Error:unclosed_string)     |return
    |default      |.char     | ->                               |>> :squote_content

  |state[:bare]
    ; Bare value in array - collect until whitespace or ]
    |eof                      | emit(TypedValue) | emit(Error:unclosed_array) |return
    |c[ \t\n]     |.done     | emit(TypedValue)                 |>> :values
    |c[<R>]       |.done     | emit(TypedValue) | emit(ArrayEnd) | -> |return
    |default      |.collect  | ->                               |>>
