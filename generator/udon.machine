|parser udon

; UDON Parser - Full Grammar via DSL
;
; Uses recursive function calls for element nesting:
;   /element(ACTUAL_COL) - call pushes element, return pops + emits ElementEnd
;
; CALLs only for:
;   - parse_element_identity: complex unicode label parsing
;   - parse_indented_attribute: typed value parsing

|entry-point /document

;==============================================================================
; ROOT DOCUMENT - Fully Generated
;==============================================================================
|function[document]
  |var[col] = 0

  |state[:start]
    |eof                                                |return
    |c[\n]      |.newline     | -> | col=0              |>> :start
    |c[ ]       |.space       | -> | col+=1             |>> :start
    |c[\t]      |.tab         | -> | emit(Error:no_tabs) |>> :skip_line
    |c[']       |.escape      | ->                      |>> :escaped
    |c[;]       |.comment     | -> | MARK               |>> :block_comment
    |c[<P>]     |.pipe        | ->                         |>> /element(ACTUAL_COL) :start
    |c[`]       |.backtick    | ->                      |>> :maybe_freeform
    |c[!]       |.directive   | ->                      |>> :directive
    |default    |.text        | MARK                    |>> :prose

  |state[:escaped]
    ; Line started with ' - rest is literal, no special chars
    |eof                       | emit(Text)             |return
    |c[\n]      |.done        | emit(Text) | col=0     |>> :start
    |default    |.first       | MARK                    |>> :escaped_text

  |state[:escaped_text]
    ; Collect escaped text - no special char handling (| ; ! are literal)
    |eof                       | emit(Text)             |return
    |c[\n]      |.done        | emit(Text) | col=0     |>> :start
    |default    |.collect     | ->                      |>>

  |state[:prose]
    |eof                       | emit(Text)             |return
    |c[\n]      |.done        | emit(Text) | col=0     |>> :start
    |c[;]       |.semi        | emit(Text) | ->         |>> :check_inline_comment
    |c[<P>]     |.pipe        | emit(Text) | ->         |>> /element(ACTUAL_COL) :start
    |default    |.collect     | ->                      |>>

  |state[:check_inline_comment]
    ; After ; in prose - is it ;{...} or rest-of-line comment?
    |c[{]       |.inline      | ->                      |>> :inline_comment
    |default    |.block       | MARK                    |>> :line_comment

  |state[:inline_comment]
    ; ;{...} - balanced braces stripped from output
    |eof                       | emit(Error:unclosed_comment) |return
    |c[}]       |.close       | ->                      |>> :prose
    |c[{]       |.nest        | ->                      |>> :inline_comment_nested
    |default    |.collect     | ->                      |>>

  |state[:inline_comment_nested]
    ; Nested braces in inline comment - simple nesting (one level)
    |eof                       | emit(Error:unclosed_comment) |return
    |c[}]       |.close       | ->                      |>> :inline_comment
    |default    |.collect     | ->                      |>>

  |state[:line_comment]
    ; Rest of line after ; (not ;{)
    |eof                       | emit(Comment)          |return
    |c[\n]      |.done        | emit(Comment) | col=0  |>> :start
    |default    |.collect     | ->                      |>>

  |state[:block_comment]
    ; Full line comment starting with ;
    |eof                       | emit(Comment)          |return
    |c[\n]      |.done        | emit(Comment) | col=0  |>> :start
    |default    |.collect     | ->                      |>>

  |state[:maybe_freeform]
    ; Saw one ` - check for ```
    |c[`]       |.second      | ->                      |>> :maybe_freeform2
    |default    |.not         | MARK                    |>> :prose

  |state[:maybe_freeform2]
    ; Saw `` - check for third
    |c[`]       |.third       | MARK                    |>> :freeform
    |default    |.not         | MARK                    |>> :prose

  |state[:freeform]
    ; Inside ``` block - preserve exact whitespace
    |eof                       | emit(Error:unclosed_freeform) |return
    |c[`]       |.maybe_end   | ->                      |>> :freeform_end1
    |default    |.collect     | ->                      |>>

  |state[:freeform_end1]
    |c[`]       |.second      | ->                      |>> :freeform_end2
    |default    |.not         | ->                      |>> :freeform

  |state[:freeform_end2]
    |c[`]       |.close       | emit(RawContent) | col=0 |>> :start
    |default    |.not         | ->                      |>> :freeform

  |state[:directive]
    ; After ! - could be !{expr} or !name
    |eof                       | emit(Error:incomplete_directive) |return
    |c[{]       |.interp      | MARK                    |>> :directive_interp
    |default    |.name        | MARK                    |>> :directive_name

  |state[:directive_interp]
    ; !{...} interpolation
    |eof                       | emit(Error:unclosed_directive) |return
    |c[}]       |.close       | emit(Interpolation)    |>> :prose_after_directive
    |default    |.collect     | ->                      |>>

  |state[:directive_name]
    ; !name...
    |eof                       | emit(Directive)        |return
    |c[\n]      |.block       | emit(Directive) | col=0 |>> :start
    |c[{]       |.inline      | emit(Directive)        |>> :directive_body
    |c[ \t]     |.space       | emit(Directive)        |>> :prose_after_directive
    |default    |.collect     | ->                      |>>

  |state[:directive_body]
    ; !name{...} inline directive body
    |eof                       | emit(Error:unclosed_directive) |return
    |c[}]       |.close       | emit(DirectiveBody)    |>> :prose_after_directive
    |default    |.collect     | ->                      |>>

  |state[:prose_after_directive]
    ; Continue prose after inline directive
    |eof                       | emit(Text)             |return
    |c[\n]      |.done        | emit(Text) | col=0     |>> :start
    |c[;]       |.semi        | emit(Text) | ->         |>> :check_inline_comment
    |c[<P>]     |.pipe        | emit(Text) | ->         |>> /element(ACTUAL_COL) :start
    |default    |.collect     | MARK                    |>> :prose

  |state[:skip_line]
    ; Error recovery - skip to next line
    |eof                                                |return
    |c[\n]      |.done        | col=0                   |>> :start
    |default    |.skip        | ->                      |>>

;==============================================================================
; ELEMENT FUNCTION
; SPEC.md:43-105, 645-662
;
; Called when we see | at some column. The element function handles:
;   1. Identity parsing (name, [id], .class, suffix)
;   2. Inline content (text, nested elements)
;   3. Indented children (via dedent detection)
;
; Entering = implicit stack push
; Returning = implicit stack pop + ElementEnd event
;==============================================================================
|function[element] :elem_col
  |var[col] = :elem_col
  |var[content_base] = -1

  ;============================================================================
  ; ELEMENT IDENTITY PARSING
  ; SPEC.md:654 - element = "|" [ name ] [ suffix ] [ id [ suffix ] ] { class }*
  ;                         [ SPACE suffix ] { attribute }* { inline_child }*
  ;
  ; Key insight: Each piece of identity syntax desugars to attributes:
  ;   [id]     → :'$id' value      (SPEC.md:60-68)
  ;   .class   → :'$class' name    (SPEC.md:572-576)
  ;   ?!*+     → :'<char>' true    (SPEC.md:74-88)
  ;
  ; Events are emitted immediately as each piece is parsed - no accumulation.
  ;============================================================================

  |state[:identity]
    ; SPEC.md:645-651 - Element recognition rules
    ; "|" is element when followed by: letter, [, ., {, ', or suffix
    ; Otherwise "|" is prose (Markdown table compatibility)
    ;
    ; Examples:
    ;   |foo     → ElementStart("foo")
    ;   |[id]    → ElementStartAnon, Attribute("$id"), StringValue("id")
    ;   |.class  → ElementStartAnon, Attribute("$class"), StringValue("class")
    ;   |?       → ElementStartAnon, Attribute("?"), BoolValue(true)
    ;   |'name'  → ElementStart("name")
    |c[LETTER]    |.name     | MARK                              |>> :id_name
    |c[<L>]       |.bracket  | ->                                |>> :id_anon_bracket
    |c[.]         |.dot      | emit(ElementStartAnon)            |>> :id_class_start
    |c[?]         |.q        | emit(ElementStartAnon) | emit(Attribute:?) | emit(BoolValue:true) |>> :id_check_more
    |c[!]         |.bang     | emit(ElementStartAnon) | emit(Attribute:!) | emit(BoolValue:true) |>> :id_check_more
    |c[*]         |.star     | emit(ElementStartAnon) | emit(Attribute:*) | emit(BoolValue:true) |>> :id_check_more
    |c[+]         |.plus     | emit(ElementStartAnon) | emit(Attribute:+) | emit(BoolValue:true) |>> :id_check_more
    |c[']         |.quote    | ->                                |>> :id_quoted_name
    |default      |.anon     | emit(ElementStartAnon)            |>> :after_identity

  |state[:id_name]
    ; SPEC.md:656 - name = LABEL | quoted_label
    ; LABEL = /[\p{L}_][\p{L}\p{N}_-]*/
    ;
    ; Example: |foo-bar → scans "foo-bar", emits ElementStart("foo-bar")
    |c[LABEL_CONT] |.cont    | ->                                |>>
    |default       |.done    | emit(ElementStart)                |>> :id_after_name

  |state[:id_after_name]
    ; After element name - check for suffix, [id], or .class
    ; SPEC.md:89-98 - Suffix allowed positions
    ;
    ; Examples:
    ;   |foo?      → ..., Attribute("?"), BoolValue(true)
    ;   |foo[id]   → ..., Attribute("$id"), StringValue("id")
    ;   |foo.bar   → ..., Attribute("$class"), StringValue("bar")
    |c[?]         |.q        | emit(Attribute:?) | emit(BoolValue:true) | -> |>> :id_check_bracket
    |c[!]         |.bang     | emit(Attribute:!) | emit(BoolValue:true) | -> |>> :id_check_bracket
    |c[*]         |.star     | emit(Attribute:*) | emit(BoolValue:true) | -> |>> :id_check_bracket
    |c[+]         |.plus     | emit(Attribute:+) | emit(BoolValue:true) | -> |>> :id_check_bracket
    |c[<L>]       |.bracket  | ->                                |>> :id_bracket_start
    |c[.]         |.dot      | ->                                |>> :id_class_start
    |default      |.done     |                                   |>> :after_identity

  |state[:id_check_bracket]
    ; After name+suffix - can still have [id] or .class
    ; Example: |foo?[id] → suffix already emitted, now parse [id]
    |c[<L>]       |.bracket  | ->                                |>> :id_bracket_start
    |c[.]         |.dot      | ->                                |>> :id_class_start
    |default      |.done     |                                   |>> :after_identity

  |state[:id_bracket_start]
    ; SPEC.md:60-68 - [id] syntax desugars to :'$id' value
    ; Called after ElementStart already emitted
    ;
    ; Example: |foo[myid] → Attribute("$id"), StringValue("myid")
    |c[<R>]       |.empty    | ->                                |>> :id_after_bracket
    |default      |.value    | emit(Attribute:$id) | MARK        |>> :id_bracket_value

  |state[:id_anon_bracket]
    ; Anonymous element starting with [
    ; Must emit ElementStartAnon before the $id attribute
    ;
    ; Example: |[myid] → ElementStartAnon, Attribute("$id"), StringValue("myid")
    |c[<R>]       |.empty    | emit(ElementStartAnon)            |>> :id_after_bracket
    |default      |.value    | emit(ElementStartAnon) | emit(Attribute:$id) | MARK |>> :id_bracket_value

  |state[:id_bracket_value]
    ; SPEC.md:657-658 - id_value = typed_value | bare_string
    ; Collecting bytes until ] - value type determined by content
    ;
    ; Example: |foo[123] → StringValue("123") (consumer may parse as int)
    |c[<R>]       |.close    | emit(StringValue) | ->            |>> :id_after_bracket
    |default      |.collect  | ->                                |>>

  |state[:id_after_bracket]
    ; After [id] - check for suffix or .class
    ; SPEC.md:95 - |name[id]? is valid (suffix after id)
    |c[?]         |.q        | emit(Attribute:?) | emit(BoolValue:true) | -> |>> :id_check_class
    |c[!]         |.bang     | emit(Attribute:!) | emit(BoolValue:true) | -> |>> :id_check_class
    |c[*]         |.star     | emit(Attribute:*) | emit(BoolValue:true) | -> |>> :id_check_class
    |c[+]         |.plus     | emit(Attribute:+) | emit(BoolValue:true) | -> |>> :id_check_class
    |c[.]         |.dot      | ->                                |>> :id_class_start
    |default      |.done     |                                   |>> :after_identity

  |state[:id_check_class]
    ; After [id]+suffix - can still have .class
    |c[.]         |.dot      | ->                                |>> :id_class_start
    |default      |.done     |                                   |>> :after_identity

  |state[:id_class_start]
    ; SPEC.md:572-576 - Classes desugar to :'$class' [names...]
    ; Each .class emits: Attribute("$class"), StringValue("classname")
    ;
    ; Example: |foo.bar → Attribute("$class"), StringValue("bar")
    ; Example: |foo.'odd name' → Attribute("$class"), QuotedStringValue("odd name")
    |c[LETTER]    |.name     | emit(Attribute:$class) | MARK     |>> :id_class_name
    |c[']         |.quote    | emit(Attribute:$class)            |>> :id_class_quoted
    |default      |.err      | emit(Error:expected_class_name)   |>> :after_identity

  |state[:id_class_name]
    ; SPEC.md:659 - class = "." LABEL
    ; Scanning class name until non-LABEL char
    |c[LABEL_CONT] |.cont    | ->                                |>>
    |default       |.done    | emit(StringValue)                 |>> :id_class_check_more

  |state[:id_class_check_more]
    ; After class name - check for more .class or space+suffix
    ; SPEC.md:100-105 - suffix on class is reserved (NOT allowed)
    ;
    ; Example: |foo.bar.baz → multiple classes, each emits separately
    |c[.]         |.more     | ->                                |>> :id_class_start
    |c[ ]         |.space    | ->                                |>> :id_space_suffix
    |default      |.done     |                                   |>> :after_identity

  |state[:id_space_suffix]
    ; SPEC.md:97 - |name[id].class ? (space-separated suffix at end)
    ; Only suffix chars valid here, otherwise back to content parsing
    |c[?]         |.q        | emit(Attribute:?) | emit(BoolValue:true) | -> |>> :after_identity
    |c[!]         |.bang     | emit(Attribute:!) | emit(BoolValue:true) | -> |>> :after_identity
    |c[*]         |.star     | emit(Attribute:*) | emit(BoolValue:true) | -> |>> :after_identity
    |c[+]         |.plus     | emit(Attribute:+) | emit(BoolValue:true) | -> |>> :after_identity
    |c[ ]         |.more     | ->                                |>>
    |default      |.nosuffix |                                   |>> :after_identity

  |state[:id_quoted_name]
    ; Quoted element name: |'has spaces'
    ; Allows any characters in element name
    |c[']         |.close    | emit(ElementStart)                |>> :id_after_name
    |default      |.collect  | MARK                              |>> :id_quoted_name_content

  |state[:id_quoted_name_content]
    ; Inside quoted name - collect until closing quote
    ; Backslash escapes the next character
    |c[']         |.close    | emit(ElementStart)                |>> :id_after_name
    |c[\\]        |.escape   | ->                                |>> :id_quoted_name_escape
    |default      |.collect  | ->                                |>>

  |state[:id_quoted_name_escape]
    ; After backslash - next char is literal
    |default      |.char     | ->                                |>> :id_quoted_name_content

  |state[:id_class_quoted]
    ; Quoted class name: |foo.'has spaces'
    ; Must see opening quote next
    |c[']         |.start    | MARK                              |>> :id_class_quoted_content
    |default      |.err      | emit(Error:expected_quote)        |>> :after_identity

  |state[:id_class_quoted_content]
    ; Inside quoted class name
    |c[']         |.close    | emit(QuotedStringValue)           |>> :id_class_check_more
    |c[\\]        |.escape   | ->                                |>> :id_class_quoted_escape
    |default      |.collect  | ->                                |>>

  |state[:id_class_quoted_escape]
    ; After backslash in quoted class
    |default      |.char     | ->                                |>> :id_class_quoted_content

  |state[:id_check_more]
    ; After suffix on anonymous element - can still have [id] or .class
    ; Example: |?[id] → suffix emitted, now parse id
    |c[<L>]       |.bracket  | ->                                |>> :id_bracket_start
    |c[.]         |.dot      | ->                                |>> :id_class_start
    |default      |.done     |                                   |>> :after_identity

  ;============================================================================
  ; AFTER IDENTITY - Inline content and transition to children
  ;============================================================================

  |state[:after_identity]
    |eof                                   | emit(ElementEnd)  |return
    |c[\n]      |.newline  | -> | col=0                        |>> :children
    |c[ \t]     |.space    | -> | col+=1                       |>> :inline_content
    |c[;]       |.comment  | ->                                |>> :elem_comment_check
    |c[<P>]     |.nested   | ->                                |>> /element(ACTUAL_COL) :inline_content
    |default    |.text     | MARK                              |>> :inline_text

  |state[:inline_content]
    ; Inline content after element identity
    |eof                   | emit(ElementEnd)                  |return
    |c[\n]      |.newline  | -> | col=0                        |>> :children
    |c[;]       |.comment  | ->                                |>> :elem_comment_check
    |c[<P>]     |.nested   | ->                                |>> /element(ACTUAL_COL) :inline_content
    |default    |.text     | MARK                              |>> :inline_text

  |state[:inline_text]
    |eof                   | emit(Text) | emit(ElementEnd)     |return
    |c[\n]      |.done     | emit(Text) | -> | col=0           |>> :children
    |c[;]       |.semi     | emit(Text) | ->                   |>> :elem_comment_check
    |c[<P>]     |.pipe     | emit(Text) | ->                   |>> /element(ACTUAL_COL) :inline_content
    |default    |.collect  | ->                                |>>

  |state[:elem_comment_check]
    |c[{]       |.inline   | ->                                |>> :elem_inline_comment
    |default    |.line     | MARK                              |>> :elem_line_comment

  |state[:elem_inline_comment]
    |eof                   | emit(ElementEnd)                  |return
    |c[}]       |.close    | ->                                |>> :inline_content
    |default    |.collect  | ->                                |>>

  |state[:elem_line_comment]
    |eof                   | emit(Comment) | emit(ElementEnd)  |return
    |c[\n]      |.done     | emit(Comment) | -> | col=0        |>> :children
    |default    |.collect  | ->                                |>>

  ;----------------------------------------------------------------------------
  ; CHILDREN - indented content after element
  ; Split into whitespace counting and content handling for correct dedent check
  ;----------------------------------------------------------------------------
  |state[:children]
    |eof                                   | emit(ElementEnd)  |return
    |c[\n]      |.blank    | -> | col=0                        |>> :children
    |c[ ]       |.space    | -> | col+=1                       |>> :children
    |c[\t]      |.tab      | -> | emit(Error:no_tabs)          |>> :skip_child
    |default               |                                   |>> :children_content

  |state[:children_content]
    ; DEDENT CHECK: use actual column from line_start, not tracked col
    |if[ACTUAL_COL <= elem_col]            | emit(ElementEnd)  |return
    ; Still inside this element - handle actual content
    |c[']       |.escape   | ->                                |>> :child_escaped
    |c[;]       |.comment  | -> | MARK                         |>> :child_block_comment
    |c[<P>]     |.element  | ->                                |>> /element(ACTUAL_COL) :children_after_element
    |c[:]       |.attr     | -> | CALL:parse_indented_attribute |>> :children
    |c[`]       |.backtick | ->                                |>> :child_freeform_check
    |c[!]       |.directive| ->                                |>> :child_directive
    |default    |.prose    | MARK                              |>> :child_prose

  |state[:children_after_element]
    ; After child element returns - child already consumed this line's whitespace
    ; We're at the first non-whitespace char (or newline). Reset col appropriately.
    |eof                                   | emit(ElementEnd)  |return
    |c[\n]      |.newline  | -> | col=0                        |>> :children
    |c[ ]       |.space    | -> | col=1                        |>> :children_count_ws
    |c[\t]      |.tab      | -> | emit(Error:no_tabs)          |>> :skip_child
    |default               | col=0                             |>> :children_content

  |state[:children_count_ws]
    ; Counting whitespace after seeing first space in :children_after_element
    |eof                                   | emit(ElementEnd)  |return
    |c[\n]      |.newline  | -> | col=0                        |>> :children
    |c[ ]       |.space    | -> | col+=1                       |>> :children_count_ws
    |c[\t]      |.tab      | -> | emit(Error:no_tabs)          |>> :skip_child
    |default               |                                   |>> :children_content

  |state[:child_escaped]
    |eof                   | emit(Text) | emit(ElementEnd)     |return
    |c[\n]      |.done     | emit(Text) | -> | col=0           |>> :children
    |default    |.first    | MARK                              |>> :child_escaped_text

  |state[:child_escaped_text]
    ; Collect escaped text - no special char handling (| ; ! are literal)
    |eof                   | emit(Text) | emit(ElementEnd)     |return
    |c[\n]      |.done     | emit(Text) | -> | col=0           |>> :children
    |default    |.collect  | ->                                |>>

  |state[:child_prose]
    |eof                   | emit(Text) | emit(ElementEnd)     |return
    |c[\n]      |.done     | emit(Text) | -> | col=0           |>> :children
    |c[;]       |.semi     | emit(Text) | ->                   |>> :child_comment_check
    |c[<P>]     |.pipe     | emit(Text) | ->                   |>> /element(ACTUAL_COL) :children_after_element
    |default    |.collect  | ->                                |>>

  |state[:child_comment_check]
    |c[{]       |.inline   | ->                                |>> :child_inline_comment
    |default    |.line     | MARK                              |>> :child_line_comment

  |state[:child_inline_comment]
    |eof                   | emit(ElementEnd)                  |return
    |c[}]       |.close    | ->                                |>> :child_prose
    |default    |.collect  | ->                                |>>

  |state[:child_line_comment]
    |eof                   | emit(Comment) | emit(ElementEnd)  |return
    |c[\n]      |.done     | emit(Comment) | -> | col=0        |>> :children
    |default    |.collect  | ->                                |>>

  |state[:child_block_comment]
    |eof                   | emit(Comment) | emit(ElementEnd)  |return
    |c[\n]      |.done     | emit(Comment) | -> | col=0        |>> :children
    |default    |.collect  | ->                                |>>

  |state[:child_freeform_check]
    |c[`]       |.second   | ->                                |>> :child_freeform_check2
    |default    |.not      | MARK                              |>> :child_prose

  |state[:child_freeform_check2]
    |c[`]       |.third    | MARK                              |>> :child_freeform
    |default    |.not      | MARK                              |>> :child_prose

  |state[:child_freeform]
    |eof                   | emit(Error:unclosed_freeform) | emit(ElementEnd) |return
    |c[`]       |.maybe    | ->                                |>> :child_freeform_end1
    |default    |.collect  | ->                                |>>

  |state[:child_freeform_end1]
    |c[`]       |.second   | ->                                |>> :child_freeform_end2
    |default    |.not      | ->                                |>> :child_freeform

  |state[:child_freeform_end2]
    |c[`]       |.close    | emit(RawContent) | col=0          |>> :children
    |default    |.not      | ->                                |>> :child_freeform

  |state[:child_directive]
    |eof                   | emit(Directive) | emit(ElementEnd)|return
    |c[{]       |.interp   | MARK                              |>> :child_directive_interp
    |default    |.name     | MARK                              |>> :child_directive_name

  |state[:child_directive_interp]
    |eof                   | emit(Error:unclosed) | emit(ElementEnd) |return
    |c[}]       |.close    | emit(Interpolation)              |>> :child_prose
    |default    |.collect  | ->                                |>>

  |state[:child_directive_name]
    |eof                   | emit(Directive) | emit(ElementEnd)|return
    |c[\n]      |.block    | emit(Directive) | -> | col=0      |>> :children
    |c[{]       |.body     | emit(Directive)                   |>> :child_directive_body
    |c[ \t]     |.end      | emit(Directive)                   |>> :child_prose
    |default    |.collect  | ->                                |>>

  |state[:child_directive_body]
    |eof                   | emit(Error:unclosed) | emit(ElementEnd) |return
    |c[}]       |.close    | emit(DirectiveBody)              |>> :child_prose
    |default    |.collect  | ->                                |>>

  |state[:skip_child]
    |eof                   | emit(ElementEnd)                  |return
    |c[\n]      |.done     | -> | col=0                        |>> :children
    |default    |.skip     | ->                                |>>
