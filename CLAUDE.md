# CLAUDE.md - Agent Guidelines for libudon

This is the core UDON parser library in Rust. It produces a C-compatible shared
library that language bindings (Ruby, Python, etc.) link against.

## Current Status: Phase 3 Rewrite

**Branch:** `phase-3-genmachine-rewrite`

The parser is being completely rewritten using **descent** (~/src/descent/), a
parser generator that produces callback-based recursive descent parsers.

**See `implementation-phase-3.md` for the full roadmap.**

Key changes from old architecture:
- **Deleted:** streaming.rs, ChunkArena, ChunkSlice, EventRing, StreamingEvent
- **Deleted:** Old 307KB generated parser.rs
- **New:** descent generates parser.rs from udon.desc

## Critical: Use SPEC.md as Authority

The UDON specification lives at `~/src/udon/SPEC.md`. This is the **only**
authoritative source for syntax rules.

Do NOT use:
- `_archive/` files (old architecture, outdated)
- Guesses about "obvious" behavior
- Other UDON-like formats as reference

When SPEC.md is ambiguous, ask Joseph for clarification.

## Architecture

```
libudon/
├── udon-core/           # Core parser library
│   └── src/
│       ├── lib.rs       # Public API exports
│       ├── parser.rs    # GENERATED by descent
│       ├── value.rs     # Scalar value parsing
│       └── span.rs      # Source locations
├── generator/           # Parser specification
│   └── udon.desc        # Parser definition (descent DSL)
├── examples/            # Test fixtures
├── _archive/            # Old architecture (do not use)
└── implementation-phase-3.md  # Current roadmap
```

## descent Workflow

descent is a separate gem at ~/src/descent/. It generates Rust parsers from
`.desc` specifications.

```bash
# Install descent locally (from ~/src/descent/)
cd ~/src/descent && dx gem install

# Generate parser (from libudon/)
descent generate generator/udon.desc -o udon-core/src/parser.rs

# Debug parsing stages
descent debug generator/udon.desc
descent debug generator/udon.desc --tokens
descent debug generator/udon.desc --ast
descent debug generator/udon.desc --ir
```

Do NOT edit `udon-core/src/parser.rs` directly - it's generated.

## The .desc DSL

See ~/src/descent/CLAUDE.md for full documentation. Quick reference:

```
|parser udon

|type[Element]     BRACKET    ; Emits ElementStart/ElementEnd
|type[Text]        CONTENT    ; Emits Text with content
|type[INT]         INTERNAL   ; No emit (internal computation)

|entry-point /document

|function[document]
  |state[:main]
    |c[\n]      | ->              |>>          ; Loop on newlines
    |c[|]       | -> | /element(0)|>>          ; Parse element
    |default    | /text(0)        |>>          ; Parse text

|function[element:Element] :col
  |state[:name]
    |LETTER     | /name           |>> :after
    |default    |                 |>> :content
  ...
```

Key concepts:
- **BRACKET types**: Emit Start on entry, End on return
- **CONTENT types**: MARK on entry, emit content on return
- **INTERNAL types**: No auto-emit (for intermediate values)
- **True recursion**: Call stack = element stack (no explicit stack)
- **SCAN optimization**: Self-looping default → memchr bulk scanning
- **EOF inference**: No explicit |eof needed, behavior inferred from type

## Generated Parser API

descent generates a callback-based parser:

```rust
pub enum Event<'a> {
    ElementStart { span: Range<usize> },
    ElementEnd { span: Range<usize> },
    Text { content: &'a [u8], span: Range<usize> },
    // ... other events
    Error { code: ParseErrorCode, span: Range<usize> },
}

pub struct Parser<'a> { ... }

impl<'a> Parser<'a> {
    pub fn new(input: &'a [u8]) -> Self;
    pub fn parse<F>(self, on_event: F) where F: FnMut(Event<'a>);
}
```

Usage:
```rust
let input = b"|div Hello World\n";
Parser::new(input).parse(|event| {
    println!("{:?}", event);
});
```

## Key Files

| File | Purpose | Edit? |
|------|---------|-------|
| `generator/udon.desc` | Parser specification | YES |
| `udon-core/src/parser.rs` | Generated parser | NO (regenerate) |
| `udon-core/src/value.rs` | Value type parsing | YES |
| `udon-core/src/span.rs` | Span types | YES |
| `implementation-phase-3.md` | Current roadmap | YES |

## UDON Syntax Quick Reference

### Four Core Prefixes

| Prefix | Domain | Example |
|--------|--------|---------|
| `\|` | Structure | `\|div`, `\|[id]`, `\|.class` |
| `:` | Attributes | `:key value` |
| `!` | Dynamics | `!if cond`, `!{{expr}}` |
| `;` | Comments | `; comment` |

### Inline Forms (bracket-delimited)

| Syntax | Description |
|--------|-------------|
| `\|{element ...}` | Embedded element |
| `!{{expr}}` | Interpolation |
| `!{directive ...}` | Inline directive |
| `;{comment}` | Inline comment |

### Element Identity

```
|name[id].class1.class2?    ; Element with id, classes, suffix
|[id-only]                   ; Anonymous with id
|.class-only                 ; Anonymous with class
```

### Directives

```
!if condition                ; Block directive
  content
!:lang:                      ; Raw block (content not parsed as UDON)
  raw content
!{include partial}           ; Inline directive
!{:json: {"key": "val"}}     ; Inline raw
```

## Testing

Old tests (udon-core/tests/) reference deleted infrastructure and need rewriting.
See implementation-phase-3.md for testing philosophy:

- Tests MUST derive from SPEC.md, not implementation
- Tests should cover edge cases at any column, not just column 0
- Use property-based testing where applicable

## Related Repositories

- `~/src/descent` - Parser generator (Ruby gem)
- `~/src/udon` - Specification, examples
- `~/src/udon-ruby` - Ruby gem (needs FFI update)
