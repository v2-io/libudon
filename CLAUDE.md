# CLAUDE.md - Agent Guidelines for libudon

This is the core UDON parser library in Rust. It produces a C-compatible shared
library that language bindings (Ruby, Python, etc.) link against.

## Current Status: Phase 3 Rewrite

**Branch:** `phase-3-genmachine-rewrite`

The parser is being completely rewritten using **descent** (~/src/descent/), a
parser generator that produces callback-based recursive descent parsers.

**See `implementation-phase-3.md` for the full roadmap.**

Key changes from old architecture:
- **Deleted:** streaming.rs, ChunkArena, ChunkSlice, EventRing, StreamingEvent
- **Deleted:** Old 307KB generated parser.rs
- **New:** descent generates parser.rs from .desc files

## The SPEC Is Ground Truth

The UDON specification lives in a single authoritative file:

- **~/src/udon/FULL-SPEC.md** - Complete unified specification

**If you don't have this file in your context, stop and read it now.**
Every session should start by confirming you understand the current spec.
This is the ONLY authoritative source for syntax rules.

Note: The older `SPEC.md`, `SPEC-INDENTS.md`, and `SPEC-UPDATE.md` files are
deprecated and superseded by FULL-SPEC.md.

Do NOT use:
- `_archive/` files (old architecture, outdated)
- Guesses about "obvious" behavior
- Other UDON-like formats as reference
- Fixture files as specification (they're starting points, not definitions)

## Architecture

```
libudon/
├── udon-core/           # Core parser library
│   ├── src/
│   │   ├── lib.rs       # Public API exports
│   │   ├── parser.rs    # GENERATED by descent (never edit)
│   │   ├── value.rs     # Scalar value parsing
│   │   └── span.rs      # Source locations
│   └── tests/
│       ├── fixtures/    # YAML test cases
│       ├── canonical.rs # Fixture-based test runner
│       └── common/      # Test infrastructure
├── generator/           # Parser specification
│   ├── udon.desc        # Main grammar
│   └── values.desc      # Value type parsing
├── regenerate-parser    # Script to regenerate parser.rs
├── PLAN.md              # Current implementation plan (keep updated!)
├── README.md            # Project documentation (keep updated!)
└── implementation-phase-3.md  # Phase 3 roadmap
```

## Regenerating the Parser

Always use the wrapper script from the project root:

```bash
./regenerate-parser           # Generate and build
./regenerate-parser --trace   # Generate with tracing (for debugging)
./regenerate-parser --no-build # Generate only
```

The script concatenates `generator/udon.desc` and `generator/values.desc` before
running descent. **Never edit `udon-core/src/parser.rs` directly.**

## Debugging: Use Tracing

**Tracing is your primary debugging tool.** When iterating on the grammar:

```bash
./regenerate-parser --trace
cargo run --example your_test
```

This produces trace output showing exactly what the parser does:

```
TRACE: L3 ENTER document | byte='L' pos=0
TRACE: L5 document:main.start | byte='L' term=[] pos=0
TRACE: L6 ENTER line | byte='L' pos=0
TRACE: L10 line:main.eol | byte='\n' term=["Line 1"] pos=6
EVENT: Text { content: [76, 105, 110, 101, 32, 49, 10], span: 0..7 }
TRACE: L4 document:main EOF | term=["Line 2\n"] pos=14
```

You can see exactly where characters are consumed, when marks and terms are set,
and what events are emitted. This is how you find where you missed consuming a
character or emitting something.

If you think descent itself is behaving unexpectedly, **tell Joseph immediately**.
There's a very fast turnaround for fixing descent bugs - usually fixed before he
can even respond. Don't spend hours working around what might be a simple fix on
the descent side.

## Think Recursive Descent, Not State Machines

**If you find yourself scanning through the generated parser.rs to understand
what's happening, you are missing the entire point.**

descent generates straightforward recursive descent code that does exactly what
the .desc file says. The generated Rust is just a mechanical translation. The
.desc file IS the parser logic.

Think in terms of:
- Consuming the next byte (or two) at a time
- Calling functions recursively
- Setting marks and terms for content capture
- Emitting events on return

NOT in terms of:
- State machines
- Rust parser internals
- Complex control flow

Everything you need to understand is in `~/src/descent/`:
- **README.md** - How descent works
- **TODO.md** - Known issues and planned features
- **CLAUDE.md** - Full DSL documentation

The .desc file should read almost like a formal grammar. Your goal is to make it
more and more readable and "obvious" - so that future agents can understand the
grammar just by reading it.

## Test Fixtures

Test cases live in `udon-core/tests/fixtures/*.yaml`:

```yaml
- id: basic_interpolation
  desc: basic interpolation
  udon: "|p Hello, !{{user.name}}!"
  events: []    # Empty = not yet implemented

- id: simple_element
  desc: Basic element with name only
  udon: "|div\n"
  events:       # Filled in = expected behavior
    - ElementStart
    - [Name, "div"]
    - ElementEnd
```

### Where These Fixtures Came From

These fixtures were **extracted from the old test suite** which had a working
parser for most UDON features. The old parser worked, but was unsustainable and
highly coupled - hence this rewrite.

The fixtures are:
- **A good starting point** for knowing what inputs should work
- **NOT gospel** - they're test cases, not specification
- **Guides for development** - empty events means "implement this"

### The SPEC Files Are Ground Truth, Not Fixtures

If a fixture seems inconsistent with the spec, **the spec wins**.

If you encounter:
- A fixture that doesn't seem correct
- Behavior that isn't defined in any of the three SPEC files
- Ambiguity about what should happen

**Talk to Joseph immediately.** Don't make assumptions. Don't add workarounds.
Don't make "minor grammar decisions" on your own.

Why? Because small assumptions and workarounds get treated as deliberate
decisions by future agents. They see code doing X and assume it's intentional
and important. The drift accelerates. What started as "I'll just handle this
edge case" becomes enshrined as part of the grammar.

Better to pause and ask than to guess wrong.

### CRITICAL: Fixtures Must Match SPEC, Not Parser Output

**DO NOT fill fixture expectations by tracing parser output and copying it.**

This is an anti-pattern that cements bugs as expected behavior. It has happened
multiple times and results in work being reverted. The correct workflow:

1. Read FULL-SPEC.md for the feature being tested
2. Write fixture expectations based on what the SPEC says should happen
3. Run tests - they WILL fail if parser doesn't match spec
4. Fix the PARSER to match the spec
5. Tests pass because parser now conforms to spec

**WRONG:** "Parser outputs X, so fixture expects X" (cements bugs)
**RIGHT:** "Spec says X, fixture expects X, fix parser until it outputs X"

If you're uncertain what the spec requires, ASK JOSEPH. Do not guess.
Do not "just see what the parser does." The spec is ground truth.

### Workflow for Implementing Features

1. Find fixtures with empty events - these need implementation
2. **Read FULL-SPEC.md** - understand what SHOULD happen per spec
3. **Write fixture expectations** - based on spec, not parser output
4. Run tests - expect failures
5. Edit `generator/*.desc` - fix the grammar to match spec
6. Regenerate with tracing - `./regenerate-parser --trace`
7. Iterate until tests pass - parser now conforms to spec

### Running Tests

```bash
cargo test                           # All tests
cargo test test_elements             # Specific fixture
UDON_TEST_COUNT=0 cargo test         # Skip variation tests (faster)
UDON_TEST_SEED=12345 cargo test      # Reproduce specific seed
```

## Your Responsibilities

**Keep PLAN.md updated.** Document what you're working on, decisions made,
questions that came up. Future agents (including future you) need this context.

**Keep README.md current.** Update it as the project evolves.

**Commit as you make progress.** Small, focused commits. Don't let work
accumulate uncommitted.

**Ask when uncertain.** The spec is ground truth. If it's unclear, ask Joseph.
If a fixture seems wrong, ask Joseph. If descent seems buggy, ask Joseph.

**Make the .desc file better.** It should describe the SPEC more and more
clearly. It should teach the grammar to anyone who reads it. Every change
should make it more obvious what UDON does.

## Quick Reference

### Four Core Prefixes

| Prefix | Domain | Example |
|--------|--------|---------|
| `\|` | Structure | `\|div`, `\|[id]`, `\|.class` |
| `:` | Attributes | `:key value` |
| `!` | Dynamics | `!if cond`, `!{{expr}}` |
| `;` | Comments | `; comment` |

### Inline Forms

| Syntax | Description |
|--------|-------------|
| `\|{element ...}` | Embedded element |
| `!{{expr}}` | Interpolation |
| `!{directive ...}` | Inline directive |
| `;{comment}` | Inline comment |

## Related Repositories

- `~/src/descent` - Parser generator (Ruby gem, active development)
- `~/src/udon` - Specification (FULL-SPEC.md is authoritative)
- `~/src/udon-ruby` - Ruby gem (needs FFI update)
