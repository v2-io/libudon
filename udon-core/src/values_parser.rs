//! Generated parser - DO NOT EDIT
//!
//! Generated by descent from values.desc
//!
//! Callback-based recursive descent parser.
//! Call stack = element stack. True recursion handles nesting naturally.

use std::ops::Range;
/// Events emitted by the parser.
#[derive(Debug, Clone, PartialEq)]
pub enum Event<'a> {
    Integer { content: &'a [u8], span: Range<usize> },
    Float { content: &'a [u8], span: Range<usize> },
    Error { code: ParseErrorCode, span: Range<usize> },
}
impl<'a> Event<'a> {
    /// Format event as a single line for test output.
    pub fn format_line(&self) -> String {
        match self {
            Event::Integer { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("Integer {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::Float { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("Float {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::Error { code, span } => {
                format!("Error {:?} @ {}..{}", code, span.start, span.end)
            }
        }
    }
}

/// Error codes for parse errors.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ParseErrorCode {
    UnexpectedEof,
    UnexpectedChar,
}

/// Callback-based parser.
///
/// Uses true recursive descent - the call stack IS the element stack.

pub struct Parser<'a> {
    input: &'a [u8],
    pos: usize,
    mark_pos: usize,
    term_pos: usize,
    line: u32,
    column: u32,
}

#[allow(unused_variables)]
impl<'a> Parser<'a> {
    /// Create a new parser for the given input.
    pub fn new(input: &'a [u8]) -> Self {
        Self {
            input,
            pos: 0,
            mark_pos: 0,
            term_pos: 0,
            line: 1,
            column: 1,
        }
    }

    /// Parse the input, calling the callback for each event.
    ///
    /// The callback receives events in document order.
    /// For backpressure, have the callback send to a bounded channel.
    pub fn parse<F>(mut self, mut on_event: F)
    where
        F: FnMut(Event<'a>),
    {
        self.parse_value(&mut on_event);
    }

    // ========== Helpers ==========
    #[inline(always)]
    fn peek(&self) -> Option<u8> {
        self.input.get(self.pos).copied()
    }

    #[inline(always)]
    fn eof(&self) -> bool {
        self.pos >= self.input.len()
    }

    #[inline(always)]
    fn advance(&mut self) {
        if self.pos < self.input.len() {
            if self.input[self.pos] == b'\n' {
                self.line += 1;
                self.column = 1;
            } else {
                self.column += 1;
            }
            self.pos += 1;
        }
    }

    #[inline(always)]
    fn mark(&mut self) {
        self.mark_pos = self.pos;
        self.term_pos = self.pos; // Reset term position
    }

    /// Set termination point with optional offset (e.g., -1 for one char before current)
    /// Clamps to valid range [0, input.len()] to prevent underflow/overflow.
    #[inline(always)]
    fn set_term(&mut self, offset: i32) {
        let new_pos = self.pos as i64 + offset as i64;
        self.term_pos = new_pos.clamp(0, self.input.len() as i64) as usize;
    }

    #[inline(always)]
    fn term(&self) -> &'a [u8] {
        // Use term_pos if set after mark, otherwise use current pos
        let end = if self.term_pos > self.mark_pos { self.term_pos } else { self.pos };
        &self.input[self.mark_pos..end]
    }

    #[inline(always)]
    fn span(&self) -> Range<usize> {
        self.pos..self.pos
    }

    #[inline(always)]
    fn span_from_mark(&self) -> Range<usize> {
        // Use term_pos if set after mark, otherwise use current pos
        let end = if self.term_pos > self.mark_pos { self.term_pos } else { self.pos };
        self.mark_pos..end
    }

    #[inline(always)]
    fn col(&self) -> i32 {
        self.column as i32
    }

    /// Previous byte (0 at start of input).
    #[inline(always)]
    fn prev(&self) -> u8 {
        if self.pos > 0 {
            self.input[self.pos - 1]
        } else {
            0
        }
    }

    #[inline(always)]
    fn is_letter(b: u8) -> bool {
        b.is_ascii_alphabetic()
    }

    #[inline(always)]
    fn is_label_cont(b: u8) -> bool {
        b.is_ascii_alphanumeric() || b == b'_' || b == b'-'
    }

    // ========== SCAN Methods (SIMD-accelerated via memchr) ==========
    /// Scan forward to find first occurrence of b1, returns matched byte or None for EOF.
    #[inline]
    fn scan_to1(&mut self, b1: u8) -> Option<u8> {
        match memchr::memchr(b1, &self.input[self.pos..]) {
            Some(offset) => {
                // Update line/column for skipped chars
                for &b in &self.input[self.pos..self.pos + offset] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos += offset;
                Some(self.input[self.pos])
            }
            None => {
                // Advance to end
                for &b in &self.input[self.pos..] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos = self.input.len();
                None
            }
        }
    }

    /// Scan forward to find first occurrence of b1 or b2.
    #[inline]
    fn scan_to2(&mut self, b1: u8, b2: u8) -> Option<u8> {
        match memchr::memchr2(b1, b2, &self.input[self.pos..]) {
            Some(offset) => {
                for &b in &self.input[self.pos..self.pos + offset] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos += offset;
                Some(self.input[self.pos])
            }
            None => {
                for &b in &self.input[self.pos..] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos = self.input.len();
                None
            }
        }
    }

    /// Scan forward to find first occurrence of b1, b2, or b3.
    #[inline]
    fn scan_to3(&mut self, b1: u8, b2: u8, b3: u8) -> Option<u8> {
        match memchr::memchr3(b1, b2, b3, &self.input[self.pos..]) {
            Some(offset) => {
                for &b in &self.input[self.pos..self.pos + offset] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos += offset;
                Some(self.input[self.pos])
            }
            None => {
                for &b in &self.input[self.pos..] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos = self.input.len();
                None
            }
        }
    }

    /// Scan forward to find first occurrence of b1, b2, b3, or b4 (chained memchr).
    #[inline]
    fn scan_to4(&mut self, b1: u8, b2: u8, b3: u8, b4: u8) -> Option<u8> {
        let haystack = &self.input[self.pos..];
        let p1 = memchr::memchr3(b1, b2, b3, haystack);
        let p2 = memchr::memchr(b4, haystack);
        let offset = match (p1, p2) {
            (Some(x), Some(y)) => Some(x.min(y)),
            (Some(x), None) | (None, Some(x)) => Some(x),
            (None, None) => None,
        };
        self.apply_scan_offset(offset)
    }

    /// Scan forward to find first occurrence of b1..b5 (chained memchr).
    #[inline]
    fn scan_to5(&mut self, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8) -> Option<u8> {
        let haystack = &self.input[self.pos..];
        let p1 = memchr::memchr3(b1, b2, b3, haystack);
        let p2 = memchr::memchr2(b4, b5, haystack);
        let offset = match (p1, p2) {
            (Some(x), Some(y)) => Some(x.min(y)),
            (Some(x), None) | (None, Some(x)) => Some(x),
            (None, None) => None,
        };
        self.apply_scan_offset(offset)
    }

    /// Scan forward to find first occurrence of b1..b6 (chained memchr).
    #[inline]
    fn scan_to6(&mut self, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8) -> Option<u8> {
        let haystack = &self.input[self.pos..];
        let p1 = memchr::memchr3(b1, b2, b3, haystack);
        let p2 = memchr::memchr3(b4, b5, b6, haystack);
        let offset = match (p1, p2) {
            (Some(x), Some(y)) => Some(x.min(y)),
            (Some(x), None) | (None, Some(x)) => Some(x),
            (None, None) => None,
        };
        self.apply_scan_offset(offset)
    }

    /// Apply scan offset result, updating position and line/column.
    #[inline]
    fn apply_scan_offset(&mut self, offset: Option<usize>) -> Option<u8> {
        match offset {
            Some(off) => {
                for &b in &self.input[self.pos..self.pos + off] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos += off;
                Some(self.input[self.pos])
            }
            None => {
                for &b in &self.input[self.pos..] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos = self.input.len();
                None
            }
        }
    }

    // ========== Generated Parse Functions ==========
    /// Parse value -> Integer
    fn parse_value<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        self.mark();
        #[derive(Clone, Copy)]
        enum State { Main, AfterSign, ZeroPrefix, DecDigits, HexDigits, OctDigits, BinDigits, FloatFrac, FloatExpSign, FloatExp,  }
        let mut state = State::Main;
        loop {
            match state {
                State::Main => {
                    if self.eof() {
                        on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        Some(b'-') => {
                    self.advance();
                    state = State::AfterSign;
                    continue;
                        }
                        Some(b'+') => {
                    self.advance();
                    state = State::AfterSign;
                    continue;
                        }
                        Some(b'0') => {
                    self.advance();
                    state = State::ZeroPrefix;
                    continue;
                        }
                        Some(b'1' | b'2' | b'3' | b'4' | b'5' | b'6' | b'7' | b'8' | b'9') => {
                    state = State::DecDigits;
                    continue;
                        }
                        _ => {
                    self.advance();
                    continue;
                        }
                    }
                }
                State::AfterSign => {
                    if self.eof() {
                        on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        Some(b'0') => {
                    self.advance();
                    state = State::ZeroPrefix;
                    continue;
                        }
                        Some(b'1' | b'2' | b'3' | b'4' | b'5' | b'6' | b'7' | b'8' | b'9') => {
                    state = State::DecDigits;
                    continue;
                        }
                        _ => {
                    self.advance();
                    state = State::Main;
                    continue;
                        }
                    }
                }
                State::ZeroPrefix => {
                    if self.eof() {
                        on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        Some(b'x' | b'X') => {
                    self.advance();
                    state = State::HexDigits;
                    continue;
                        }
                        Some(b'o' | b'O') => {
                    self.advance();
                    state = State::OctDigits;
                    continue;
                        }
                        Some(b'b' | b'B') => {
                    self.advance();
                    state = State::BinDigits;
                    continue;
                        }
                        Some(b'1' | b'2' | b'3' | b'4' | b'5' | b'6' | b'7' | b'8' | b'9') => {
                    state = State::DecDigits;
                    continue;
                        }
                        Some(b'.') => {
                    self.advance();
                    state = State::FloatFrac;
                    continue;
                        }
                        Some(b'e' | b'E') => {
                    self.advance();
                    state = State::FloatExpSign;
                    continue;
                        }
                        Some(b'_') => {
                    self.advance();
                    state = State::DecDigits;
                    continue;
                        }
                        _ => {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                    }
                }
                State::DecDigits => {
                    if self.eof() {
                        on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        Some(b'0' | b'1' | b'2' | b'3' | b'4' | b'5' | b'6' | b'7' | b'8' | b'9' | b'_') => {
                    self.advance();
                    continue;
                        }
                        Some(b'.') => {
                    self.advance();
                    state = State::FloatFrac;
                    continue;
                        }
                        Some(b'e' | b'E') => {
                    self.advance();
                    state = State::FloatExpSign;
                    continue;
                        }
                        _ => {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                    }
                }
                State::HexDigits => {
                    if self.eof() {
                        on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        Some(b'0' | b'1' | b'2' | b'3' | b'4' | b'5' | b'6' | b'7' | b'8' | b'9' | b'a' | b'b' | b'c' | b'd' | b'e' | b'f' | b'A' | b'B' | b'C' | b'D' | b'E' | b'F' | b'_') => {
                    self.advance();
                    continue;
                        }
                        _ => {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                    }
                }
                State::OctDigits => {
                    if self.eof() {
                        on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        Some(b'0' | b'1' | b'2' | b'3' | b'4' | b'5' | b'6' | b'7' | b'_') => {
                    self.advance();
                    continue;
                        }
                        _ => {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                    }
                }
                State::BinDigits => {
                    if self.eof() {
                        on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        Some(b'0' | b'1' | b'_') => {
                    self.advance();
                    continue;
                        }
                        _ => {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                    }
                }
                State::FloatFrac => {
                    if self.eof() {
                        on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        Some(b'0' | b'1' | b'2' | b'3' | b'4' | b'5' | b'6' | b'7' | b'8' | b'9' | b'_') => {
                    self.advance();
                    continue;
                        }
                        Some(b'e' | b'E') => {
                    self.advance();
                    state = State::FloatExpSign;
                    continue;
                        }
                        _ => {
                    on_event(Event::Float { content: self.term(), span: self.span_from_mark() });
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                    }
                }
                State::FloatExpSign => {
                    if self.eof() {
                        on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        Some(b'+' | b'-') => {
                    self.advance();
                    state = State::FloatExp;
                    continue;
                        }
                        Some(b'0' | b'1' | b'2' | b'3' | b'4' | b'5' | b'6' | b'7' | b'8' | b'9') => {
                    state = State::FloatExp;
                    continue;
                        }
                        _ => {
                    on_event(Event::Float { content: self.term(), span: self.span_from_mark() });
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                    }
                }
                State::FloatExp => {
                    if self.eof() {
                        on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        Some(b'0' | b'1' | b'2' | b'3' | b'4' | b'5' | b'6' | b'7' | b'8' | b'9' | b'_') => {
                    self.advance();
                    continue;
                        }
                        _ => {
                    on_event(Event::Float { content: self.term(), span: self.span_from_mark() });
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                    }
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_parse_basic() {
        // Basic smoke test - actual tests depend on parser semantics
        let input = b"";
        let mut events = Vec::new();
        Parser::new(input).parse(|e| events.push(e));
        // Events depend on the specific parser
    }
}
