//! Generated parser - DO NOT EDIT
//!
//! Generated by descent from udon.desc
//!
//! Callback-based recursive descent parser.
//! Call stack = element stack. True recursion handles nesting naturally.

use std::ops::Range;
use phf::phf_map;
/// Events emitted by the parser.
#[derive(Debug, Clone, PartialEq)]
pub enum Event<'a> {
    ElementStart { span: Range<usize> },
    ElementEnd { span: Range<usize> },
    EmbeddedStart { span: Range<usize> },
    EmbeddedEnd { span: Range<usize> },
    DirectiveStart { span: Range<usize> },
    DirectiveEnd { span: Range<usize> },
    ArrayStart { span: Range<usize> },
    ArrayEnd { span: Range<usize> },
    FreeformStart { span: Range<usize> },
    FreeformEnd { span: Range<usize> },
    Name { content: &'a [u8], span: Range<usize> },
    Text { content: &'a [u8], span: Range<usize> },
    Comment { content: &'a [u8], span: Range<usize> },
    Attr { content: &'a [u8], span: Range<usize> },
    StringValue { content: &'a [u8], span: Range<usize> },
    BareValue { content: &'a [u8], span: Range<usize> },
    BoolTrue { content: &'a [u8], span: Range<usize> },
    BoolFalse { content: &'a [u8], span: Range<usize> },
    Nil { content: &'a [u8], span: Range<usize> },
    Interpolation { content: &'a [u8], span: Range<usize> },
    Reference { content: &'a [u8], span: Range<usize> },
    RawContent { content: &'a [u8], span: Range<usize> },
    Raw { content: &'a [u8], span: Range<usize> },
    Integer { content: &'a [u8], span: Range<usize> },
    Float { content: &'a [u8], span: Range<usize> },
    Error { code: ParseErrorCode, span: Range<usize> },
}
impl<'a> Event<'a> {
    /// Format event as a single line for test output.
    pub fn format_line(&self) -> String {
        match self {
            Event::ElementStart { span } => {
                format!("ElementStart @ {}..{}", span.start, span.end)
            }
            Event::ElementEnd { span } => {
                format!("ElementEnd @ {}..{}", span.start, span.end)
            }
            Event::EmbeddedStart { span } => {
                format!("EmbeddedStart @ {}..{}", span.start, span.end)
            }
            Event::EmbeddedEnd { span } => {
                format!("EmbeddedEnd @ {}..{}", span.start, span.end)
            }
            Event::DirectiveStart { span } => {
                format!("DirectiveStart @ {}..{}", span.start, span.end)
            }
            Event::DirectiveEnd { span } => {
                format!("DirectiveEnd @ {}..{}", span.start, span.end)
            }
            Event::ArrayStart { span } => {
                format!("ArrayStart @ {}..{}", span.start, span.end)
            }
            Event::ArrayEnd { span } => {
                format!("ArrayEnd @ {}..{}", span.start, span.end)
            }
            Event::FreeformStart { span } => {
                format!("FreeformStart @ {}..{}", span.start, span.end)
            }
            Event::FreeformEnd { span } => {
                format!("FreeformEnd @ {}..{}", span.start, span.end)
            }
            Event::Name { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("Name {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::Text { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("Text {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::Comment { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("Comment {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::Attr { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("Attr {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::StringValue { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("StringValue {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::BareValue { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("BareValue {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::BoolTrue { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("BoolTrue {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::BoolFalse { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("BoolFalse {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::Nil { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("Nil {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::Interpolation { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("Interpolation {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::Reference { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("Reference {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::RawContent { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("RawContent {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::Raw { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("Raw {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::Integer { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("Integer {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::Float { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("Float {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::Error { code, span } => {
                format!("Error {:?} @ {}..{}", code, span.start, span.end)
            }
        }
    }
}

/// Keyword lookup map for bare_kw.
/// Generated from |keywords[bare_kw] - O(1) perfect hash lookup.
static BARE_KW_KEYWORDS: phf::Map<&'static [u8], u8> = phf_map! {
    b"true" => 0u8,
    b"false" => 1u8,
    b"null" => 2u8,
    b"nil" => 3u8,
};
/// Error codes for parse errors.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ParseErrorCode {
    UnexpectedEof,
    UnexpectedChar,
    Unclosed,
    UnclosedArray,
    UnclosedComment,
    UnclosedText,
    UnclosedDirective,
    NoTabs,
}

/// Callback-based parser.
///
/// Uses true recursive descent - the call stack IS the element stack.

pub struct Parser<'a> {
    input: &'a [u8],
    pos: usize,
    mark_pos: usize,
    term_pos: usize,
    line: u32,
    column: u32,
}

#[allow(unused_variables)]
impl<'a> Parser<'a> {
    /// Create a new parser for the given input.
    pub fn new(input: &'a [u8]) -> Self {
        Self {
            input,
            pos: 0,
            mark_pos: 0,
            term_pos: 0,
            line: 1,
            column: 1,
        }
    }

    /// Parse the input, calling the callback for each event.
    ///
    /// The callback receives events in document order.
    /// For backpressure, have the callback send to a bounded channel.
    pub fn parse<F>(mut self, mut on_event: F)
    where
        F: FnMut(Event<'a>),
    {
        self.parse_document(&mut on_event);
    }

    // ========== Helpers ==========
    #[inline(always)]
    fn peek(&self) -> Option<u8> {
        self.input.get(self.pos).copied()
    }

    #[inline(always)]
    fn eof(&self) -> bool {
        self.pos >= self.input.len()
    }

    #[inline(always)]
    fn advance(&mut self) {
        if self.pos < self.input.len() {
            if self.input[self.pos] == b'\n' {
                self.line += 1;
                self.column = 1;
            } else {
                self.column += 1;
            }
            self.pos += 1;
        }
    }

    #[inline(always)]
    fn mark(&mut self) {
        self.mark_pos = self.pos;
        self.term_pos = self.pos; // Reset term position
    }

    /// Set termination point with optional offset (e.g., -1 for one char before current)
    /// Clamps to valid range [0, input.len()] to prevent underflow/overflow.
    #[inline(always)]
    fn set_term(&mut self, offset: i32) {
        let new_pos = self.pos as i64 + offset as i64;
        self.term_pos = new_pos.clamp(0, self.input.len() as i64) as usize;
    }

    #[inline(always)]
    fn term(&self) -> &'a [u8] {
        // Use term_pos if set after mark, otherwise use current pos
        let end = if self.term_pos > self.mark_pos { self.term_pos } else { self.pos };
        &self.input[self.mark_pos..end]
    }

    #[inline(always)]
    fn span(&self) -> Range<usize> {
        self.pos..self.pos
    }

    #[inline(always)]
    fn span_from_mark(&self) -> Range<usize> {
        // Use term_pos if set after mark, otherwise use current pos
        let end = if self.term_pos > self.mark_pos { self.term_pos } else { self.pos };
        self.mark_pos..end
    }

    #[inline(always)]
    fn col(&self) -> i32 {
        self.column as i32
    }

    /// Previous byte (0 at start of input).
    #[inline(always)]
    fn prev(&self) -> u8 {
        if self.pos > 0 {
            self.input[self.pos - 1]
        } else {
            0
        }
    }

    #[inline(always)]
    fn is_letter(b: u8) -> bool {
        b.is_ascii_alphabetic()
    }

    #[inline(always)]
    fn is_label_cont(b: u8) -> bool {
        b.is_ascii_alphanumeric() || b == b'_' || b == b'-'
    }

    #[inline(always)]
    fn is_digit(b: u8) -> bool {
        b.is_ascii_digit()
    }

    #[inline(always)]
    fn is_hex_digit(b: u8) -> bool {
        b.is_ascii_hexdigit()
    }

    // ========== SCAN Methods (SIMD-accelerated via memchr) ==========
    /// Scan forward to find first occurrence of b1, returns matched byte or None for EOF.
    #[inline]
    fn scan_to1(&mut self, b1: u8) -> Option<u8> {
        match memchr::memchr(b1, &self.input[self.pos..]) {
            Some(offset) => {
                // Update line/column for skipped chars
                for &b in &self.input[self.pos..self.pos + offset] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos += offset;
                Some(self.input[self.pos])
            }
            None => {
                // Advance to end
                for &b in &self.input[self.pos..] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos = self.input.len();
                None
            }
        }
    }

    /// Scan forward to find first occurrence of b1 or b2.
    #[inline]
    fn scan_to2(&mut self, b1: u8, b2: u8) -> Option<u8> {
        match memchr::memchr2(b1, b2, &self.input[self.pos..]) {
            Some(offset) => {
                for &b in &self.input[self.pos..self.pos + offset] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos += offset;
                Some(self.input[self.pos])
            }
            None => {
                for &b in &self.input[self.pos..] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos = self.input.len();
                None
            }
        }
    }

    /// Scan forward to find first occurrence of b1, b2, or b3.
    #[inline]
    fn scan_to3(&mut self, b1: u8, b2: u8, b3: u8) -> Option<u8> {
        match memchr::memchr3(b1, b2, b3, &self.input[self.pos..]) {
            Some(offset) => {
                for &b in &self.input[self.pos..self.pos + offset] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos += offset;
                Some(self.input[self.pos])
            }
            None => {
                for &b in &self.input[self.pos..] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos = self.input.len();
                None
            }
        }
    }

    /// Scan forward to find first occurrence of b1, b2, b3, or b4 (chained memchr).
    #[inline]
    fn scan_to4(&mut self, b1: u8, b2: u8, b3: u8, b4: u8) -> Option<u8> {
        let haystack = &self.input[self.pos..];
        let p1 = memchr::memchr3(b1, b2, b3, haystack);
        let p2 = memchr::memchr(b4, haystack);
        let offset = match (p1, p2) {
            (Some(x), Some(y)) => Some(x.min(y)),
            (Some(x), None) | (None, Some(x)) => Some(x),
            (None, None) => None,
        };
        self.apply_scan_offset(offset)
    }

    /// Scan forward to find first occurrence of b1..b5 (chained memchr).
    #[inline]
    fn scan_to5(&mut self, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8) -> Option<u8> {
        let haystack = &self.input[self.pos..];
        let p1 = memchr::memchr3(b1, b2, b3, haystack);
        let p2 = memchr::memchr2(b4, b5, haystack);
        let offset = match (p1, p2) {
            (Some(x), Some(y)) => Some(x.min(y)),
            (Some(x), None) | (None, Some(x)) => Some(x),
            (None, None) => None,
        };
        self.apply_scan_offset(offset)
    }

    /// Scan forward to find first occurrence of b1..b6 (chained memchr).
    #[inline]
    fn scan_to6(&mut self, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8) -> Option<u8> {
        let haystack = &self.input[self.pos..];
        let p1 = memchr::memchr3(b1, b2, b3, haystack);
        let p2 = memchr::memchr3(b4, b5, b6, haystack);
        let offset = match (p1, p2) {
            (Some(x), Some(y)) => Some(x.min(y)),
            (Some(x), None) | (None, Some(x)) => Some(x),
            (None, None) => None,
        };
        self.apply_scan_offset(offset)
    }

    /// Apply scan offset result, updating position and line/column.
    #[inline]
    fn apply_scan_offset(&mut self, offset: Option<usize>) -> Option<u8> {
        match offset {
            Some(off) => {
                for &b in &self.input[self.pos..self.pos + off] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos += off;
                Some(self.input[self.pos])
            }
            None => {
                for &b in &self.input[self.pos..] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos = self.input.len();
                None
            }
        }
    }

    // ========== Keyword Lookup: bare_kw ==========
    /// Look up accumulated content in bare_kw keywords.
    /// Returns true if a keyword matched (event emitted), false otherwise.
    fn lookup_bare_kw<F>(&mut self, on_event: &mut F) -> bool
    where
        F: FnMut(Event<'a>),
    {
        let content = self.term();
        if let Some(&id) = BARE_KW_KEYWORDS.get(content) {
            let span = self.span_from_mark();
            match id {
                0 => on_event(Event::BoolTrue { content, span }),
                1 => on_event(Event::BoolFalse { content, span }),
                2 => on_event(Event::Nil { content, span }),
                3 => on_event(Event::Nil { content, span }),
                _ => unreachable!("keyword map contains only valid ids"),
            }
            true
        } else {
            false
        }
    }

    /// Look up and emit keyword, or call fallback function.
    fn lookup_bare_kw_or_fallback<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        if !self.lookup_bare_kw(on_event) {
            self.parse_emit_bare_value(on_event);
        }
    }

    // ========== Generated Parse Functions ==========
    /// Parse document
    fn parse_document<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        let mut col: i32 = 0;
        #[derive(Clone, Copy)]
        enum State { Line, Dispatch, CheckPipe,  }
        let mut state = State::Line;
        loop {
            match state {
                State::Line => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b'\n') => {
                    self.advance();
                    continue;
                        }
                        Some(b' ') => {
                    col = self.parse_count_indent(on_event);
                    state = State::Dispatch;
                    continue;
                        }
                        Some(b'\t') => {
                    on_event(Event::Error { code: ParseErrorCode::NoTabs, span: self.span() });
                    return;
                    self.scan_to1(b'\n');
                    state = State::Line;
                    continue;
                        }
                        _ => {
                    col = 0;
                    state = State::Dispatch;
                    continue;
                        }
                    }
                }
                State::Dispatch => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b'|') => {
                    self.advance();
                    state = State::CheckPipe;
                    continue;
                        }
                        Some(b':') => {
                    self.advance();
                    self.parse_block_attr(on_event);
                    state = State::Line;
                    continue;
                        }
                        Some(b'!') => {
                    self.advance();
                    self.parse_block_directive(col, on_event);
                    state = State::Line;
                    continue;
                        }
                        Some(b';') => {
                    self.advance();
                    self.parse_line_comment(on_event);
                    state = State::Line;
                    continue;
                        }
                        Some(b'\'') => {
                    self.advance();
                    self.parse_prose(col, -1, on_event);
                    state = State::Line;
                    continue;
                        }
                        _ => {
                    self.parse_prose(col, -1, on_event);
                    state = State::Line;
                    continue;
                        }
                    }
                }
                State::CheckPipe => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b) if Self::is_letter(b) || b == b'\'' || b == b'[' || b == b'.' || b == b'?' || b == b'!' || b == b'*' || b == b'+' => {
                    self.parse_element(col, -1, on_event);
                    state = State::Line;
                    continue;
                        }
                        Some(b'{') => {
                    self.advance();
                    self.parse_embedded(on_event);
                    state = State::Line;
                    continue;
                        }
                        _ => {
                    self.parse_prose_pipe(col, -1, on_event);
                    state = State::Line;
                    continue;
                        }
                    }
                }
            }
        }
    }

    /// Parse count_indent -> INT
    fn parse_count_indent<F>(&mut self, on_event: &mut F) -> i32
    where
        F: FnMut(Event<'a>),
    {
        let mut result: i32 = 0;
        loop {
            if self.eof() {
                return 0;
            }
            match self.peek() {
                Some(b' ') => {
                    self.advance();
                    result += 1;
                    continue;
                }
                _ => {
                    return result;
                }
            }
        }
    }

    /// Parse parse_element_identity
    fn parse_parse_element_identity<F>(&mut self, close: u8, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        #[derive(Clone, Copy)]
        enum State { Identity, QuotedName, PostName, Bracket, BracketClose, PostBracket, Class, PostClass,  }
        let mut state = State::Identity;
        loop {
            match state {
                State::Identity => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b) if b == close => {
                    return;
                        }
                        Some(b) if Self::is_letter(b) => {
                    self.parse_name(on_event);
                    state = State::PostName;
                    continue;
                        }
                        Some(b'\'') => {
                    self.advance();
                    state = State::QuotedName;
                    continue;
                        }
                        Some(b'[') => {
                    self.advance();
                    state = State::Bracket;
                    continue;
                        }
                        Some(b'.') => {
                    state = State::Class;
                    continue;
                        }
                        Some(b'?' | b'!' | b'*' | b'+') => {
                    self.parse_suffix(on_event);
                    return;
                        }
                        _ => {
                    return;
                        }
                    }
                }
                State::QuotedName => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b'\'') => {
                    self.advance();
                    state = State::PostName;
                    continue;
                        }
                        _ => {
                    self.parse_quoted_name(on_event);
                    state = State::PostName;
                    continue;
                        }
                    }
                }
                State::PostName => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b) if b == close => {
                    return;
                        }
                        Some(b'[') => {
                    self.advance();
                    state = State::Bracket;
                    continue;
                        }
                        Some(b'.') => {
                    state = State::Class;
                    continue;
                        }
                        Some(b'?' | b'!' | b'*' | b'+') => {
                    self.parse_suffix(on_event);
                    return;
                        }
                        _ => {
                    return;
                        }
                    }
                }
                State::Bracket => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b']') => {
                    self.advance();
                    state = State::PostBracket;
                    continue;
                        }
                        _ => {
                    on_event(Event::Attr { content: b"id", span: self.span() });
                    self.parse_value_sameline(on_event);
                    state = State::BracketClose;
                    continue;
                        }
                    }
                }
                State::BracketClose => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b']') => {
                    self.advance();
                    state = State::PostBracket;
                    continue;
                        }
                        _ => {
                    return;
                        }
                    }
                }
                State::PostBracket => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b) if b == close => {
                    return;
                        }
                        Some(b'.') => {
                    state = State::Class;
                    continue;
                        }
                        Some(b'?' | b'!' | b'*' | b'+') => {
                    self.parse_suffix(on_event);
                    return;
                        }
                        _ => {
                    return;
                        }
                    }
                }
                State::Class => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b'.') => {
                    self.advance();
                    continue;
                        }
                        Some(b) if Self::is_letter(b) => {
                    on_event(Event::Attr { content: b"class", span: self.span() });
                    self.parse_class_name(on_event);
                    state = State::PostClass;
                    continue;
                        }
                        Some(b'\'') => {
                    on_event(Event::Attr { content: b"class", span: self.span() });
                    self.advance();
                    self.parse_quoted_class(on_event);
                    state = State::PostClass;
                    continue;
                        }
                        _ => {
                    return;
                        }
                    }
                }
                State::PostClass => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b) if b == close => {
                    return;
                        }
                        Some(b'.') => {
                    state = State::Class;
                    continue;
                        }
                        Some(b'?' | b'!' | b'*' | b'+') => {
                    self.parse_suffix(on_event);
                    return;
                        }
                        _ => {
                    return;
                        }
                    }
                }
            }
        }
    }

    /// Parse element -> Element
    fn parse_element<F>(&mut self, elem_col: i32, parent_col: i32, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        let start_span = self.span();
        on_event(Event::ElementStart { span: start_span.clone() });
        let mut col: i32 = 0;
        #[derive(Clone, Copy)]
        enum State { Identity, PostIdentity, PreContent, CheckSamelinePipe, CheckSamelineSemi, CheckSamelineBang, PostChild, Children, CheckChild, ChildDispatch, ChildPipe, AfterChild,  }
        let mut state = State::Identity;
        loop {
            match state {
                State::Identity => {
                    if self.eof() {
                        on_event(Event::ElementEnd { span: self.span() });
                        return;
                    }
                    match self.peek() {
                        _ => {
                    self.parse_parse_element_identity(0, on_event);
                    state = State::PostIdentity;
                    continue;
                        }
                    }
                }
                State::PostIdentity => {
                    if self.eof() {
                        on_event(Event::ElementEnd { span: self.span() });
                        return;
                    }
                    match self.peek() {
                        Some(b'\n') => {
                    self.advance();
                    state = State::Children;
                    continue;
                        }
                        Some(b' ' | b'\t') => {
                    self.advance();
                    state = State::PreContent;
                    continue;
                        }
                        _ => {
                    self.parse_sameline_text(elem_col, 0, on_event);
                    state = State::Children;
                    continue;
                        }
                    }
                }
                State::PreContent => {
                    if self.eof() {
                        on_event(Event::ElementEnd { span: self.span() });
                        return;
                    }
                    match self.peek() {
                        Some(b'\n') => {
                    self.advance();
                    state = State::Children;
                    continue;
                        }
                        Some(b' ' | b'\t') => {
                    self.advance();
                    continue;
                        }
                        Some(b':') => {
                    self.advance();
                    self.parse_sameline_attr(on_event);
                    continue;
                        }
                        Some(b'|') => {
                    self.advance();
                    state = State::CheckSamelinePipe;
                    continue;
                        }
                        Some(b';') => {
                    self.advance();
                    state = State::CheckSamelineSemi;
                    continue;
                        }
                        Some(b'!') => {
                    self.advance();
                    state = State::CheckSamelineBang;
                    continue;
                        }
                        _ => {
                    self.parse_sameline_text(elem_col, 0, on_event);
                    state = State::Children;
                    continue;
                        }
                    }
                }
                State::CheckSamelinePipe => {
                    if self.eof() {
                        on_event(Event::ElementEnd { span: self.span() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.advance();
                    self.parse_embedded(on_event);
                    state = State::PostChild;
                    continue;
                        }
                        Some(b) if Self::is_letter(b) || b == b'\'' || b == b'[' || b == b'.' || b == b'?' || b == b'!' || b == b'*' || b == b'+' => {
                    self.parse_element(self.col() - 1, elem_col, on_event);
                    state = State::PostChild;
                    continue;
                        }
                        _ => {
                    self.parse_sameline_text(elem_col, b'|', on_event);
                    state = State::Children;
                    continue;
                        }
                    }
                }
                State::CheckSamelineSemi => {
                    if self.eof() {
                        on_event(Event::ElementEnd { span: self.span() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.advance();
                    self.parse_brace_comment(on_event);
                    state = State::PreContent;
                    continue;
                        }
                        _ => {
                    self.parse_line_comment_content(on_event);
                    state = State::Children;
                    continue;
                        }
                    }
                }
                State::CheckSamelineBang => {
                    if self.eof() {
                        on_event(Event::ElementEnd { span: self.span() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.advance();
                    self.parse_inline_directive(on_event);
                    state = State::PreContent;
                    continue;
                        }
                        _ => {
                    self.parse_sameline_text(elem_col, b'!', on_event);
                    state = State::Children;
                    continue;
                        }
                    }
                }
                State::PostChild => {
                    if self.eof() {
                        on_event(Event::ElementEnd { span: self.span() });
                        return;
                    }
                    match self.peek() {
                        Some(b'\n') => {
                    self.advance();
                    state = State::Children;
                    continue;
                        }
                        Some(b' ' | b'\t') => {
                    self.advance();
                    continue;
                        }
                        Some(b'|') => {
                    self.advance();
                    state = State::CheckSamelinePipe;
                    continue;
                        }
                        _ => {
                    self.parse_sameline_text(elem_col, 0, on_event);
                    state = State::Children;
                    continue;
                        }
                    }
                }
                State::Children => {
                    if self.eof() {
                        on_event(Event::ElementEnd { span: self.span() });
                        return;
                    }
                    match self.peek() {
                        Some(b'\n') => {
                    self.advance();
                    continue;
                        }
                        Some(b' ') => {
                    col = self.parse_count_indent(on_event);
                    state = State::CheckChild;
                    continue;
                        }
                        Some(b'\t') => {
                    on_event(Event::Error { code: ParseErrorCode::NoTabs, span: self.span() });
                    return;
                    self.scan_to1(b'\n');
                    continue;
                        }
                        _ => {
                    col = self.col() - 1;
                    state = State::CheckChild;
                    continue;
                        }
                    }
                }
                State::CheckChild => {
                    if self.eof() {
                        on_event(Event::ElementEnd { span: self.span() });
                        return;
                    }
                    match self.peek() {
                        _ if col <= elem_col => {
                    on_event(Event::ElementEnd { span: self.span() });
                    return;
                        }
                        _ => {
                    state = State::ChildDispatch;
                    continue;
                        }
                    }
                }
                State::ChildDispatch => {
                    if self.eof() {
                        on_event(Event::ElementEnd { span: self.span() });
                        return;
                    }
                    match self.peek() {
                        Some(b'|') => {
                    self.advance();
                    state = State::ChildPipe;
                    continue;
                        }
                        Some(b':') => {
                    self.advance();
                    self.parse_block_attr(on_event);
                    state = State::Children;
                    continue;
                        }
                        Some(b'!') => {
                    self.advance();
                    self.parse_block_directive(col, on_event);
                    state = State::Children;
                    continue;
                        }
                        Some(b';') => {
                    self.advance();
                    self.parse_line_comment(on_event);
                    state = State::Children;
                    continue;
                        }
                        Some(b'\'') => {
                    self.advance();
                    self.parse_prose(col, elem_col, on_event);
                    state = State::Children;
                    continue;
                        }
                        _ => {
                    self.parse_prose(col, elem_col, on_event);
                    state = State::Children;
                    continue;
                        }
                    }
                }
                State::ChildPipe => {
                    if self.eof() {
                        on_event(Event::ElementEnd { span: self.span() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.advance();
                    self.parse_embedded(on_event);
                    state = State::AfterChild;
                    continue;
                        }
                        Some(b) if Self::is_letter(b) || b == b'\'' || b == b'[' || b == b'.' || b == b'?' || b == b'!' || b == b'*' || b == b'+' => {
                    self.parse_element(col, elem_col, on_event);
                    state = State::AfterChild;
                    continue;
                        }
                        _ => {
                    self.parse_prose_pipe(col, elem_col, on_event);
                    state = State::Children;
                    continue;
                        }
                    }
                }
                State::AfterChild => {
                    if self.eof() {
                        on_event(Event::ElementEnd { span: self.span() });
                        return;
                    }
                    match self.peek() {
                        _ => {
                    state = State::Children;
                    continue;
                        }
                    }
                }
            }
        }
    }

    /// Parse name -> Name
    fn parse_name<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        self.mark();
        loop {
            if self.eof() {
                on_event(Event::Name { content: self.term(), span: self.span_from_mark() });
                return;
            }
            match self.peek() {
                Some(b) if Self::is_label_cont(b) => {
                    self.advance();
                    continue;
                }
                _ => {
                    self.set_term(0);
                    on_event(Event::Name { content: self.term(), span: self.span_from_mark() });
                    return;
                }
            }
        }
    }

    /// Parse skip_single_quoted
    fn parse_skip_single_quoted<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        loop {
            match self.scan_to2(b'\'', b'\\') {
                Some(b'\'') => {
                    self.advance();
                    return;
                }
                Some(b'\\') => {
                    self.advance();
                    self.advance();
                    continue;
                }
                None => {
                    on_event(Event::Error { code: ParseErrorCode::Unclosed, span: self.span() });
                    return;
                }
                _ => unreachable!("scan_to only returns target chars"),
            }
        }
    }

    /// Parse quoted_name -> Name
    fn parse_quoted_name<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        self.mark();
        loop {
            if self.eof() {
                on_event(Event::Name { content: self.term(), span: self.span_from_mark() });
                return;
            }
            match self.peek() {
                _ => {
                    self.parse_skip_single_quoted(on_event);
                    self.set_term(-1);
                    on_event(Event::Name { content: self.term(), span: self.span_from_mark() });
                    return;
                }
            }
        }
    }

    /// Parse class_name -> BareValue
    fn parse_class_name<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        self.mark();
        loop {
            if self.eof() {
                on_event(Event::BareValue { content: self.term(), span: self.span_from_mark() });
                return;
            }
            match self.peek() {
                Some(b) if Self::is_label_cont(b) => {
                    self.advance();
                    continue;
                }
                _ => {
                    self.set_term(0);
                    on_event(Event::BareValue { content: self.term(), span: self.span_from_mark() });
                    return;
                }
            }
        }
    }

    /// Parse quoted_class -> BareValue
    fn parse_quoted_class<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        self.mark();
        loop {
            if self.eof() {
                on_event(Event::BareValue { content: self.term(), span: self.span_from_mark() });
                return;
            }
            match self.peek() {
                _ => {
                    self.parse_skip_single_quoted(on_event);
                    self.set_term(-1);
                    on_event(Event::BareValue { content: self.term(), span: self.span_from_mark() });
                    return;
                }
            }
        }
    }

    /// Parse suffix
    fn parse_suffix<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        loop {
            if self.eof() {
                return;
            }
            match self.peek() {
                Some(b'?') => {
                    on_event(Event::Attr { content: b"?", span: self.span() });
                    on_event(Event::BoolTrue { content: b"", span: self.span() });
                    self.advance();
                    return;
                }
                Some(b'!') => {
                    on_event(Event::Attr { content: b"!", span: self.span() });
                    on_event(Event::BoolTrue { content: b"", span: self.span() });
                    self.advance();
                    return;
                }
                Some(b'*') => {
                    on_event(Event::Attr { content: b"*", span: self.span() });
                    on_event(Event::BoolTrue { content: b"", span: self.span() });
                    self.advance();
                    return;
                }
                Some(b'+') => {
                    on_event(Event::Attr { content: b"+", span: self.span() });
                    on_event(Event::BoolTrue { content: b"", span: self.span() });
                    self.advance();
                    return;
                }
                _ => {
                    return;
                }
            }
        }
    }

    /// Parse block_attr
    fn parse_block_attr<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        #[derive(Clone, Copy)]
        enum State { Key, ValueStart,  }
        let mut state = State::Key;
        loop {
            match state {
                State::Key => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b) if Self::is_letter(b) => {
                    self.parse_attr_key(on_event);
                    state = State::ValueStart;
                    continue;
                        }
                        Some(b'\'') => {
                    self.advance();
                    self.parse_attr_key_quoted(on_event);
                    state = State::ValueStart;
                    continue;
                        }
                        _ => {
                            return;
                        }
                    }
                }
                State::ValueStart => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b' ' | b'\t') => {
                    self.advance();
                    continue;
                        }
                        Some(b'\n') => {
                    on_event(Event::BoolTrue { content: b"", span: self.span() });
                    return;
                        }
                        _ => {
                    self.parse_value_block(on_event);
                    return;
                        }
                    }
                }
            }
        }
    }

    /// Parse sameline_attr
    fn parse_sameline_attr<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        #[derive(Clone, Copy)]
        enum State { Key, ValueStart,  }
        let mut state = State::Key;
        loop {
            match state {
                State::Key => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b) if Self::is_letter(b) => {
                    self.parse_attr_key(on_event);
                    state = State::ValueStart;
                    continue;
                        }
                        Some(b'\'') => {
                    self.advance();
                    self.parse_attr_key_quoted(on_event);
                    state = State::ValueStart;
                    continue;
                        }
                        _ => {
                            return;
                        }
                    }
                }
                State::ValueStart => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b' ' | b'\t') => {
                    self.advance();
                    continue;
                        }
                        Some(b'\n' | b':' | b'|') => {
                    on_event(Event::BoolTrue { content: b"", span: self.span() });
                    return;
                        }
                        _ => {
                    self.parse_value_sameline(on_event);
                    return;
                        }
                    }
                }
            }
        }
    }

    /// Parse sameline_attr_embedded
    fn parse_sameline_attr_embedded<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        #[derive(Clone, Copy)]
        enum State { Key, ValueStart,  }
        let mut state = State::Key;
        loop {
            match state {
                State::Key => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b) if Self::is_letter(b) => {
                    self.parse_attr_key(on_event);
                    state = State::ValueStart;
                    continue;
                        }
                        Some(b'\'') => {
                    self.advance();
                    self.parse_attr_key_quoted(on_event);
                    state = State::ValueStart;
                    continue;
                        }
                        _ => {
                            return;
                        }
                    }
                }
                State::ValueStart => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b' ' | b'\t') => {
                    self.advance();
                    continue;
                        }
                        Some(b'\n' | b':' | b'|' | b'}') => {
                    on_event(Event::BoolTrue { content: b"", span: self.span() });
                    return;
                        }
                        _ => {
                    self.parse_value_embedded(on_event);
                    return;
                        }
                    }
                }
            }
        }
    }

    /// Parse attr_key -> Attr
    fn parse_attr_key<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        self.mark();
        loop {
            if self.eof() {
                on_event(Event::Attr { content: self.term(), span: self.span_from_mark() });
                return;
            }
            match self.peek() {
                Some(b) if Self::is_label_cont(b) => {
                    self.advance();
                    continue;
                }
                _ => {
                    self.set_term(0);
                    on_event(Event::Attr { content: self.term(), span: self.span_from_mark() });
                    return;
                }
            }
        }
    }

    /// Parse attr_key_quoted -> Attr
    fn parse_attr_key_quoted<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        self.mark();
        loop {
            if self.eof() {
                on_event(Event::Attr { content: self.term(), span: self.span_from_mark() });
                return;
            }
            match self.peek() {
                _ => {
                    self.parse_skip_single_quoted(on_event);
                    self.set_term(-1);
                    on_event(Event::Attr { content: self.term(), span: self.span_from_mark() });
                    return;
                }
            }
        }
    }

    /// Parse value_block
    fn parse_value_block<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        loop {
            if self.eof() {
                return;
            }
            match self.peek() {
                Some(b'"') => {
                    self.advance();
                    self.parse_quoted_string(b'"', on_event);
                    return;
                }
                Some(b'\'') => {
                    self.advance();
                    self.parse_quoted_string(b'\'', on_event);
                    return;
                }
                Some(b'[') => {
                    self.parse_array_block(on_event);
                    return;
                }
                _ => {
                    self.mark();
                    self.parse_typed_value(0, 0, on_event);
                    return;
                }
            }
        }
    }

    /// Parse value_sameline
    fn parse_value_sameline<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        loop {
            if self.eof() {
                return;
            }
            match self.peek() {
                Some(b'"') => {
                    self.advance();
                    self.parse_quoted_string(b'"', on_event);
                    return;
                }
                Some(b'\'') => {
                    self.advance();
                    self.parse_quoted_string(b'\'', on_event);
                    return;
                }
                Some(b'[') => {
                    self.parse_array_sameline(on_event);
                    return;
                }
                _ => {
                    self.mark();
                    self.parse_typed_value(1, 0, on_event);
                    return;
                }
            }
        }
    }

    /// Parse value_embedded
    fn parse_value_embedded<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        loop {
            if self.eof() {
                return;
            }
            match self.peek() {
                Some(b'"') => {
                    self.advance();
                    self.parse_quoted_string(b'"', on_event);
                    return;
                }
                Some(b'\'') => {
                    self.advance();
                    self.parse_quoted_string(b'\'', on_event);
                    return;
                }
                Some(b'[') => {
                    self.parse_array_embedded(on_event);
                    return;
                }
                _ => {
                    self.mark();
                    self.parse_typed_value(1, b'}', on_event);
                    return;
                }
            }
        }
    }

    /// Parse quoted_string -> StringValue
    fn parse_quoted_string<F>(&mut self, quote: u8, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        self.mark();
        loop {
            match self.scan_to1(b'\\') {
                Some(b) if b == quote => {
                    self.set_term(0);
                    self.advance();
                    on_event(Event::StringValue { content: self.term(), span: self.span_from_mark() });
                    return;
                }
                Some(b'\\') => {
                    self.advance();
                    self.advance();
                    continue;
                }
                None => {
                    on_event(Event::StringValue { content: self.term(), span: self.span_from_mark() });
                    return;
                }
                _ => unreachable!("scan_to only returns target chars"),
            }
        }
    }

    /// Parse array_block -> Array
    fn parse_array_block<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        let start_span = self.span();
        on_event(Event::ArrayStart { span: start_span.clone() });
        loop {
            if self.eof() {
                on_event(Event::Error { code: ParseErrorCode::UnclosedArray, span: self.span() });
                return;
            }
            match self.peek() {
                Some(b']') => {
                    self.advance();
                    on_event(Event::ArrayEnd { span: self.span() });
                    return;
                }
                Some(b' ' | b'\t' | b'\n') => {
                    self.advance();
                    continue;
                }
                _ => {
                    self.mark();
                    self.parse_typed_value(1, b']', on_event);
                    continue;
                }
            }
        }
    }

    /// Parse array_sameline -> Array
    fn parse_array_sameline<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        let start_span = self.span();
        on_event(Event::ArrayStart { span: start_span.clone() });
        loop {
            if self.eof() {
                on_event(Event::Error { code: ParseErrorCode::UnclosedArray, span: self.span() });
                return;
            }
            match self.peek() {
                Some(b']') => {
                    self.advance();
                    on_event(Event::ArrayEnd { span: self.span() });
                    return;
                }
                Some(b' ' | b'\t' | b'\n') => {
                    self.advance();
                    continue;
                }
                _ => {
                    self.mark();
                    self.parse_typed_value(1, b']', on_event);
                    continue;
                }
            }
        }
    }

    /// Parse array_embedded -> Array
    fn parse_array_embedded<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        let start_span = self.span();
        on_event(Event::ArrayStart { span: start_span.clone() });
        loop {
            if self.eof() {
                on_event(Event::Error { code: ParseErrorCode::UnclosedArray, span: self.span() });
                return;
            }
            match self.peek() {
                Some(b']') => {
                    self.advance();
                    on_event(Event::ArrayEnd { span: self.span() });
                    return;
                }
                Some(b' ' | b'\t' | b'\n') => {
                    self.advance();
                    continue;
                }
                _ => {
                    self.mark();
                    self.parse_typed_value(1, b']', on_event);
                    continue;
                }
            }
        }
    }

    /// Parse prose
    fn parse_prose<F>(&mut self, line_col: i32, parent_col: i32, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        loop {
            if self.eof() {
                return;
            }
            match self.peek() {
                _ => {
                    self.parse_text(line_col, parent_col, 0, on_event);
                    return;
                }
            }
        }
    }

    /// Parse prose_pipe
    fn parse_prose_pipe<F>(&mut self, line_col: i32, parent_col: i32, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        loop {
            if self.eof() {
                return;
            }
            match self.peek() {
                _ => {
                    self.parse_text(line_col, parent_col, b'|', on_event);
                    return;
                }
            }
        }
    }

    /// Parse text -> Text
    fn parse_text<F>(&mut self, line_col: i32, parent_col: i32, prepend: u8, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        self.mark();
        #[derive(Clone, Copy)]
        enum State { Entry, Main, CheckPipe, CheckSemi, CheckBang,  }
        let mut state = State::Entry;
        loop {
            match state {
                State::Entry => {
                    if self.eof() {
                        on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        _ => {
                    if prepend != 0 {
                        // WARNING: No call sites found for PREPEND(:prepend) - cannot determine valid values
                        unreachable!("PREPEND(:prepend) has no traced call sites");
                    }
                    state = State::Main;
                    continue;
                        }
                    }
                }
                State::Main => {
                    match self.scan_to4(b'\n', b'|', b';', b'!') {
                        Some(b'\n') => {
                    self.set_term(0);
                    on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        Some(b'|') => {
                    self.set_term(0);
                    self.advance();
                    state = State::CheckPipe;
                    continue;
                        }
                        Some(b';') => {
                    self.set_term(0);
                    self.advance();
                    state = State::CheckSemi;
                    continue;
                        }
                        Some(b'!') => {
                    self.set_term(0);
                    self.advance();
                    state = State::CheckBang;
                    continue;
                        }
                        None => {
                            on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                            return;
                        }
                        _ => unreachable!("scan_to only returns target chars"),
                    }
                }
                State::CheckPipe => {
                    if self.eof() {
                        on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.advance();
                    self.parse_embedded(on_event);
                    self.mark();
                    state = State::Main;
                    continue;
                        }
                        _ => {
                    self.mark();
                    // Unknown command: raw
                    // Unknown command: raw
                    state = State::Main;
                    continue;
                        }
                    }
                }
                State::CheckSemi => {
                    if self.eof() {
                        on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.advance();
                    self.parse_brace_comment(on_event);
                    self.mark();
                    state = State::Main;
                    continue;
                        }
                        _ => {
                    self.parse_line_comment_content(on_event);
                    on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                    }
                }
                State::CheckBang => {
                    if self.eof() {
                        on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.advance();
                    self.parse_inline_directive(on_event);
                    self.mark();
                    state = State::Main;
                    continue;
                        }
                        _ => {
                    self.mark();
                    on_event(Event::Text { content: b"!", span: self.span() });
                    state = State::Main;
                    continue;
                        }
                    }
                }
            }
        }
    }

    /// Parse sameline_text -> Text
    fn parse_sameline_text<F>(&mut self, elem_col: i32, prepend: u8, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        self.mark();
        #[derive(Clone, Copy)]
        enum State { Entry, Main, CheckPipe, CheckSemi, CheckBang,  }
        let mut state = State::Entry;
        loop {
            match state {
                State::Entry => {
                    if self.eof() {
                        on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        _ => {
                    if prepend != 0 {
                        // WARNING: No call sites found for PREPEND(:prepend) - cannot determine valid values
                        unreachable!("PREPEND(:prepend) has no traced call sites");
                    }
                    state = State::Main;
                    continue;
                        }
                    }
                }
                State::Main => {
                    match self.scan_to4(b'\n', b'|', b';', b'!') {
                        Some(b'\n') => {
                    self.set_term(0);
                    on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        Some(b'|') => {
                    self.set_term(0);
                    self.advance();
                    state = State::CheckPipe;
                    continue;
                        }
                        Some(b';') => {
                    self.set_term(0);
                    self.advance();
                    state = State::CheckSemi;
                    continue;
                        }
                        Some(b'!') => {
                    self.set_term(0);
                    self.advance();
                    state = State::CheckBang;
                    continue;
                        }
                        None => {
                            on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                            return;
                        }
                        _ => unreachable!("scan_to only returns target chars"),
                    }
                }
                State::CheckPipe => {
                    if self.eof() {
                        on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.advance();
                    self.parse_embedded(on_event);
                    self.mark();
                    state = State::Main;
                    continue;
                        }
                        Some(b) if Self::is_letter(b) || b == b'\'' || b == b'[' || b == b'.' || b == b'?' || b == b'!' || b == b'*' || b == b'+' => {
                    self.parse_element(self.col() - 1, elem_col, on_event);
                    self.mark();
                    state = State::Main;
                    continue;
                        }
                        _ => {
                    self.mark();
                    // Unknown command: raw
                    // Unknown command: raw
                    state = State::Main;
                    continue;
                        }
                    }
                }
                State::CheckSemi => {
                    if self.eof() {
                        on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.advance();
                    self.parse_brace_comment(on_event);
                    self.mark();
                    state = State::Main;
                    continue;
                        }
                        _ => {
                    self.set_term(0);
                    self.parse_line_comment_content(on_event);
                    on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                    }
                }
                State::CheckBang => {
                    if self.eof() {
                        on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.advance();
                    self.parse_inline_directive(on_event);
                    self.mark();
                    state = State::Main;
                    continue;
                        }
                        _ => {
                    self.mark();
                    on_event(Event::Text { content: b"!", span: self.span() });
                    state = State::Main;
                    continue;
                        }
                    }
                }
            }
        }
    }

    /// Parse line_comment
    fn parse_line_comment<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        loop {
            if self.eof() {
                return;
            }
            match self.peek() {
                Some(b'{') => {
                    self.advance();
                    self.parse_brace_comment(on_event);
                    return;
                }
                _ => {
                    self.parse_line_comment_content(on_event);
                    return;
                }
            }
        }
    }

    /// Parse line_comment_content -> Comment
    fn parse_line_comment_content<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        self.mark();
        loop {
            match self.scan_to1(b'\n') {
                Some(b'\n') => {
                    self.set_term(0);
                    on_event(Event::Comment { content: self.term(), span: self.span_from_mark() });
                    return;
                }
                None => {
                    on_event(Event::Comment { content: self.term(), span: self.span_from_mark() });
                    on_event(Event::Error { code: ParseErrorCode::UnclosedComment, span: self.span() });
                    return;
                }
                _ => unreachable!("scan_to only returns target chars"),
            }
        }
    }

    /// Parse skip_brace_balanced
    fn parse_skip_brace_balanced<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        let mut depth: i32 = 0;
        #[derive(Clone, Copy)]
        enum State { Main, Check,  }
        let mut state = State::Main;
        loop {
            match state {
                State::Main => {
                    match self.scan_to2(b'{', b'}') {
                        Some(b'{') => {
                    self.advance();
                    depth += 1;
                    continue;
                        }
                        Some(b'}') => {
                    self.advance();
                    depth -= 1;
                    state = State::Check;
                    continue;
                        }
                        None => {
                            return;
                        }
                        _ => unreachable!("scan_to only returns target chars"),
                    }
                }
                State::Check => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        _ if depth == 0 => {
                    return;
                        }
                        _ => {
                    state = State::Main;
                    continue;
                        }
                    }
                }
            }
        }
    }

    /// Parse brace_comment -> Comment
    fn parse_brace_comment<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        self.mark();
        loop {
            if self.eof() {
                on_event(Event::Comment { content: self.term(), span: self.span_from_mark() });
                return;
            }
            match self.peek() {
                _ => {
                    self.parse_skip_brace_balanced(on_event);
                    self.set_term(-1);
                    on_event(Event::Comment { content: self.term(), span: self.span_from_mark() });
                    return;
                }
            }
        }
    }

    /// Parse embedded -> Embedded
    fn parse_embedded<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        let start_span = self.span();
        on_event(Event::EmbeddedStart { span: start_span.clone() });
        #[derive(Clone, Copy)]
        enum State { Identity, PostIdentity, PreContent,  }
        let mut state = State::Identity;
        loop {
            match state {
                State::Identity => {
                    if self.eof() {
                        on_event(Event::EmbeddedEnd { span: self.span() });
                        return;
                    }
                    match self.peek() {
                        _ => {
                    self.parse_parse_element_identity(b'}', on_event);
                    state = State::PostIdentity;
                    continue;
                        }
                    }
                }
                State::PostIdentity => {
                    if self.eof() {
                        on_event(Event::EmbeddedEnd { span: self.span() });
                        return;
                    }
                    match self.peek() {
                        Some(b'}') => {
                    self.advance();
                    on_event(Event::EmbeddedEnd { span: self.span() });
                    return;
                        }
                        Some(b' ' | b'\t') => {
                    self.advance();
                    state = State::PreContent;
                    continue;
                        }
                        _ => {
                    self.parse_embed_content(on_event);
                    on_event(Event::EmbeddedEnd { span: self.span() });
                    return;
                        }
                    }
                }
                State::PreContent => {
                    if self.eof() {
                        on_event(Event::EmbeddedEnd { span: self.span() });
                        return;
                    }
                    match self.peek() {
                        Some(b'}') => {
                    self.advance();
                    on_event(Event::EmbeddedEnd { span: self.span() });
                    return;
                        }
                        Some(b' ' | b'\t') => {
                    self.advance();
                    continue;
                        }
                        Some(b':') => {
                    self.advance();
                    self.parse_sameline_attr_embedded(on_event);
                    continue;
                        }
                        _ => {
                    self.parse_embed_content(on_event);
                    on_event(Event::EmbeddedEnd { span: self.span() });
                    return;
                        }
                    }
                }
            }
        }
    }

    /// Parse embed_content -> Text
    fn parse_embed_content<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        self.mark();
        #[derive(Clone, Copy)]
        enum State { Main, CheckPipe, CheckSemi, CheckBang,  }
        let mut state = State::Main;
        loop {
            match state {
                State::Main => {
                    match self.scan_to4(b'}', b'|', b';', b'!') {
                        Some(b'}') => {
                    self.set_term(0);
                    self.advance();
                    on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        Some(b'|') => {
                    self.set_term(0);
                    self.advance();
                    state = State::CheckPipe;
                    continue;
                        }
                        Some(b';') => {
                    self.set_term(0);
                    self.advance();
                    state = State::CheckSemi;
                    continue;
                        }
                        Some(b'!') => {
                    self.set_term(0);
                    self.advance();
                    state = State::CheckBang;
                    continue;
                        }
                        None => {
                            on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                            on_event(Event::Error { code: ParseErrorCode::UnclosedText, span: self.span() });
                            return;
                        }
                        _ => unreachable!("scan_to only returns target chars"),
                    }
                }
                State::CheckPipe => {
                    if self.eof() {
                        on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                        on_event(Event::Error { code: ParseErrorCode::UnclosedText, span: self.span() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.advance();
                    self.parse_embedded(on_event);
                    self.mark();
                    state = State::Main;
                    continue;
                        }
                        _ => {
                    self.mark();
                    // Unknown command: raw
                    // Unknown command: raw
                    state = State::Main;
                    continue;
                        }
                    }
                }
                State::CheckSemi => {
                    if self.eof() {
                        on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                        on_event(Event::Error { code: ParseErrorCode::UnclosedText, span: self.span() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.advance();
                    self.parse_brace_comment(on_event);
                    self.mark();
                    state = State::Main;
                    continue;
                        }
                        _ => {
                    self.mark();
                    // Unknown command: raw
                        }
                    }
                }
                State::CheckBang => {
                    if self.eof() {
                        on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                        on_event(Event::Error { code: ParseErrorCode::UnclosedText, span: self.span() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.advance();
                    self.parse_inline_directive(on_event);
                    self.mark();
                    state = State::Main;
                    continue;
                        }
                        _ => {
                    self.mark();
                    on_event(Event::Text { content: b"!", span: self.span() });
                    state = State::Main;
                    continue;
                        }
                    }
                }
            }
        }
    }

    /// Parse block_directive -> Directive
    fn parse_block_directive<F>(&mut self, line_col: i32, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        let start_span = self.span();
        on_event(Event::DirectiveStart { span: start_span.clone() });
        loop {
            match self.scan_to1(b'\n') {
                Some(b'\n') => {
                    on_event(Event::DirectiveEnd { span: self.span() });
                    return;
                }
                None => {
                    on_event(Event::Error { code: ParseErrorCode::UnclosedDirective, span: self.span() });
                    return;
                }
                _ => unreachable!("scan_to only returns target chars"),
            }
        }
    }

    /// Parse inline_directive -> Directive
    fn parse_inline_directive<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        let start_span = self.span();
        on_event(Event::DirectiveStart { span: start_span.clone() });
        loop {
            if self.eof() {
                on_event(Event::DirectiveEnd { span: self.span() });
                return;
            }
            match self.peek() {
                _ => {
                    self.parse_skip_brace_balanced(on_event);
                    on_event(Event::DirectiveEnd { span: self.span() });
                    return;
                }
            }
        }
    }

    /// Parse emit_bare_value
    fn parse_emit_bare_value<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        loop {
            if self.eof() {
                return;
            }
            match self.peek() {
                _ => {
                    on_event(Event::BareValue { content: self.term(), span: self.span_from_mark() });
                    return;
                }
            }
        }
    }

    /// Parse typed_value
    fn parse_typed_value<F>(&mut self, space_term: i32, bracket: u8, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        #[derive(Clone, Copy)]
        enum State { Main, CheckSpace, BlockSpace, Accumulate, AccumSpace, AccumBlock, NumSign, NumZero, NumZeroSpace, NumZeroBlock, NumDec, NumDecSpace, NumDecBlock, NumHex, NumHexSpace, NumHexBlock, NumOct, NumOctSpace, NumOctBlock, NumBin, NumBinSpace, NumBinBlock, NumFloatFrac, NumFloatFracSpace, NumFloatFracBlock, NumFloatExp, NumFloatExpSpace, NumFloatExpBlock, NumFloatExpDigits, NumFloatExpDSpace, NumFloatExpDBlock, String, StringSpace, StringBlock,  }
        let mut state = State::Main;
        loop {
            match state {
                State::Main => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b'\n') => {
                    on_event(Event::BareValue { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        Some(b' ') => {
                    state = State::CheckSpace;
                    continue;
                        }
                        Some(b) if b == bracket => {
                    on_event(Event::BareValue { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        Some(b'0') => {
                    self.advance();
                    state = State::NumZero;
                    continue;
                        }
                        Some(b'1' | b'2' | b'3' | b'4' | b'5' | b'6' | b'7' | b'8' | b'9') => {
                    state = State::NumDec;
                    continue;
                        }
                        Some(b'-' | b'+') => {
                    self.advance();
                    state = State::NumSign;
                    continue;
                        }
                        Some(b) if Self::is_letter(b) => {
                    self.advance();
                    state = State::Accumulate;
                    continue;
                        }
                        _ => {
                    self.advance();
                    continue;
                        }
                    }
                }
                State::CheckSpace => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        _ if space_term == 0 => {
                    state = State::BlockSpace;
                    continue;
                        }
                        _ => {
                    on_event(Event::BareValue { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                    }
                }
                State::BlockSpace => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b';') => {
                    self.set_term(-1);
                    on_event(Event::BareValue { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        _ => {
                    self.advance();
                    state = State::Main;
                    continue;
                        }
                    }
                }
                State::Accumulate => {
                    if self.eof() {
                    self.set_term(0);
                    self.lookup_bare_kw_or_fallback(on_event);
                    return;
                    }
                    match self.peek() {
                        Some(b'\n') => {
                    self.set_term(0);
                    self.lookup_bare_kw_or_fallback(on_event);
                    return;
                        }
                        Some(b' ') => {
                    state = State::AccumSpace;
                    continue;
                        }
                        Some(b) if b == bracket => {
                    self.set_term(0);
                    self.lookup_bare_kw_or_fallback(on_event);
                    return;
                        }
                        Some(b) if Self::is_label_cont(b) => {
                    self.advance();
                    continue;
                        }
                        _ => {
                    self.set_term(0);
                    self.lookup_bare_kw_or_fallback(on_event);
                    return;
                        }
                    }
                }
                State::AccumSpace => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        _ if space_term == 0 => {
                    state = State::AccumBlock;
                    continue;
                        }
                        _ => {
                    self.set_term(0);
                    self.lookup_bare_kw_or_fallback(on_event);
                    return;
                        }
                    }
                }
                State::AccumBlock => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b';') => {
                    self.set_term(-1);
                    self.lookup_bare_kw_or_fallback(on_event);
                    return;
                        }
                        _ => {
                    self.advance();
                    state = State::Accumulate;
                    continue;
                        }
                    }
                }
                State::NumSign => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b'0') => {
                    self.advance();
                    state = State::NumZero;
                    continue;
                        }
                        Some(b'1' | b'2' | b'3' | b'4' | b'5' | b'6' | b'7' | b'8' | b'9') => {
                    state = State::NumDec;
                    continue;
                        }
                        _ => {
                    state = State::Accumulate;
                    continue;
                        }
                    }
                }
                State::NumZero => {
                    if self.eof() {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                    }
                    match self.peek() {
                        Some(b'x' | b'X') => {
                    self.advance();
                    state = State::NumHex;
                    continue;
                        }
                        Some(b'o' | b'O') => {
                    self.advance();
                    state = State::NumOct;
                    continue;
                        }
                        Some(b'b' | b'B') => {
                    self.advance();
                    state = State::NumBin;
                    continue;
                        }
                        Some(b'.') => {
                    self.advance();
                    state = State::NumFloatFrac;
                    continue;
                        }
                        Some(b'e' | b'E') => {
                    self.advance();
                    state = State::NumFloatExp;
                    continue;
                        }
                        Some(b'0' | b'1' | b'2' | b'3' | b'4' | b'5' | b'6' | b'7' | b'8' | b'9' | b'_') => {
                    self.advance();
                    state = State::NumDec;
                    continue;
                        }
                        Some(b'\n') => {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        Some(b' ') => {
                    state = State::NumZeroSpace;
                    continue;
                        }
                        Some(b) if b == bracket => {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        _ => {
                    state = State::String;
                    continue;
                        }
                    }
                }
                State::NumZeroSpace => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        _ if space_term == 0 => {
                    state = State::NumZeroBlock;
                    continue;
                        }
                        _ => {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                    }
                }
                State::NumZeroBlock => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b';') => {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        _ => {
                    self.advance();
                    state = State::String;
                    continue;
                        }
                    }
                }
                State::NumDec => {
                    if self.eof() {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                    }
                    match self.peek() {
                        Some(b'0' | b'1' | b'2' | b'3' | b'4' | b'5' | b'6' | b'7' | b'8' | b'9' | b'_') => {
                    self.advance();
                    continue;
                        }
                        Some(b'.') => {
                    self.advance();
                    state = State::NumFloatFrac;
                    continue;
                        }
                        Some(b'e' | b'E') => {
                    self.advance();
                    state = State::NumFloatExp;
                    continue;
                        }
                        Some(b'\n') => {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        Some(b' ') => {
                    state = State::NumDecSpace;
                    continue;
                        }
                        Some(b) if b == bracket => {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        _ => {
                    state = State::String;
                    continue;
                        }
                    }
                }
                State::NumDecSpace => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        _ if space_term == 0 => {
                    state = State::NumDecBlock;
                    continue;
                        }
                        _ => {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                    }
                }
                State::NumDecBlock => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b';') => {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        _ => {
                    self.advance();
                    state = State::String;
                    continue;
                        }
                    }
                }
                State::NumHex => {
                    if self.eof() {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                    }
                    match self.peek() {
                        Some(b'0' | b'1' | b'2' | b'3' | b'4' | b'5' | b'6' | b'7' | b'8' | b'9' | b'a' | b'b' | b'c' | b'd' | b'e' | b'f' | b'A' | b'B' | b'C' | b'D' | b'E' | b'F' | b'_') => {
                    self.advance();
                    continue;
                        }
                        Some(b'\n') => {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        Some(b' ') => {
                    state = State::NumHexSpace;
                    continue;
                        }
                        Some(b) if b == bracket => {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        _ => {
                    state = State::String;
                    continue;
                        }
                    }
                }
                State::NumHexSpace => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        _ if space_term == 0 => {
                    state = State::NumHexBlock;
                    continue;
                        }
                        _ => {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                    }
                }
                State::NumHexBlock => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b';') => {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        _ => {
                    self.advance();
                    state = State::String;
                    continue;
                        }
                    }
                }
                State::NumOct => {
                    if self.eof() {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                    }
                    match self.peek() {
                        Some(b'0' | b'1' | b'2' | b'3' | b'4' | b'5' | b'6' | b'7' | b'_') => {
                    self.advance();
                    continue;
                        }
                        Some(b'\n') => {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        Some(b' ') => {
                    state = State::NumOctSpace;
                    continue;
                        }
                        Some(b) if b == bracket => {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        _ => {
                    state = State::String;
                    continue;
                        }
                    }
                }
                State::NumOctSpace => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        _ if space_term == 0 => {
                    state = State::NumOctBlock;
                    continue;
                        }
                        _ => {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                    }
                }
                State::NumOctBlock => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b';') => {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        _ => {
                    self.advance();
                    state = State::String;
                    continue;
                        }
                    }
                }
                State::NumBin => {
                    if self.eof() {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                    }
                    match self.peek() {
                        Some(b'0' | b'1' | b'_') => {
                    self.advance();
                    continue;
                        }
                        Some(b'\n') => {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        Some(b' ') => {
                    state = State::NumBinSpace;
                    continue;
                        }
                        Some(b) if b == bracket => {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        _ => {
                    state = State::String;
                    continue;
                        }
                    }
                }
                State::NumBinSpace => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        _ if space_term == 0 => {
                    state = State::NumBinBlock;
                    continue;
                        }
                        _ => {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                    }
                }
                State::NumBinBlock => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b';') => {
                    on_event(Event::Integer { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        _ => {
                    self.advance();
                    state = State::String;
                    continue;
                        }
                    }
                }
                State::NumFloatFrac => {
                    if self.eof() {
                    on_event(Event::Float { content: self.term(), span: self.span_from_mark() });
                    return;
                    }
                    match self.peek() {
                        Some(b'0' | b'1' | b'2' | b'3' | b'4' | b'5' | b'6' | b'7' | b'8' | b'9' | b'_') => {
                    self.advance();
                    continue;
                        }
                        Some(b'e' | b'E') => {
                    self.advance();
                    state = State::NumFloatExp;
                    continue;
                        }
                        Some(b'\n') => {
                    on_event(Event::Float { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        Some(b' ') => {
                    state = State::NumFloatFracSpace;
                    continue;
                        }
                        Some(b) if b == bracket => {
                    on_event(Event::Float { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        _ => {
                    state = State::String;
                    continue;
                        }
                    }
                }
                State::NumFloatFracSpace => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        _ if space_term == 0 => {
                    state = State::NumFloatFracBlock;
                    continue;
                        }
                        _ => {
                    on_event(Event::Float { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                    }
                }
                State::NumFloatFracBlock => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b';') => {
                    on_event(Event::Float { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        _ => {
                    self.advance();
                    state = State::String;
                    continue;
                        }
                    }
                }
                State::NumFloatExp => {
                    if self.eof() {
                    on_event(Event::Float { content: self.term(), span: self.span_from_mark() });
                    return;
                    }
                    match self.peek() {
                        Some(b'+' | b'-') => {
                    self.advance();
                    state = State::NumFloatExpDigits;
                    continue;
                        }
                        Some(b'0' | b'1' | b'2' | b'3' | b'4' | b'5' | b'6' | b'7' | b'8' | b'9') => {
                    state = State::NumFloatExpDigits;
                    continue;
                        }
                        Some(b'\n') => {
                    on_event(Event::Float { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        Some(b' ') => {
                    state = State::NumFloatExpSpace;
                    continue;
                        }
                        Some(b) if b == bracket => {
                    on_event(Event::Float { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        _ => {
                    state = State::String;
                    continue;
                        }
                    }
                }
                State::NumFloatExpSpace => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        _ if space_term == 0 => {
                    state = State::NumFloatExpBlock;
                    continue;
                        }
                        _ => {
                    on_event(Event::Float { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                    }
                }
                State::NumFloatExpBlock => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b';') => {
                    on_event(Event::Float { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        _ => {
                    self.advance();
                    state = State::String;
                    continue;
                        }
                    }
                }
                State::NumFloatExpDigits => {
                    if self.eof() {
                    on_event(Event::Float { content: self.term(), span: self.span_from_mark() });
                    return;
                    }
                    match self.peek() {
                        Some(b'0' | b'1' | b'2' | b'3' | b'4' | b'5' | b'6' | b'7' | b'8' | b'9' | b'_') => {
                    self.advance();
                    continue;
                        }
                        Some(b'\n') => {
                    on_event(Event::Float { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        Some(b' ') => {
                    state = State::NumFloatExpDSpace;
                    continue;
                        }
                        Some(b) if b == bracket => {
                    on_event(Event::Float { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        _ => {
                    state = State::String;
                    continue;
                        }
                    }
                }
                State::NumFloatExpDSpace => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        _ if space_term == 0 => {
                    state = State::NumFloatExpDBlock;
                    continue;
                        }
                        _ => {
                    on_event(Event::Float { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                    }
                }
                State::NumFloatExpDBlock => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b';') => {
                    on_event(Event::Float { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        _ => {
                    self.advance();
                    state = State::String;
                    continue;
                        }
                    }
                }
                State::String => {
                    match self.scan_to2(b'\n', b' ') {
                        Some(b'\n') => {
                    on_event(Event::BareValue { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        Some(b' ') => {
                    state = State::StringSpace;
                    continue;
                        }
                        Some(b) if b == bracket => {
                    on_event(Event::BareValue { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        None => {
                    on_event(Event::BareValue { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        _ => unreachable!("scan_to only returns target chars"),
                    }
                }
                State::StringSpace => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        _ if space_term == 0 => {
                    state = State::StringBlock;
                    continue;
                        }
                        _ => {
                    on_event(Event::BareValue { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                    }
                }
                State::StringBlock => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b';') => {
                    self.set_term(-1);
                    on_event(Event::BareValue { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        _ => {
                    self.advance();
                    state = State::String;
                    continue;
                        }
                    }
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_parse_basic() {
        // Basic smoke test - actual tests depend on parser semantics
        let input = b"";
        let mut events = Vec::new();
        Parser::new(input).parse(|e| events.push(e));
        // Events depend on the specific parser
    }
}
