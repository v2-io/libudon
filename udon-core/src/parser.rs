//! UDON Streaming Parser - Generated by genmachine
//!
//! This is a generated file. Do not edit directly.
//! Source: udon.machine
//!
//! This parser uses a ring buffer architecture for true streaming:
//! - Input arrives in chunks via feed()
//! - Events emit to a ring buffer as they're parsed
//! - Backpressure when buffer is full
//! - Chunk arena for zero-copy string references

use crate::span::Span;
use crate::streaming::{ChunkArena, ChunkSlice, EventRing, FeedResult, StreamingEvent};

/// Parser state enum - persists across feed() calls.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ParserState {
    /// Initial state / document level
    Document,
    /// Need more input to complete current token
    NeedInput,
    /// Finished parsing (got finish() call)
    Finished,
    /// Inside a specific parse function
    InFunction { function: FunctionId, state: u16 },
}

/// Function identifiers for nested parsing.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FunctionId {
    Document,
    Element,
    Array,
    // Add more as needed based on DSL functions
}

/// Streaming parser with ring buffer output.
///
/// # Example
///
/// ```ignore
/// let mut parser = StreamingParser::new(1024); // 1024 event capacity
///
/// // Feed chunks of input
/// parser.feed(b"|div Hello");
/// parser.feed(b" World\n");
/// parser.finish();
///
/// // Read events
/// while let Some(event) = parser.read() {
///     println!("{:?}", event);
/// }
/// ```
pub struct StreamingParser {
    // ========== State Machine ==========

    /// Current parser state
    state: ParserState,

    /// Call stack for nested function calls (element within element, etc.)
    /// Each entry is (function_id, local_state, return_state)
    call_stack: Vec<(FunctionId, u16, ParserState)>,

    // ========== Input Management ==========

    /// Arena storing input chunks
    chunks: ChunkArena,

    /// Current chunk index being parsed
    current_chunk: u32,

    /// Cached pointer to current chunk data (hot path optimization)
    /// This avoids repeated arena lookups in peek()/eof()
    current_ptr: *const u8,
    current_len: usize,

    /// Position within current chunk
    pos: usize,

    /// Partial token buffer (for tokens split across chunks)
    partial: Vec<u8>,

    /// Whether we're continuing a partial token
    in_partial: bool,

    // ========== Position Tracking ==========

    /// Current line number (1-indexed)
    line: u32,

    /// Current column (1-indexed)
    column: u32,

    /// Position of line start (for column calculation)
    line_start: usize,

    /// Global byte offset (across all chunks)
    global_offset: u64,

    // ========== Accumulation ==========

    /// Mark position for MARK/TERM pattern
    mark_chunk: u32,
    mark_pos: u32,

    // ========== Indentation Tracking ==========

    /// Element stack for indentation-based hierarchy
    /// Each entry is (column, has_children)
    element_stack: Vec<(i32, bool)>,

    // ========== Output ==========

    /// Ring buffer for output events
    events: EventRing,

    /// Whether finish() has been called
    finished: bool,
}

impl StreamingParser {
    /// Create a new streaming parser with the given event buffer capacity.
    pub fn new(event_capacity: usize) -> Self {
        Self {
            state: ParserState::Document,
            call_stack: Vec::with_capacity(16),
            chunks: ChunkArena::new(),
            current_chunk: 0,
            current_ptr: std::ptr::null(),
            current_len: 0,
            pos: 0,
            partial: Vec::with_capacity(256),
            in_partial: false,
            line: 1,
            column: 1,
            line_start: 0,
            global_offset: 0,
            mark_chunk: 0,
            mark_pos: 0,
            element_stack: Vec::with_capacity(32),
            events: EventRing::new(event_capacity),
            finished: false,
        }
    }

    /// Create with default capacity (1024 events).
    pub fn with_default_capacity() -> Self {
        Self::new(1024)
    }

    // ========== Public API ==========

    /// Feed a chunk of input to the parser.
    ///
    /// Returns information about how much was consumed and how many events were generated.
    /// If the ring buffer fills up, parsing pauses (backpressure).
    pub fn feed(&mut self, chunk: &[u8]) -> FeedResult {
        if self.finished {
            return FeedResult {
                bytes_consumed: 0,
                events_written: 0,
                buffer_full: false,
            };
        }

        // Add chunk to arena
        let chunk_idx = self.chunks.push(chunk.to_vec());
        self.current_chunk = chunk_idx;
        self.pos = 0;

        // Cache pointer to chunk data for hot path (avoids repeated arena lookups)
        if let Some(chunk) = self.chunks.get(chunk_idx) {
            let data = chunk.data();
            self.current_ptr = data.as_ptr();
            self.current_len = data.len();
        }

        let events_before = self.events.available();

        // Resume parsing
        self.parse_continue();

        let events_written = self.events.available() - events_before;

        FeedResult {
            bytes_consumed: self.pos,
            events_written,
            buffer_full: self.events.is_full(),
        }
    }

    /// Signal end of input stream.
    ///
    /// Flushes any pending partial tokens and emits final events.
    pub fn finish(&mut self) -> FeedResult {
        if self.finished {
            return FeedResult {
                bytes_consumed: 0,
                events_written: 0,
                buffer_full: false,
            };
        }

        self.finished = true;
        let events_before = self.events.available();

        // Emit any pending element ends
        while !self.element_stack.is_empty() {
            self.emit_element_end();
        }

        FeedResult {
            bytes_consumed: 0,
            events_written: self.events.available() - events_before,
            buffer_full: self.events.is_full(),
        }
    }

    /// Read the next event from the ring buffer.
    ///
    /// Returns None if no events are available.
    pub fn read(&mut self) -> Option<StreamingEvent> {
        self.events.pop()
    }

    /// Peek at the next event without consuming it.
    pub fn peek_event(&self) -> Option<&StreamingEvent> {
        self.events.peek()
    }

    /// Number of events available to read.
    pub fn available(&self) -> usize {
        self.events.available()
    }

    /// Check if parsing is complete (finish called and buffer drained).
    pub fn is_done(&self) -> bool {
        self.finished && self.events.is_empty()
    }

    /// Check if the ring buffer is full (backpressure).
    pub fn is_buffer_full(&self) -> bool {
        self.events.is_full()
    }

    /// Get access to the chunk arena (for resolving ChunkSlice to bytes).
    pub fn arena(&self) -> &ChunkArena {
        &self.chunks
    }

    /// Reset the parser for reuse.
    ///
    /// Clears all state but keeps allocated capacity, allowing efficient
    /// reuse of the parser across multiple parse operations.
    pub fn reset(&mut self) {
        self.state = ParserState::Document;
        self.call_stack.clear();
        self.chunks.clear();
        self.current_chunk = 0;
        self.current_ptr = std::ptr::null();
        self.current_len = 0;
        self.pos = 0;
        self.partial.clear();
        self.in_partial = false;
        self.line = 1;
        self.column = 1;
        self.line_start = 0;
        self.global_offset = 0;
        self.mark_chunk = 0;
        self.mark_pos = 0;
        self.element_stack.clear();
        self.events.clear();
        self.finished = false;
    }

    // ========== Internal Helpers ==========
    //
    // These methods provide compatibility with the generated state machine code.
    // Hot path methods use cached pointer to avoid arena lookups.

    /// Check if at end of current chunk.
    #[inline(always)]
    fn eof(&self) -> bool {
        self.pos >= self.current_len
    }

    /// Get current byte without advancing.
    #[inline(always)]
    fn peek(&self) -> Option<u8> {
        if self.pos < self.current_len {
            // SAFETY: pos < current_len, and current_ptr points to valid data
            // that lives in the arena for the duration of parsing this chunk
            Some(unsafe { *self.current_ptr.add(self.pos) })
        } else {
            None
        }
    }

    /// Get current chunk's data (uses cached pointer).
    #[inline(always)]
    fn current_chunk_data(&self) -> &[u8] {
        if self.current_ptr.is_null() {
            &[]
        } else {
            // SAFETY: current_ptr/current_len set from valid chunk data in feed()
            unsafe { std::slice::from_raw_parts(self.current_ptr, self.current_len) }
        }
    }

    /// Advance one byte.
    #[inline(always)]
    fn advance(&mut self) {
        if self.pos < self.current_len {
            // SAFETY: pos < current_len, pointer is valid
            let b = unsafe { *self.current_ptr.add(self.pos) };
            if b == b'\n' {
                self.line += 1;
                self.column = 1;
                self.pos += 1;
                self.line_start = self.pos;
            } else {
                self.column += 1;
                self.pos += 1;
            }
            self.global_offset += 1;
        }
    }

    /// Mark current position for accumulation.
    #[inline]
    fn mark(&mut self) {
        self.mark_chunk = self.current_chunk;
        self.mark_pos = self.pos as u32;
    }

    /// Get accumulated slice from mark to current position.
    ///
    /// Fast path: if mark and current are in same chunk, returns direct reference.
    /// Slow path: if token spans chunks, copies bytes into a synthetic chunk.
    #[inline]
    fn term(&mut self) -> ChunkSlice {
        if self.mark_chunk == self.current_chunk {
            // Fast path: same chunk, no copy needed
            ChunkSlice::new(self.mark_chunk, self.mark_pos, self.pos as u32)
        } else {
            // Slow path: token spans multiple chunks, need to copy
            self.term_cross_chunk()
        }
    }

    /// Handle token that spans multiple chunks (cold path).
    ///
    /// Copies bytes from mark position through current position across all
    /// intervening chunks, pushes as a synthetic chunk, returns slice to it.
    #[cold]
    fn term_cross_chunk(&mut self) -> ChunkSlice {
        // Reuse the partial buffer for accumulation
        self.partial.clear();

        // Copy from mark_chunk[mark_pos..end]
        if let Some(chunk) = self.chunks.get(self.mark_chunk) {
            let data = chunk.data();
            self.partial.extend_from_slice(&data[self.mark_pos as usize..]);
        }

        // Copy from any intermediate chunks (mark_chunk + 1 .. current_chunk)
        for chunk_idx in (self.mark_chunk + 1)..self.current_chunk {
            if let Some(chunk) = self.chunks.get(chunk_idx) {
                self.partial.extend_from_slice(chunk.data());
            }
        }

        // Copy from current_chunk[0..pos]
        if let Some(chunk) = self.chunks.get(self.current_chunk) {
            let data = chunk.data();
            self.partial.extend_from_slice(&data[..self.pos]);
        }

        // Push as synthetic chunk and return slice to it
        let synthetic_data = std::mem::take(&mut self.partial);
        let len = synthetic_data.len() as u32;
        let chunk_idx = self.chunks.push(synthetic_data);
        ChunkSlice::new(chunk_idx, 0, len)
    }

    /// Get current column (0-indexed from line start).
    #[inline]
    fn current_column(&self) -> i32 {
        (self.pos - self.line_start) as i32
    }

    /// Create a span from mark to current position.
    #[inline]
    fn span_from_mark(&self) -> Span {
        let start = self.chunks.get(self.mark_chunk)
            .map(|c| c.stream_offset() as usize + self.mark_pos as usize)
            .unwrap_or(0);
        let end = self.chunks.get(self.current_chunk)
            .map(|c| c.stream_offset() as usize + self.pos)
            .unwrap_or(0);
        Span::new(start, end)
    }

    /// Emit an event to the ring buffer.
    #[inline]
    fn emit(&mut self, event: StreamingEvent) {
        // If buffer is full, we'd need to handle backpressure
        // For now, just push (will panic if full)
        let _ = self.events.try_push(event);
    }

    /// Emit ElementEnd event.
    fn emit_element_end(&mut self) {
        if self.element_stack.pop().is_some() {
            self.emit(StreamingEvent::ElementEnd {
                span: Span::new(self.global_offset as usize, self.global_offset as usize),
            });
        }
    }

    /// Emit special attribute for identity parsing ($id, $class, suffixes).
    /// These are synthetic keys that don't come from the input.
    fn emit_special_attribute(&mut self, _key: &str) {
        // For special attributes, we need to handle them differently
        // since the key is a static string, not from input.
        // We'll create a synthetic ChunkSlice pointing to the current position.
        // For now, use the actual term (which contains the value, e.g. "#id-name")
        // TODO: Better solution for static attribute keys
        let key = self.term();
        let span = self.span_from_mark();
        self.emit(StreamingEvent::Attribute { key, span });
    }

    /// Check if byte can start a LABEL.
    #[inline]
    fn is_label_start(&self, b: u8) -> bool {
        matches!(b, b'a'..=b'z' | b'A'..=b'Z' | b'_') ||
        (b >= 0x80 && self.is_unicode_letter_at(self.pos))
    }

    /// Check if byte can continue a LABEL.
    #[inline]
    fn is_label_continue(&self, b: u8) -> bool {
        matches!(b, b'a'..=b'z' | b'A'..=b'Z' | b'0'..=b'9' | b'_' | b'-') ||
        (b >= 0x80 && self.is_unicode_letter_or_number_at(self.pos))
    }

    /// Check for Unicode letter at position.
    fn is_unicode_letter_at(&self, pos: usize) -> bool {
        if let Some(slice) = self.current_chunk_data().get(pos..) {
            if let Ok(s) = std::str::from_utf8(slice) {
                if let Some(c) = s.chars().next() {
                    return unicode_xid::UnicodeXID::is_xid_start(c);
                }
            }
        }
        false
    }

    /// Check for Unicode letter or number at position.
    fn is_unicode_letter_or_number_at(&self, pos: usize) -> bool {
        if let Some(slice) = self.current_chunk_data().get(pos..) {
            if let Ok(s) = std::str::from_utf8(slice) {
                if let Some(c) = s.chars().next() {
                    return unicode_xid::UnicodeXID::is_xid_continue(c);
                }
            }
        }
        false
    }

    // ========== SIMD-Accelerated Scanning ==========
    //
    // These functions use memchr for fast SIMD-based scanning through content.
    // They advance position and line/column tracking in bulk.

    /// Scan prose until newline, semicolon, or pipe (prose terminators).
    /// Returns the terminating byte, or None if EOF.
    /// Advances position to the terminator (does not consume it).
    #[inline]
    fn scan_prose(&mut self) -> Option<u8> {
        // Use raw pointer to avoid borrow issues
        if self.current_ptr.is_null() || self.pos >= self.current_len {
            return None;
        }

        let remaining = unsafe {
            std::slice::from_raw_parts(
                self.current_ptr.add(self.pos),
                self.current_len - self.pos
            )
        };

        // Use memchr3 to find next prose terminator
        match memchr::memchr3(b'\n', b';', b'|', remaining) {
            Some(offset) => {
                // Advance position (no newlines in scanned range)
                self.pos += offset;
                self.column += offset as u32;
                self.global_offset += offset as u64;
                Some(remaining[offset])
            }
            None => {
                // No terminator found, consume rest of chunk
                let len = remaining.len();
                self.pos += len;
                self.column += len as u32;
                self.global_offset += len as u64;
                None
            }
        }
    }

    /// Scan until newline (for comments, escaped text, etc.).
    /// Returns true if newline found, false if EOF.
    /// Advances position to the newline (does not consume it).
    #[inline]
    fn scan_until_newline(&mut self) -> bool {
        if self.current_ptr.is_null() || self.pos >= self.current_len {
            return false;
        }

        let remaining = unsafe {
            std::slice::from_raw_parts(
                self.current_ptr.add(self.pos),
                self.current_len - self.pos
            )
        };

        match memchr::memchr(b'\n', remaining) {
            Some(offset) => {
                self.pos += offset;
                self.column += offset as u32;
                self.global_offset += offset as u64;
                true
            }
            None => {
                let len = remaining.len();
                self.pos += len;
                self.column += len as u32;
                self.global_offset += len as u64;
                false
            }
        }
    }

    /// Scan quoted string content until closing quote or backslash escape.
    /// Returns the terminating byte (quote or backslash), or None if EOF.
    #[inline]
    fn scan_quoted(&mut self, quote: u8) -> Option<u8> {
        if self.current_ptr.is_null() || self.pos >= self.current_len {
            return None;
        }

        let remaining = unsafe {
            std::slice::from_raw_parts(
                self.current_ptr.add(self.pos),
                self.current_len - self.pos
            )
        };

        // Look for quote or escape
        match memchr::memchr2(quote, b'\\', remaining) {
            Some(offset) => {
                // Check for newlines in scanned content (rare, but need accurate line tracking)
                let scanned = &remaining[..offset];
                let newlines = memchr::memchr_iter(b'\n', scanned).count();
                if newlines > 0 {
                    // Find last newline for column calculation
                    let last_nl = memchr::memrchr(b'\n', scanned).unwrap();
                    self.line += newlines as u32;
                    self.column = (offset - last_nl) as u32;
                    self.line_start = self.pos + last_nl + 1;
                } else {
                    self.column += offset as u32;
                }
                self.pos += offset;
                self.global_offset += offset as u64;
                Some(remaining[offset])
            }
            None => {
                // Handle newlines in remaining content
                let newlines = memchr::memchr_iter(b'\n', remaining).count();
                if newlines > 0 {
                    if let Some(last_nl) = memchr::memrchr(b'\n', remaining) {
                        self.line += newlines as u32;
                        self.column = (remaining.len() - last_nl - 1) as u32;
                        self.line_start = self.pos + last_nl + 1;
                    }
                } else {
                    self.column += remaining.len() as u32;
                }
                let len = remaining.len();
                self.pos += len;
                self.global_offset += len as u64;
                None
            }
        }
    }

    /// Scan label/identifier characters (ASCII fast path).
    /// Stops at first non-label character.
    #[inline]
    fn scan_label(&mut self) {
        while self.pos < self.current_len {
            // SAFETY: pos < current_len, current_ptr valid
            let b = unsafe { *self.current_ptr.add(self.pos) };
            if matches!(b, b'a'..=b'z' | b'A'..=b'Z' | b'0'..=b'9' | b'_' | b'-') {
                self.pos += 1;
                self.column += 1;
                self.global_offset += 1;
            } else if b >= 0x80 {
                // Unicode - need to check via helper
                if self.is_unicode_letter_or_number_at(self.pos) {
                    // Get UTF-8 char width
                    let data = self.current_chunk_data();
                    if let Ok(s) = std::str::from_utf8(&data[self.pos..]) {
                        if let Some(c) = s.chars().next() {
                            let width = c.len_utf8();
                            self.pos += width;
                            self.column += 1;
                            self.global_offset += width as u64;
                            continue;
                        }
                    }
                }
                break;
            } else {
                break;
            }
        }
    }

    /// Emit a typed value based on accumulated content.
    fn emit_typed_value(&mut self) {
        let slice = self.term();
        let span = self.span_from_mark();

        // Resolve slice to check content
        if let Some(bytes) = self.chunks.resolve(slice) {
            // Check for nil
            if bytes == b"null" || bytes == b"nil" || bytes == b"~" {
                self.emit(StreamingEvent::NilValue { span });
                return;
            }

            // Check for bool
            if bytes == b"true" {
                self.emit(StreamingEvent::BoolValue { value: true, span });
                return;
            }
            if bytes == b"false" {
                self.emit(StreamingEvent::BoolValue { value: false, span });
                return;
            }

            // Try to parse as number
            if let Some(event) = self.try_parse_number(bytes, span) {
                self.emit(event);
                return;
            }
        }

        // Default to string
        self.emit(StreamingEvent::StringValue { value: slice, span });
    }

    /// Try to parse bytes as a number.
    fn try_parse_number(&self, bytes: &[u8], span: Span) -> Option<StreamingEvent> {
        use crate::Value;
        match Value::parse(bytes) {
            Value::Integer(i) => Some(StreamingEvent::IntegerValue { value: i, span }),
            Value::Float(f) => Some(StreamingEvent::FloatValue { value: f, span }),
            Value::Rational { numerator, denominator } => {
                Some(StreamingEvent::RationalValue { numerator, denominator, span })
            }
            Value::Complex { real, imag } => {
                Some(StreamingEvent::ComplexValue { real, imag, span })
            }
            _ => None,
        }
    }

    // ========== State Machine Entry Point ==========

    /// Continue parsing from current state.
    fn parse_continue(&mut self) {
        // For now, just run the document parser
        // TODO: Proper state restoration for streaming
        self.parse_document();
    }

    // ========== Generated State Machine ==========

    fn parse_document(&mut self) {
        #[derive(Clone, Copy)]
        enum State { SStart, SEscaped, SEscapedText, SProse, SCheckInlineComment, SInlineComment, SInlineCommentNested, SLineComment, SBlockComment, SMaybeFreeform, SMaybeFreeform2, SFreeform, SFreeformEnd1, SFreeformEnd2, SDirective, SDirectiveInterp, SDirectiveName, SDirectiveBody, SProseAfterDirective, SSkipLine }

        let mut state = State::SStart;
        loop {
            match state {
                State::SStart => {
                    if self.eof() {
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.advance();
                            state = State::SStart;
                        }
                        b' ' => {
                            self.advance();
                            state = State::SStart;
                        }
                        b'\t' => {
                            self.advance();
                            self.emit(StreamingEvent::Error { message: "no tabs".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            state = State::SSkipLine;
                        }
                        b'\'' => {
                            self.advance();
                            state = State::SEscaped;
                        }
                        b';' => {
                            self.advance();
                            self.mark();
                            state = State::SBlockComment;
                        }
                        b'|' => {
                            self.advance();
                            self.parse_element(self.current_column());
                            state = State::SStart;
                        }
                        b'`' => {
                            self.advance();
                            state = State::SMaybeFreeform;
                        }
                        b'!' => {
                            self.advance();
                            state = State::SDirective;
                        }
                        _ => {
                            self.mark();
                            state = State::SProse;
                        }
                        }
                    }
                }
                State::SEscaped => {
                    if self.eof() {
                        { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            state = State::SStart;
                        }
                        _ => {
                            self.mark();
                            state = State::SEscapedText;
                        }
                        }
                    }
                }
                State::SEscapedText => {
                    // SIMD-optimized: scan to newline in bulk
                    if self.scan_until_newline() {
                        { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                        state = State::SStart;
                    } else {
                        // EOF
                        { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                        return;
                    }
                }
                State::SProse => {
                    // SIMD-optimized: scan to next terminator in bulk
                    match self.scan_prose() {
                        Some(b'\n') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            state = State::SStart;
                        }
                        Some(b';') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.advance();
                            state = State::SCheckInlineComment;
                        }
                        Some(b'|') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.advance();
                            self.parse_element(self.current_column());
                            state = State::SStart;
                        }
                        Some(_) => unreachable!(), // scan_prose only returns \n, ;, |
                        None => {
                            // EOF
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            return;
                        }
                    }
                }
                State::SCheckInlineComment => {
                    if self.eof() {
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'{' => {
                            self.advance();
                            state = State::SInlineComment;
                        }
                        _ => {
                            self.mark();
                            state = State::SLineComment;
                        }
                        }
                    }
                }
                State::SInlineComment => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed comment".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'}' => {
                            self.advance();
                            state = State::SProse;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SInlineCommentNested;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SInlineCommentNested => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed comment".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'}' => {
                            self.advance();
                            state = State::SInlineComment;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SLineComment => {
                    // SIMD-optimized: scan to newline in bulk
                    if self.scan_until_newline() {
                        { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Comment { content, span }); }
                        state = State::SStart;
                    } else {
                        // EOF
                        { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Comment { content, span }); }
                        return;
                    }
                }
                State::SBlockComment => {
                    // SIMD-optimized: scan to newline in bulk
                    if self.scan_until_newline() {
                        { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Comment { content, span }); }
                        state = State::SStart;
                    } else {
                        // EOF
                        { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Comment { content, span }); }
                        return;
                    }
                }
                State::SMaybeFreeform => {
                    if self.eof() {
                        { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'`' => {
                            self.advance();
                            state = State::SMaybeFreeform2;
                        }
                        _ => {
                            self.mark();
                            state = State::SProse;
                        }
                        }
                    }
                }
                State::SMaybeFreeform2 => {
                    if self.eof() {
                        { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'`' => {
                            self.mark();
                            state = State::SFreeform;
                        }
                        _ => {
                            self.mark();
                            state = State::SProse;
                        }
                        }
                    }
                }
                State::SFreeform => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed freeform".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'`' => {
                            self.advance();
                            state = State::SFreeformEnd1;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SFreeformEnd1 => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed freeform".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'`' => {
                            self.advance();
                            state = State::SFreeformEnd2;
                        }
                        _ => {
                            self.advance();
                            state = State::SFreeform;
                        }
                        }
                    }
                }
                State::SFreeformEnd2 => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed freeform".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'`' => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::RawContent { content, span }); }
                            state = State::SStart;
                        }
                        _ => {
                            self.advance();
                            state = State::SFreeform;
                        }
                        }
                    }
                }
                State::SDirective => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "incomplete directive".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'{' => {
                            self.mark();
                            state = State::SDirectiveInterp;
                        }
                        _ => {
                            self.mark();
                            state = State::SDirectiveName;
                        }
                        }
                    }
                }
                State::SDirectiveInterp => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed directive".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'}' => {
                            { let expression = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Interpolation { expression, span }); }
                            state = State::SProseAfterDirective;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SDirectiveName => {
                    if self.eof() {
                        // TODO: emit Directive
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            // TODO: emit Directive
                            state = State::SStart;
                        }
                        b'{' => {
                            // TODO: emit Directive
                            state = State::SDirectiveBody;
                        }
                        b' ' | b'\t' => {
                            // TODO: emit Directive
                            state = State::SProseAfterDirective;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SDirectiveBody => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed directive".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'}' => {
                            // TODO: emit DirectiveBody
                            state = State::SProseAfterDirective;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SProseAfterDirective => {
                    if self.eof() {
                        { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            state = State::SStart;
                        }
                        b';' => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.advance();
                            state = State::SCheckInlineComment;
                        }
                        b'|' => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.advance();
                            self.parse_element(self.current_column());
                            state = State::SStart;
                        }
                        _ => {
                            self.mark();
                            state = State::SProse;
                        }
                        }
                    }
                }
                State::SSkipLine => {
                    if self.eof() {
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            state = State::SStart;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
            }
        }
    }

    fn parse_element(&mut self, elem_col: i32) {
        #[derive(Clone, Copy)]
        enum State { SIdentity, SIdName, SIdAfterName, SIdCheckBracket, SIdBracketStart, SIdAnonBracket, SIdBracketValue, SIdAfterBracket, SIdCheckClass, SIdClassStart, SIdClassName, SIdClassCheckMore, SIdSpaceSuffix, SIdQuotedName, SIdQuotedNameContent, SIdQuotedNameEscape, SIdClassQuoted, SIdClassQuotedContent, SIdClassQuotedEscape, SIdCheckMore, SAfterIdentity, SInlineContent, SInlineText, SElemCommentCheck, SElemInlineComment, SElemLineComment, SInlineAttrKey, SInlineAttrKeyScan, SInlineAttrKeyQuoted, SInlineAttrKeyQuotedContent, SInlineAttrKeyQuotedEsc, SInlineAttrWs, SInlineAttrValue, SInlineAttrDquote, SInlineAttrDquoteContent, SInlineAttrDquoteEsc, SInlineAttrSquote, SInlineAttrSquoteContent, SInlineAttrSquoteEsc, SInlineAttrBare, SInlineAttrAfterValue, SChildren, SChildrenContent, SChildrenAfterElement, SChildrenCountWs, SChildEscaped, SChildEscapedText, SChildProse, SChildCommentCheck, SChildInlineComment, SChildLineComment, SChildBlockComment, SChildFreeformCheck, SChildFreeformCheck2, SChildFreeform, SChildFreeformEnd1, SChildFreeformEnd2, SChildDirective, SChildDirectiveInterp, SChildDirectiveName, SChildDirectiveBody, SSkipChild, SAttrKey, SAttrKeyScan, SAttrKeyQuoted, SAttrKeyQuotedContent, SAttrKeyQuotedEsc, SAttrWs, SAttrValue, SAttrComment, SAttrDquote, SAttrDquoteContent, SAttrDquoteEsc, SAttrSquote, SAttrSquoteContent, SAttrSquoteEsc, SAttrBare, SAttrAfterValue, SAttrSkipLine }

        let mut state = State::SIdentity;
        loop {
            match state {
                State::SIdentity => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b if self.is_label_start(b) => {
                            self.mark();
                            state = State::SIdName;
                        }
                        b'[' => {
                            self.advance();
                            state = State::SIdAnonBracket;
                        }
                        b'.' => {
                            self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            state = State::SIdClassStart;
                        }
                        b'?' => {
                            self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.emit_special_attribute("?");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SIdCheckMore;
                        }
                        b'!' => {
                            self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.emit_special_attribute("!");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SIdCheckMore;
                        }
                        b'*' => {
                            self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.emit_special_attribute("*");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SIdCheckMore;
                        }
                        b'+' => {
                            self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.emit_special_attribute("+");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SIdCheckMore;
                        }
                        b'\'' => {
                            self.advance();
                            state = State::SIdQuotedName;
                        }
                        _ => {
                            self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            state = State::SAfterIdentity;
                        }
                        }
                    }
                }
                State::SIdName => {
                    if self.eof() {
                        { let name = Some(self.term()); let span = self.span_from_mark(); self.emit(StreamingEvent::ElementStart { name, span }); }
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b if self.is_label_continue(b) => {
                            self.advance();
                        }
                        _ => {
                            { let name = Some(self.term()); let span = self.span_from_mark(); self.emit(StreamingEvent::ElementStart { name, span }); }
                            state = State::SIdAfterName;
                        }
                        }
                    }
                }
                State::SIdAfterName => {
                    if self.eof() {
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'?' => {
                            self.emit_special_attribute("?");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SIdCheckBracket;
                        }
                        b'!' => {
                            self.emit_special_attribute("!");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SIdCheckBracket;
                        }
                        b'*' => {
                            self.emit_special_attribute("*");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SIdCheckBracket;
                        }
                        b'+' => {
                            self.emit_special_attribute("+");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SIdCheckBracket;
                        }
                        b'[' => {
                            self.advance();
                            state = State::SIdBracketStart;
                        }
                        b'.' => {
                            self.advance();
                            state = State::SIdClassStart;
                        }
                        _ => {
                            state = State::SAfterIdentity;
                        }
                        }
                    }
                }
                State::SIdCheckBracket => {
                    if self.eof() {
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'[' => {
                            self.advance();
                            state = State::SIdBracketStart;
                        }
                        b'.' => {
                            self.advance();
                            state = State::SIdClassStart;
                        }
                        _ => {
                            state = State::SAfterIdentity;
                        }
                        }
                    }
                }
                State::SIdBracketStart => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed bracket".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b']' => {
                            self.advance();
                            state = State::SIdAfterBracket;
                        }
                        _ => {
                            self.emit_special_attribute("$id");
                            self.mark();
                            state = State::SIdBracketValue;
                        }
                        }
                    }
                }
                State::SIdAnonBracket => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::Error { message: "unclosed bracket".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b']' => {
                            self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            state = State::SIdAfterBracket;
                        }
                        _ => {
                            self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.emit_special_attribute("$id");
                            self.mark();
                            state = State::SIdBracketValue;
                        }
                        }
                    }
                }
                State::SIdBracketValue => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed bracket".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b']' => {
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::StringValue { value, span }); }
                            self.advance();
                            state = State::SIdAfterBracket;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SIdAfterBracket => {
                    if self.eof() {
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'?' => {
                            self.emit_special_attribute("?");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SIdCheckClass;
                        }
                        b'!' => {
                            self.emit_special_attribute("!");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SIdCheckClass;
                        }
                        b'*' => {
                            self.emit_special_attribute("*");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SIdCheckClass;
                        }
                        b'+' => {
                            self.emit_special_attribute("+");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SIdCheckClass;
                        }
                        b'.' => {
                            self.advance();
                            state = State::SIdClassStart;
                        }
                        _ => {
                            state = State::SAfterIdentity;
                        }
                        }
                    }
                }
                State::SIdCheckClass => {
                    if self.eof() {
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'.' => {
                            self.advance();
                            state = State::SIdClassStart;
                        }
                        _ => {
                            state = State::SAfterIdentity;
                        }
                        }
                    }
                }
                State::SIdClassStart => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "expected class name".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b if self.is_label_start(b) => {
                            self.emit_special_attribute("$class");
                            self.mark();
                            state = State::SIdClassName;
                        }
                        b'\'' => {
                            self.emit_special_attribute("$class");
                            self.advance();
                            state = State::SIdClassQuoted;
                        }
                        _ => {
                            self.emit(StreamingEvent::Error { message: "expected class name".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            state = State::SAfterIdentity;
                        }
                        }
                    }
                }
                State::SIdClassName => {
                    if self.eof() {
                        { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::StringValue { value, span }); }
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b if self.is_label_continue(b) => {
                            self.advance();
                        }
                        _ => {
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::StringValue { value, span }); }
                            state = State::SIdClassCheckMore;
                        }
                        }
                    }
                }
                State::SIdClassCheckMore => {
                    if self.eof() {
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'.' => {
                            self.advance();
                            state = State::SIdClassStart;
                        }
                        b' ' => {
                            self.advance();
                            state = State::SIdSpaceSuffix;
                        }
                        _ => {
                            state = State::SAfterIdentity;
                        }
                        }
                    }
                }
                State::SIdSpaceSuffix => {
                    if self.eof() {
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'?' => {
                            self.emit_special_attribute("?");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SAfterIdentity;
                        }
                        b'!' => {
                            self.emit_special_attribute("!");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SAfterIdentity;
                        }
                        b'*' => {
                            self.emit_special_attribute("*");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SAfterIdentity;
                        }
                        b'+' => {
                            self.emit_special_attribute("+");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SAfterIdentity;
                        }
                        b' ' => {
                            self.advance();
                        }
                        _ => {
                            state = State::SAfterIdentity;
                        }
                        }
                    }
                }
                State::SIdQuotedName => {
                    if self.eof() {
                        { let name = Some(self.term()); let span = self.span_from_mark(); self.emit(StreamingEvent::ElementStart { name, span }); }
                        self.emit(StreamingEvent::Error { message: "unclosed quote".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            self.mark();
                            { let name = Some(self.term()); let span = self.span_from_mark(); self.emit(StreamingEvent::ElementStart { name, span }); }
                            self.advance();
                            state = State::SIdAfterName;
                        }
                        _ => {
                            self.mark();
                            state = State::SIdQuotedNameContent;
                        }
                        }
                    }
                }
                State::SIdQuotedNameContent => {
                    if self.eof() {
                        { let name = Some(self.term()); let span = self.span_from_mark(); self.emit(StreamingEvent::ElementStart { name, span }); }
                        self.emit(StreamingEvent::Error { message: "unclosed quote".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            { let name = Some(self.term()); let span = self.span_from_mark(); self.emit(StreamingEvent::ElementStart { name, span }); }
                            self.advance();
                            state = State::SIdAfterName;
                        }
                        b'\\' => {
                            self.advance();
                            state = State::SIdQuotedNameEscape;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SIdQuotedNameEscape => {
                    if self.eof() {
                        { let name = Some(self.term()); let span = self.span_from_mark(); self.emit(StreamingEvent::ElementStart { name, span }); }
                        self.emit(StreamingEvent::Error { message: "unclosed quote".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        _ => {
                            self.advance();
                            state = State::SIdQuotedNameContent;
                        }
                        }
                    }
                }
                State::SIdClassQuoted => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed quote".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            self.mark();
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SIdClassCheckMore;
                        }
                        _ => {
                            self.mark();
                            state = State::SIdClassQuotedContent;
                        }
                        }
                    }
                }
                State::SIdClassQuotedContent => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed quote".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SIdClassCheckMore;
                        }
                        b'\\' => {
                            self.advance();
                            state = State::SIdClassQuotedEscape;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SIdClassQuotedEscape => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed quote".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        _ => {
                            self.advance();
                            state = State::SIdClassQuotedContent;
                        }
                        }
                    }
                }
                State::SIdCheckMore => {
                    if self.eof() {
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'[' => {
                            self.advance();
                            state = State::SIdBracketStart;
                        }
                        b'.' => {
                            self.advance();
                            state = State::SIdClassStart;
                        }
                        _ => {
                            state = State::SAfterIdentity;
                        }
                        }
                    }
                }
                State::SAfterIdentity => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.advance();
                            state = State::SChildren;
                        }
                        b' ' | b'\t' => {
                            self.advance();
                            state = State::SInlineContent;
                        }
                        b';' => {
                            self.advance();
                            state = State::SElemCommentCheck;
                        }
                        b':' => {
                            self.advance();
                            state = State::SInlineAttrKey;
                        }
                        b'|' => {
                            self.advance();
                            self.parse_element(self.current_column());
                            state = State::SInlineContent;
                        }
                        _ => {
                            self.mark();
                            state = State::SInlineText;
                        }
                        }
                    }
                }
                State::SInlineContent => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.advance();
                            state = State::SChildren;
                        }
                        b' ' | b'\t' => {
                            self.advance();
                        }
                        b';' => {
                            self.advance();
                            state = State::SElemCommentCheck;
                        }
                        b':' => {
                            self.advance();
                            state = State::SInlineAttrKey;
                        }
                        b'|' => {
                            self.advance();
                            self.parse_element(self.current_column());
                            state = State::SInlineContent;
                        }
                        _ => {
                            self.mark();
                            state = State::SInlineText;
                        }
                        }
                    }
                }
                State::SInlineText => {
                    // SIMD-optimized: scan to next terminator in bulk
                    match self.scan_prose() {
                        Some(b'\n') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.advance();
                            state = State::SChildren;
                        }
                        Some(b';') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.advance();
                            state = State::SElemCommentCheck;
                        }
                        Some(b'|') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.advance();
                            self.parse_element(self.current_column());
                            state = State::SInlineContent;
                        }
                        Some(_) => unreachable!(),
                        None => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                    }
                }
                State::SElemCommentCheck => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'{' => {
                            self.advance();
                            state = State::SElemInlineComment;
                        }
                        _ => {
                            self.mark();
                            state = State::SElemLineComment;
                        }
                        }
                    }
                }
                State::SElemInlineComment => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'}' => {
                            self.advance();
                            state = State::SInlineContent;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SElemLineComment => {
                    if self.eof() {
                        { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Comment { content, span }); }
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Comment { content, span }); }
                            self.advance();
                            state = State::SChildren;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SInlineAttrKey => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "expected attr key".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b if self.is_label_start(b) => {
                            self.mark();
                            state = State::SInlineAttrKeyScan;
                        }
                        b'\'' => {
                            self.advance();
                            state = State::SInlineAttrKeyQuoted;
                        }
                        _ => {
                            self.emit(StreamingEvent::Error { message: "expected attr key".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            state = State::SInlineContent;
                        }
                        }
                    }
                }
                State::SInlineAttrKeyScan => {
                    if self.eof() {
                        { let key = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Attribute { key, span }); }
                        state = State::SInlineAttrWs;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b if self.is_label_continue(b) => {
                            self.advance();
                        }
                        _ => {
                            { let key = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Attribute { key, span }); }
                            state = State::SInlineAttrWs;
                        }
                        }
                    }
                }
                State::SInlineAttrKeyQuoted => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed quote".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            self.mark();
                            { let key = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Attribute { key, span }); }
                            self.advance();
                            state = State::SInlineAttrWs;
                        }
                        _ => {
                            self.mark();
                            state = State::SInlineAttrKeyQuotedContent;
                        }
                        }
                    }
                }
                State::SInlineAttrKeyQuotedContent => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed quote".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            { let key = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Attribute { key, span }); }
                            state = State::SInlineAttrWs;
                        }
                        b'\\' => {
                            self.advance();
                            state = State::SInlineAttrKeyQuotedEsc;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SInlineAttrKeyQuotedEsc => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed quote".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        _ => {
                            self.advance();
                            state = State::SInlineAttrKeyQuotedContent;
                        }
                        }
                    }
                }
                State::SInlineAttrWs => {
                    if self.eof() {
                        state = State::SInlineAttrValue;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b' ' | b'\t' => {
                            self.advance();
                        }
                        _ => {
                            state = State::SInlineAttrValue;
                        }
                        }
                    }
                }
                State::SInlineAttrValue => {
                    if self.eof() {
                        { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                        state = State::SInlineContent;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            state = State::SChildren;
                        }
                        b';' => {
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            state = State::SElemCommentCheck;
                        }
                        b':' => {
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            state = State::SInlineAttrKey;
                        }
                        b'[' => {
                            self.emit(StreamingEvent::ArrayStart { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            self.parse_array();
                            state = State::SInlineAttrAfterValue;
                        }
                        b'"' => {
                            self.advance();
                            state = State::SInlineAttrDquote;
                        }
                        b'\'' => {
                            self.advance();
                            state = State::SInlineAttrSquote;
                        }
                        _ => {
                            self.mark();
                            state = State::SInlineAttrBare;
                        }
                        }
                    }
                }
                State::SInlineAttrDquote => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'"' => {
                            self.mark();
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SInlineAttrAfterValue;
                        }
                        _ => {
                            self.mark();
                            state = State::SInlineAttrDquoteContent;
                        }
                        }
                    }
                }
                State::SInlineAttrDquoteContent => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SInlineContent;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'"' => {
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SInlineAttrAfterValue;
                        }
                        b'\\' => {
                            self.advance();
                            state = State::SInlineAttrDquoteEsc;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SInlineAttrDquoteEsc => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SInlineContent;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        _ => {
                            self.advance();
                            state = State::SInlineAttrDquoteContent;
                        }
                        }
                    }
                }
                State::SInlineAttrSquote => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            self.mark();
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SInlineAttrAfterValue;
                        }
                        _ => {
                            self.mark();
                            state = State::SInlineAttrSquoteContent;
                        }
                        }
                    }
                }
                State::SInlineAttrSquoteContent => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SInlineContent;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SInlineAttrAfterValue;
                        }
                        b'\\' => {
                            self.advance();
                            state = State::SInlineAttrSquoteEsc;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SInlineAttrSquoteEsc => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SInlineContent;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        _ => {
                            self.advance();
                            state = State::SInlineAttrSquoteContent;
                        }
                        }
                    }
                }
                State::SInlineAttrBare => {
                    if self.eof() {
                        self.emit_typed_value();
                        state = State::SInlineContent;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.emit_typed_value();
                            state = State::SChildren;
                        }
                        b' ' | b'\t' => {
                            self.emit_typed_value();
                            state = State::SInlineAttrAfterValue;
                        }
                        b';' => {
                            self.emit_typed_value();
                            state = State::SElemCommentCheck;
                        }
                        b':' => {
                            self.emit_typed_value();
                            state = State::SInlineAttrKey;
                        }
                        b'|' => {
                            self.emit_typed_value();
                            self.parse_element(self.current_column());
                            state = State::SInlineContent;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SInlineAttrAfterValue => {
                    if self.eof() {
                        state = State::SInlineContent;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            state = State::SChildren;
                        }
                        b';' => {
                            state = State::SElemCommentCheck;
                        }
                        b':' => {
                            state = State::SInlineAttrKey;
                        }
                        b' ' | b'\t' => {
                            self.advance();
                        }
                        b'|' => {
                            self.parse_element(self.current_column());
                            state = State::SInlineContent;
                        }
                        _ => {
                            self.mark();
                            state = State::SInlineText;
                        }
                        }
                    }
                }
                State::SChildren => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.advance();
                            state = State::SChildren;
                        }
                        b' ' => {
                            self.advance();
                            state = State::SChildren;
                        }
                        b'\t' => {
                            self.advance();
                            self.emit(StreamingEvent::Error { message: "no tabs".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            state = State::SSkipChild;
                        }
                        _ => {
                            state = State::SChildrenContent;
                        }
                        }
                    }
                }
                State::SChildrenContent => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if self.current_column()  <=  elem_col {
    self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
    return;
}
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            self.advance();
                            state = State::SChildEscaped;
                        }
                        b';' => {
                            self.advance();
                            self.mark();
                            state = State::SChildBlockComment;
                        }
                        b'|' => {
                            self.advance();
                            self.parse_element(self.current_column());
                            state = State::SChildrenAfterElement;
                        }
                        b':' => {
                            self.advance();
                            state = State::SAttrKey;
                        }
                        b'`' => {
                            self.advance();
                            state = State::SChildFreeformCheck;
                        }
                        b'!' => {
                            self.advance();
                            state = State::SChildDirective;
                        }
                        _ => {
                            self.mark();
                            state = State::SChildProse;
                        }
                        }
                    }
                }
                State::SChildrenAfterElement => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.advance();
                            state = State::SChildren;
                        }
                        b' ' => {
                            self.advance();
                            state = State::SChildrenCountWs;
                        }
                        b'\t' => {
                            self.advance();
                            self.emit(StreamingEvent::Error { message: "no tabs".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            state = State::SSkipChild;
                        }
                        _ => {
                            state = State::SChildrenContent;
                        }
                        }
                    }
                }
                State::SChildrenCountWs => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.advance();
                            state = State::SChildren;
                        }
                        b' ' => {
                            self.advance();
                            state = State::SChildrenCountWs;
                        }
                        b'\t' => {
                            self.advance();
                            self.emit(StreamingEvent::Error { message: "no tabs".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            state = State::SSkipChild;
                        }
                        _ => {
                            state = State::SChildrenContent;
                        }
                        }
                    }
                }
                State::SChildEscaped => {
                    if self.eof() {
                        { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.advance();
                            state = State::SChildren;
                        }
                        _ => {
                            self.mark();
                            state = State::SChildEscapedText;
                        }
                        }
                    }
                }
                State::SChildEscapedText => {
                    // SIMD-optimized: scan to newline in bulk
                    if self.scan_until_newline() {
                        { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                        self.advance();
                        state = State::SChildren;
                    } else {
                        // EOF
                        { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                }
                State::SChildProse => {
                    // SIMD-optimized: scan to next terminator in bulk
                    match self.scan_prose() {
                        Some(b'\n') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.advance();
                            state = State::SChildren;
                        }
                        Some(b';') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.advance();
                            state = State::SChildCommentCheck;
                        }
                        Some(b'|') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.advance();
                            self.parse_element(self.current_column());
                            state = State::SChildrenAfterElement;
                        }
                        Some(_) => unreachable!(),
                        None => {
                            // EOF
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                    }
                }
                State::SChildCommentCheck => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'{' => {
                            self.advance();
                            state = State::SChildInlineComment;
                        }
                        _ => {
                            self.mark();
                            state = State::SChildLineComment;
                        }
                        }
                    }
                }
                State::SChildInlineComment => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'}' => {
                            self.advance();
                            state = State::SChildProse;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SChildLineComment => {
                    if self.eof() {
                        { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Comment { content, span }); }
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Comment { content, span }); }
                            self.advance();
                            state = State::SChildren;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SChildBlockComment => {
                    if self.eof() {
                        { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Comment { content, span }); }
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Comment { content, span }); }
                            self.advance();
                            state = State::SChildren;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SChildFreeformCheck => {
                    if self.eof() {
                        { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'`' => {
                            self.advance();
                            state = State::SChildFreeformCheck2;
                        }
                        _ => {
                            self.mark();
                            state = State::SChildProse;
                        }
                        }
                    }
                }
                State::SChildFreeformCheck2 => {
                    if self.eof() {
                        { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'`' => {
                            self.mark();
                            state = State::SChildFreeform;
                        }
                        _ => {
                            self.mark();
                            state = State::SChildProse;
                        }
                        }
                    }
                }
                State::SChildFreeform => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed freeform".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'`' => {
                            self.advance();
                            state = State::SChildFreeformEnd1;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SChildFreeformEnd1 => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed freeform".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'`' => {
                            self.advance();
                            state = State::SChildFreeformEnd2;
                        }
                        _ => {
                            self.advance();
                            state = State::SChildFreeform;
                        }
                        }
                    }
                }
                State::SChildFreeformEnd2 => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed freeform".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'`' => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::RawContent { content, span }); }
                            state = State::SChildren;
                        }
                        _ => {
                            self.advance();
                            state = State::SChildFreeform;
                        }
                        }
                    }
                }
                State::SChildDirective => {
                    if self.eof() {
                        // TODO: emit Directive
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'{' => {
                            self.mark();
                            state = State::SChildDirectiveInterp;
                        }
                        _ => {
                            self.mark();
                            state = State::SChildDirectiveName;
                        }
                        }
                    }
                }
                State::SChildDirectiveInterp => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'}' => {
                            { let expression = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Interpolation { expression, span }); }
                            state = State::SChildProse;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SChildDirectiveName => {
                    if self.eof() {
                        // TODO: emit Directive
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            // TODO: emit Directive
                            self.advance();
                            state = State::SChildren;
                        }
                        b'{' => {
                            // TODO: emit Directive
                            state = State::SChildDirectiveBody;
                        }
                        b' ' | b'\t' => {
                            // TODO: emit Directive
                            state = State::SChildProse;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SChildDirectiveBody => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'}' => {
                            // TODO: emit DirectiveBody
                            state = State::SChildProse;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SSkipChild => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.advance();
                            state = State::SChildren;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SAttrKey => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "expected attr key".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b if self.is_label_start(b) => {
                            self.mark();
                            state = State::SAttrKeyScan;
                        }
                        b'\'' => {
                            self.advance();
                            state = State::SAttrKeyQuoted;
                        }
                        _ => {
                            self.emit(StreamingEvent::Error { message: "expected attr key".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            state = State::SChildren;
                        }
                        }
                    }
                }
                State::SAttrKeyScan => {
                    if self.eof() {
                        { let key = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Attribute { key, span }); }
                        state = State::SAttrWs;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b if self.is_label_continue(b) => {
                            self.advance();
                        }
                        _ => {
                            { let key = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Attribute { key, span }); }
                            state = State::SAttrWs;
                        }
                        }
                    }
                }
                State::SAttrKeyQuoted => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed quote".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            self.mark();
                            { let key = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Attribute { key, span }); }
                            self.advance();
                            state = State::SAttrWs;
                        }
                        _ => {
                            self.mark();
                            state = State::SAttrKeyQuotedContent;
                        }
                        }
                    }
                }
                State::SAttrKeyQuotedContent => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed quote".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            { let key = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Attribute { key, span }); }
                            state = State::SAttrWs;
                        }
                        b'\\' => {
                            self.advance();
                            state = State::SAttrKeyQuotedEsc;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SAttrKeyQuotedEsc => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed quote".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        _ => {
                            self.advance();
                            state = State::SAttrKeyQuotedContent;
                        }
                        }
                    }
                }
                State::SAttrWs => {
                    if self.eof() {
                        state = State::SAttrValue;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b' ' | b'\t' => {
                            self.advance();
                        }
                        _ => {
                            state = State::SAttrValue;
                        }
                        }
                    }
                }
                State::SAttrValue => {
                    if self.eof() {
                        { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                        state = State::SChildren;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            state = State::SChildren;
                        }
                        b';' => {
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            state = State::SAttrComment;
                        }
                        b'[' => {
                            self.emit(StreamingEvent::ArrayStart { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            self.parse_array();
                            state = State::SAttrAfterValue;
                        }
                        b'"' => {
                            self.advance();
                            state = State::SAttrDquote;
                        }
                        b'\'' => {
                            self.advance();
                            state = State::SAttrSquote;
                        }
                        _ => {
                            self.mark();
                            state = State::SAttrBare;
                        }
                        }
                    }
                }
                State::SAttrComment => {
                    if self.eof() {
                        state = State::SChildren;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            state = State::SChildren;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SAttrDquote => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'"' => {
                            self.mark();
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SAttrAfterValue;
                        }
                        _ => {
                            self.mark();
                            state = State::SAttrDquoteContent;
                        }
                        }
                    }
                }
                State::SAttrDquoteContent => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SChildren;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'"' => {
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SAttrAfterValue;
                        }
                        b'\\' => {
                            self.advance();
                            state = State::SAttrDquoteEsc;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SAttrDquoteEsc => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SChildren;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        _ => {
                            self.advance();
                            state = State::SAttrDquoteContent;
                        }
                        }
                    }
                }
                State::SAttrSquote => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            self.mark();
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SAttrAfterValue;
                        }
                        _ => {
                            self.mark();
                            state = State::SAttrSquoteContent;
                        }
                        }
                    }
                }
                State::SAttrSquoteContent => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SChildren;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SAttrAfterValue;
                        }
                        b'\\' => {
                            self.advance();
                            state = State::SAttrSquoteEsc;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SAttrSquoteEsc => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SChildren;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        _ => {
                            self.advance();
                            state = State::SAttrSquoteContent;
                        }
                        }
                    }
                }
                State::SAttrBare => {
                    if self.eof() {
                        self.emit_typed_value();
                        state = State::SChildren;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.emit_typed_value();
                            state = State::SChildren;
                        }
                        b';' => {
                            self.emit_typed_value();
                            state = State::SAttrComment;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SAttrAfterValue => {
                    if self.eof() {
                        state = State::SChildren;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            state = State::SChildren;
                        }
                        b';' => {
                            state = State::SAttrComment;
                        }
                        b' ' | b'\t' => {
                            self.advance();
                        }
                        _ => {
                            self.emit(StreamingEvent::Error { message: "unexpected after value".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            state = State::SAttrSkipLine;
                        }
                        }
                    }
                }
                State::SAttrSkipLine => {
                    if self.eof() {
                        state = State::SChildren;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            state = State::SChildren;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
            }
        }
    }

    fn parse_array(&mut self) {
        #[derive(Clone, Copy)]
        enum State { SValues, SDquote, SDquoteContent, SDquoteEsc, SSquote, SSquoteContent, SSquoteEsc, SBare }

        let mut state = State::SValues;
        loop {
            match state {
                State::SValues => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed array".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b' ' | b'\t' => {
                            self.advance();
                        }
                        b'\n' => {
                            self.advance();
                        }
                        b']' => {
                            self.emit(StreamingEvent::ArrayEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            return;
                        }
                        b'"' => {
                            self.advance();
                            state = State::SDquote;
                        }
                        b'\'' => {
                            self.advance();
                            state = State::SSquote;
                        }
                        b'[' => {
                            self.emit(StreamingEvent::ArrayStart { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            self.parse_array();
                            state = State::SValues;
                        }
                        _ => {
                            self.mark();
                            state = State::SBare;
                        }
                        }
                    }
                }
                State::SDquote => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'"' => {
                            self.mark();
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SValues;
                        }
                        _ => {
                            self.mark();
                            state = State::SDquoteContent;
                        }
                        }
                    }
                }
                State::SDquoteContent => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'"' => {
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SValues;
                        }
                        b'\\' => {
                            self.advance();
                            state = State::SDquoteEsc;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SDquoteEsc => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        _ => {
                            self.advance();
                            state = State::SDquoteContent;
                        }
                        }
                    }
                }
                State::SSquote => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            self.mark();
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SValues;
                        }
                        _ => {
                            self.mark();
                            state = State::SSquoteContent;
                        }
                        }
                    }
                }
                State::SSquoteContent => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SValues;
                        }
                        b'\\' => {
                            self.advance();
                            state = State::SSquoteEsc;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SSquoteEsc => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        _ => {
                            self.advance();
                            state = State::SSquoteContent;
                        }
                        }
                    }
                }
                State::SBare => {
                    if self.eof() {
                        self.emit_typed_value();
                        self.emit(StreamingEvent::Error { message: "unclosed array".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b' ' | b'\t' | b'\n' => {
                            self.emit_typed_value();
                            state = State::SValues;
                        }
                        b']' => {
                            self.emit_typed_value();
                            self.emit(StreamingEvent::ArrayEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            return;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
            }
        }
    }
}

// ========== Batch Parser (DEPRECATED) ==========
//
// TODO: Remove this once all tests migrate to StreamingParser.
// The old Parser<'a> API with borrowed events is no longer generated.
// Tests should use StreamingParser directly.

/// Deprecated batch parser - use StreamingParser instead.
#[deprecated(note = "Use StreamingParser directly")]
pub struct Parser<'a> {
    _phantom: std::marker::PhantomData<&'a ()>,
}

impl<'a> Parser<'a> {
    /// Create a new parser - DEPRECATED, use StreamingParser::new() instead.
    #[deprecated(note = "Use StreamingParser::new() instead")]
    pub fn new(_input: &'a [u8]) -> Self {
        Self { _phantom: std::marker::PhantomData }
    }

    /// Parse - DEPRECATED, use StreamingParser::feed() + finish() + read() instead.
    #[deprecated(note = "Use StreamingParser feed/finish/read API instead")]
    pub fn parse(&mut self) -> Vec<crate::event::Event<'a>> {
        panic!("Parser is deprecated. Use StreamingParser instead. See tests/parsing.rs for examples.")
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_streaming_parser_creation() {
        let parser = StreamingParser::new(64);
        assert!(parser.is_done() == false);
        assert_eq!(parser.available(), 0);
    }

    #[test]
    fn test_streaming_parser_simple_text() {
        let mut parser = StreamingParser::new(64);

        // Feed some simple text
        let result = parser.feed(b"Hello world\n");
        println!("Feed result: {:?}", result);
        println!("Events available: {}", parser.available());

        // Finish parsing
        parser.finish();

        // Check what events we got
        let mut events = Vec::new();
        while let Some(event) = parser.read() {
            println!("Event: {:?}", event);
            events.push(event);
        }

        println!("Total events: {}", events.len());
        assert!(!events.is_empty(), "Should have at least one event");
    }

    #[test]
    fn test_streaming_parser_element() {
        let mut parser = StreamingParser::new(64);

        // Feed an element
        let result = parser.feed(b"|div Hello\n");
        println!("Feed result: {:?}", result);

        parser.finish();

        let mut events = Vec::new();
        while let Some(event) = parser.read() {
            println!("Event: {:?}", event);
            events.push(event);
        }

        println!("Total events: {}", events.len());

        // Should have ElementStart, Text, ElementEnd
        let has_element_start = events.iter().any(|e| matches!(e, StreamingEvent::ElementStart { .. }));
        assert!(has_element_start, "Should have ElementStart event");
    }
}
