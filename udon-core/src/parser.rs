//! Generated parser - DO NOT EDIT
//!
//! Generated by descent from udon.desc
//!
//! Callback-based recursive descent parser.
//! Call stack = element stack. True recursion handles nesting naturally.

use std::ops::Range;
/// Events emitted by the parser.
#[derive(Debug, Clone, PartialEq)]
pub enum Event<'a> {
    ElementStart { span: Range<usize> },
    ElementEnd { span: Range<usize> },
    EmbeddedStart { span: Range<usize> },
    EmbeddedEnd { span: Range<usize> },
    DirectiveStart { span: Range<usize> },
    DirectiveEnd { span: Range<usize> },
    ArrayStart { span: Range<usize> },
    ArrayEnd { span: Range<usize> },
    FreeformStart { span: Range<usize> },
    FreeformEnd { span: Range<usize> },
    Name { content: &'a [u8], span: Range<usize> },
    Text { content: &'a [u8], span: Range<usize> },
    Comment { content: &'a [u8], span: Range<usize> },
    Attr { content: &'a [u8], span: Range<usize> },
    StringValue { content: &'a [u8], span: Range<usize> },
    BareValue { content: &'a [u8], span: Range<usize> },
    BoolTrue { content: &'a [u8], span: Range<usize> },
    BoolFalse { content: &'a [u8], span: Range<usize> },
    Nil { content: &'a [u8], span: Range<usize> },
    Interpolation { content: &'a [u8], span: Range<usize> },
    Reference { content: &'a [u8], span: Range<usize> },
    RawContent { content: &'a [u8], span: Range<usize> },
    Raw { content: &'a [u8], span: Range<usize> },
    Error { code: ParseErrorCode, span: Range<usize> },
}
impl<'a> Event<'a> {
    /// Format event as a single line for test output.
    pub fn format_line(&self) -> String {
        match self {
            Event::ElementStart { span } => {
                format!("ElementStart @ {}..{}", span.start, span.end)
            }
            Event::ElementEnd { span } => {
                format!("ElementEnd @ {}..{}", span.start, span.end)
            }
            Event::EmbeddedStart { span } => {
                format!("EmbeddedStart @ {}..{}", span.start, span.end)
            }
            Event::EmbeddedEnd { span } => {
                format!("EmbeddedEnd @ {}..{}", span.start, span.end)
            }
            Event::DirectiveStart { span } => {
                format!("DirectiveStart @ {}..{}", span.start, span.end)
            }
            Event::DirectiveEnd { span } => {
                format!("DirectiveEnd @ {}..{}", span.start, span.end)
            }
            Event::ArrayStart { span } => {
                format!("ArrayStart @ {}..{}", span.start, span.end)
            }
            Event::ArrayEnd { span } => {
                format!("ArrayEnd @ {}..{}", span.start, span.end)
            }
            Event::FreeformStart { span } => {
                format!("FreeformStart @ {}..{}", span.start, span.end)
            }
            Event::FreeformEnd { span } => {
                format!("FreeformEnd @ {}..{}", span.start, span.end)
            }
            Event::Name { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("Name {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::Text { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("Text {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::Comment { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("Comment {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::Attr { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("Attr {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::StringValue { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("StringValue {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::BareValue { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("BareValue {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::BoolTrue { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("BoolTrue {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::BoolFalse { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("BoolFalse {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::Nil { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("Nil {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::Interpolation { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("Interpolation {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::Reference { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("Reference {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::RawContent { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("RawContent {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::Raw { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("Raw {:?} @ {}..{}", s, span.start, span.end)
            }
            Event::Error { code, span } => {
                format!("Error {:?} @ {}..{}", code, span.start, span.end)
            }
        }
    }
}

/// Error codes for parse errors.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ParseErrorCode {
    UnexpectedEof,
    UnexpectedChar,
    Unclosed,
    UnclosedArray,
    UnclosedComment,
    UnclosedText,
    UnclosedDirective,
    NoTabs,
}

/// Callback-based parser.
///
/// Uses true recursive descent - the call stack IS the element stack.

pub struct Parser<'a> {
    input: &'a [u8],
    pos: usize,
    mark_pos: usize,
    term_pos: usize,
    line: u32,
    column: u32,
}

#[allow(unused_variables)]
impl<'a> Parser<'a> {
    /// Create a new parser for the given input.
    pub fn new(input: &'a [u8]) -> Self {
        Self {
            input,
            pos: 0,
            mark_pos: 0,
            term_pos: 0,
            line: 1,
            column: 1,
        }
    }

    /// Parse the input, calling the callback for each event.
    ///
    /// The callback receives events in document order.
    /// For backpressure, have the callback send to a bounded channel.
    pub fn parse<F>(mut self, mut on_event: F)
    where
        F: FnMut(Event<'a>),
    {
        self.parse_document(&mut on_event);
    }

    // ========== Helpers ==========
    #[inline(always)]
    fn peek(&self) -> Option<u8> {
        self.input.get(self.pos).copied()
    }

    #[inline(always)]
    fn eof(&self) -> bool {
        self.pos >= self.input.len()
    }

    #[inline(always)]
    fn advance(&mut self) {
        if self.pos < self.input.len() {
            if self.input[self.pos] == b'\n' {
                self.line += 1;
                self.column = 1;
            } else {
                self.column += 1;
            }
            self.pos += 1;
        }
    }

    #[inline(always)]
    fn mark(&mut self) {
        self.mark_pos = self.pos;
        self.term_pos = self.pos; // Reset term position
    }

    /// Set termination point with optional offset (e.g., -1 for one char before current)
    /// Clamps to valid range [0, input.len()] to prevent underflow/overflow.
    #[inline(always)]
    fn set_term(&mut self, offset: i32) {
        let new_pos = self.pos as i64 + offset as i64;
        self.term_pos = new_pos.clamp(0, self.input.len() as i64) as usize;
    }

    #[inline(always)]
    fn term(&self) -> &'a [u8] {
        // Use term_pos if set after mark, otherwise use current pos
        let end = if self.term_pos > self.mark_pos { self.term_pos } else { self.pos };
        &self.input[self.mark_pos..end]
    }

    #[inline(always)]
    fn span(&self) -> Range<usize> {
        self.pos..self.pos
    }

    #[inline(always)]
    fn span_from_mark(&self) -> Range<usize> {
        // Use term_pos if set after mark, otherwise use current pos
        let end = if self.term_pos > self.mark_pos { self.term_pos } else { self.pos };
        self.mark_pos..end
    }

    #[inline(always)]
    fn col(&self) -> i32 {
        self.column as i32
    }

    /// Previous byte (0 at start of input).
    #[inline(always)]
    fn prev(&self) -> u8 {
        if self.pos > 0 {
            self.input[self.pos - 1]
        } else {
            0
        }
    }

    #[inline(always)]
    fn is_letter(b: u8) -> bool {
        b.is_ascii_alphabetic()
    }

    #[inline(always)]
    fn is_label_cont(b: u8) -> bool {
        b.is_ascii_alphanumeric() || b == b'_' || b == b'-'
    }

    #[inline(always)]
    fn is_digit(b: u8) -> bool {
        b.is_ascii_digit()
    }

    #[inline(always)]
    fn is_hex_digit(b: u8) -> bool {
        b.is_ascii_hexdigit()
    }

    // ========== SCAN Methods (SIMD-accelerated via memchr) ==========
    /// Scan forward to find first occurrence of b1, returns matched byte or None for EOF.
    #[inline]
    fn scan_to1(&mut self, b1: u8) -> Option<u8> {
        match memchr::memchr(b1, &self.input[self.pos..]) {
            Some(offset) => {
                // Update line/column for skipped chars
                for &b in &self.input[self.pos..self.pos + offset] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos += offset;
                Some(self.input[self.pos])
            }
            None => {
                // Advance to end
                for &b in &self.input[self.pos..] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos = self.input.len();
                None
            }
        }
    }

    /// Scan forward to find first occurrence of b1 or b2.
    #[inline]
    fn scan_to2(&mut self, b1: u8, b2: u8) -> Option<u8> {
        match memchr::memchr2(b1, b2, &self.input[self.pos..]) {
            Some(offset) => {
                for &b in &self.input[self.pos..self.pos + offset] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos += offset;
                Some(self.input[self.pos])
            }
            None => {
                for &b in &self.input[self.pos..] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos = self.input.len();
                None
            }
        }
    }

    /// Scan forward to find first occurrence of b1, b2, or b3.
    #[inline]
    fn scan_to3(&mut self, b1: u8, b2: u8, b3: u8) -> Option<u8> {
        match memchr::memchr3(b1, b2, b3, &self.input[self.pos..]) {
            Some(offset) => {
                for &b in &self.input[self.pos..self.pos + offset] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos += offset;
                Some(self.input[self.pos])
            }
            None => {
                for &b in &self.input[self.pos..] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos = self.input.len();
                None
            }
        }
    }

    /// Scan forward to find first occurrence of b1, b2, b3, or b4 (chained memchr).
    #[inline]
    fn scan_to4(&mut self, b1: u8, b2: u8, b3: u8, b4: u8) -> Option<u8> {
        let haystack = &self.input[self.pos..];
        let p1 = memchr::memchr3(b1, b2, b3, haystack);
        let p2 = memchr::memchr(b4, haystack);
        let offset = match (p1, p2) {
            (Some(x), Some(y)) => Some(x.min(y)),
            (Some(x), None) | (None, Some(x)) => Some(x),
            (None, None) => None,
        };
        self.apply_scan_offset(offset)
    }

    /// Scan forward to find first occurrence of b1..b5 (chained memchr).
    #[inline]
    fn scan_to5(&mut self, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8) -> Option<u8> {
        let haystack = &self.input[self.pos..];
        let p1 = memchr::memchr3(b1, b2, b3, haystack);
        let p2 = memchr::memchr2(b4, b5, haystack);
        let offset = match (p1, p2) {
            (Some(x), Some(y)) => Some(x.min(y)),
            (Some(x), None) | (None, Some(x)) => Some(x),
            (None, None) => None,
        };
        self.apply_scan_offset(offset)
    }

    /// Scan forward to find first occurrence of b1..b6 (chained memchr).
    #[inline]
    fn scan_to6(&mut self, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8) -> Option<u8> {
        let haystack = &self.input[self.pos..];
        let p1 = memchr::memchr3(b1, b2, b3, haystack);
        let p2 = memchr::memchr3(b4, b5, b6, haystack);
        let offset = match (p1, p2) {
            (Some(x), Some(y)) => Some(x.min(y)),
            (Some(x), None) | (None, Some(x)) => Some(x),
            (None, None) => None,
        };
        self.apply_scan_offset(offset)
    }

    /// Apply scan offset result, updating position and line/column.
    #[inline]
    fn apply_scan_offset(&mut self, offset: Option<usize>) -> Option<u8> {
        match offset {
            Some(off) => {
                for &b in &self.input[self.pos..self.pos + off] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos += off;
                Some(self.input[self.pos])
            }
            None => {
                for &b in &self.input[self.pos..] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos = self.input.len();
                None
            }
        }
    }

    // ========== Generated Parse Functions ==========
    /// Parse document
    fn parse_document<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        let mut col: i32 = 0;
        #[derive(Clone, Copy)]
        enum State { Line, Dispatch, CheckPipe,  }
        let mut state = State::Line;
        loop {
            match state {
                State::Line => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b'\n') => {
                    self.advance();
                    continue;
                        }
                        Some(b' ') => {
                    col = self.parse_count_indent(on_event);
                    state = State::Dispatch;
                    continue;
                        }
                        Some(b'\t') => {
                    on_event(Event::Error { code: ParseErrorCode::NoTabs, span: self.span() });
                    return;
                    self.scan_to1(b'\n');
                    state = State::Line;
                    continue;
                        }
                        _ => {
                    col = 0;
                    state = State::Dispatch;
                    continue;
                        }
                    }
                }
                State::Dispatch => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b'|') => {
                    self.advance();
                    state = State::CheckPipe;
                    continue;
                        }
                        Some(b':') => {
                    self.advance();
                    self.parse_block_attr(on_event);
                    state = State::Line;
                    continue;
                        }
                        Some(b'!') => {
                    self.advance();
                    self.parse_block_directive(col, on_event);
                    state = State::Line;
                    continue;
                        }
                        Some(b';') => {
                    self.advance();
                    self.parse_line_comment(on_event);
                    state = State::Line;
                    continue;
                        }
                        Some(b'\'') => {
                    self.advance();
                    self.parse_prose(col, -1, on_event);
                    state = State::Line;
                    continue;
                        }
                        _ => {
                    self.parse_prose(col, -1, on_event);
                    state = State::Line;
                    continue;
                        }
                    }
                }
                State::CheckPipe => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b) if Self::is_letter(b) || b == b'\'' || b == b'[' || b == b'.' || b == b'?' || b == b'!' || b == b'*' || b == b'+' => {
                    self.parse_element(col, -1, on_event);
                    state = State::Line;
                    continue;
                        }
                        Some(b'{') => {
                    self.parse_embedded(on_event);
                    state = State::Line;
                    continue;
                        }
                        _ => {
                    self.parse_prose_pipe(col, -1, on_event);
                    state = State::Line;
                    continue;
                        }
                    }
                }
            }
        }
    }

    /// Parse count_indent -> INT
    fn parse_count_indent<F>(&mut self, on_event: &mut F) -> i32
    where
        F: FnMut(Event<'a>),
    {
        let mut result: i32 = 0;
        loop {
            if self.eof() {
                return 0;
            }
            match self.peek() {
                Some(b' ') => {
                    self.advance();
                    result += 1;
                    continue;
                }
                _ => {
                    return result;
                }
            }
        }
    }

    /// Parse parse_element_identity
    fn parse_parse_element_identity<F>(&mut self, close: u8, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        #[derive(Clone, Copy)]
        enum State { Identity, QuotedName, PostName, Bracket, BracketClose, PostBracket, Class, PostClass,  }
        let mut state = State::Identity;
        loop {
            match state {
                State::Identity => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b) if b == close => {
                    return;
                        }
                        Some(b) if Self::is_letter(b) => {
                    self.parse_name(on_event);
                    state = State::PostName;
                    continue;
                        }
                        Some(b'\'') => {
                    self.advance();
                    state = State::QuotedName;
                    continue;
                        }
                        Some(b'[') => {
                    state = State::Bracket;
                    continue;
                        }
                        Some(b'.') => {
                    state = State::Class;
                    continue;
                        }
                        Some(b'?' | b'!' | b'*' | b'+') => {
                    self.parse_suffix(on_event);
                    return;
                        }
                        _ => {
                    return;
                        }
                    }
                }
                State::QuotedName => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b'\'') => {
                    self.advance();
                    state = State::PostName;
                    continue;
                        }
                        _ => {
                    self.parse_quoted_name(on_event);
                    state = State::PostName;
                    continue;
                        }
                    }
                }
                State::PostName => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b) if b == close => {
                    return;
                        }
                        Some(b'[') => {
                    self.advance();
                    state = State::Bracket;
                    continue;
                        }
                        Some(b'.') => {
                    state = State::Class;
                    continue;
                        }
                        Some(b'?' | b'!' | b'*' | b'+') => {
                    self.parse_suffix(on_event);
                    return;
                        }
                        _ => {
                    return;
                        }
                    }
                }
                State::Bracket => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b']') => {
                    self.advance();
                    state = State::PostBracket;
                    continue;
                        }
                        _ => {
                    on_event(Event::Attr { content: b"$id", span: self.span() });
                    self.parse_value(on_event);
                    state = State::BracketClose;
                    continue;
                        }
                    }
                }
                State::BracketClose => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b']') => {
                    self.advance();
                    state = State::PostBracket;
                    continue;
                        }
                        _ => {
                    return;
                        }
                    }
                }
                State::PostBracket => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b) if b == close => {
                    return;
                        }
                        Some(b'.') => {
                    state = State::Class;
                    continue;
                        }
                        Some(b'?' | b'!' | b'*' | b'+') => {
                    self.parse_suffix(on_event);
                    return;
                        }
                        _ => {
                    return;
                        }
                    }
                }
                State::Class => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b'.') => {
                    self.advance();
                    continue;
                        }
                        Some(b) if Self::is_letter(b) => {
                    on_event(Event::Attr { content: b"$class", span: self.span() });
                    self.parse_class_name(on_event);
                    state = State::PostClass;
                    continue;
                        }
                        Some(b'\'') => {
                    on_event(Event::Attr { content: b"$class", span: self.span() });
                    self.advance();
                    self.parse_quoted_class(on_event);
                    state = State::PostClass;
                    continue;
                        }
                        _ => {
                    return;
                        }
                    }
                }
                State::PostClass => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b) if b == close => {
                    return;
                        }
                        Some(b'.') => {
                    state = State::Class;
                    continue;
                        }
                        Some(b'?' | b'!' | b'*' | b'+') => {
                    self.parse_suffix(on_event);
                    return;
                        }
                        _ => {
                    return;
                        }
                    }
                }
            }
        }
    }

    /// Parse element -> Element
    fn parse_element<F>(&mut self, elem_col: i32, parent_col: i32, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        let start_span = self.span();
        on_event(Event::ElementStart { span: start_span.clone() });
        let mut col: i32 = 0;
        #[derive(Clone, Copy)]
        enum State { Identity, PostIdentity, PreContent, CheckInlinePipe, CheckInlineSemi, CheckInlineBang, PostChild, Children, CheckChild, ChildDispatch, ChildPipe,  }
        let mut state = State::Identity;
        loop {
            match state {
                State::Identity => {
                    if self.eof() {
                        on_event(Event::ElementEnd { span: self.span() });
                        return;
                    }
                    match self.peek() {
                        _ => {
                    self.parse_parse_element_identity(0, on_event);
                    state = State::PostIdentity;
                    continue;
                        }
                    }
                }
                State::PostIdentity => {
                    if self.eof() {
                        on_event(Event::ElementEnd { span: self.span() });
                        return;
                    }
                    match self.peek() {
                        Some(b'\n') => {
                    self.advance();
                    state = State::Children;
                    continue;
                        }
                        Some(b' ' | b'\t') => {
                    self.advance();
                    state = State::PreContent;
                    continue;
                        }
                        _ => {
                    self.parse_inline_text(elem_col, on_event);
                    state = State::Children;
                    continue;
                        }
                    }
                }
                State::PreContent => {
                    if self.eof() {
                        on_event(Event::ElementEnd { span: self.span() });
                        return;
                    }
                    match self.peek() {
                        Some(b'\n') => {
                    self.advance();
                    state = State::Children;
                    continue;
                        }
                        Some(b' ' | b'\t') => {
                    self.advance();
                    continue;
                        }
                        Some(b':') => {
                    self.advance();
                    self.parse_inline_attr(on_event);
                    continue;
                        }
                        Some(b'|') => {
                    self.advance();
                    state = State::CheckInlinePipe;
                    continue;
                        }
                        Some(b';') => {
                    self.advance();
                    state = State::CheckInlineSemi;
                    continue;
                        }
                        Some(b'!') => {
                    self.advance();
                    state = State::CheckInlineBang;
                    continue;
                        }
                        _ => {
                    self.parse_inline_text(elem_col, on_event);
                    state = State::Children;
                    continue;
                        }
                    }
                }
                State::CheckInlinePipe => {
                    if self.eof() {
                        on_event(Event::ElementEnd { span: self.span() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.parse_embedded(on_event);
                    state = State::PostChild;
                    continue;
                        }
                        Some(b) if Self::is_letter(b) || b == b'\'' || b == b'[' || b == b'.' || b == b'?' || b == b'!' || b == b'*' || b == b'+' => {
                    self.parse_element(self.col(), elem_col, on_event);
                    state = State::PostChild;
                    continue;
                        }
                        _ => {
                    self.parse_inline_text_pipe(elem_col, on_event);
                    state = State::Children;
                    continue;
                        }
                    }
                }
                State::CheckInlineSemi => {
                    if self.eof() {
                        on_event(Event::ElementEnd { span: self.span() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.parse_brace_comment(on_event);
                    state = State::PreContent;
                    continue;
                        }
                        _ => {
                    self.parse_line_comment_content(on_event);
                    state = State::Children;
                    continue;
                        }
                    }
                }
                State::CheckInlineBang => {
                    if self.eof() {
                        on_event(Event::ElementEnd { span: self.span() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.advance();
                    self.parse_inline_directive(on_event);
                    state = State::PreContent;
                    continue;
                        }
                        _ => {
                    self.parse_inline_text_bang(elem_col, on_event);
                    state = State::Children;
                    continue;
                        }
                    }
                }
                State::PostChild => {
                    if self.eof() {
                        on_event(Event::ElementEnd { span: self.span() });
                        return;
                    }
                    match self.peek() {
                        Some(b'\n') => {
                    self.advance();
                    state = State::Children;
                    continue;
                        }
                        Some(b' ' | b'\t') => {
                    self.advance();
                    continue;
                        }
                        Some(b'|') => {
                    self.advance();
                    state = State::CheckInlinePipe;
                    continue;
                        }
                        _ => {
                    self.parse_inline_text(elem_col, on_event);
                    state = State::Children;
                    continue;
                        }
                    }
                }
                State::Children => {
                    if self.eof() {
                        on_event(Event::ElementEnd { span: self.span() });
                        return;
                    }
                    match self.peek() {
                        Some(b'\n') => {
                    self.advance();
                    continue;
                        }
                        Some(b' ') => {
                    col = self.parse_count_indent(on_event);
                    state = State::CheckChild;
                    continue;
                        }
                        Some(b'\t') => {
                    on_event(Event::Error { code: ParseErrorCode::NoTabs, span: self.span() });
                    return;
                    self.scan_to1(b'\n');
                    continue;
                        }
                        _ => {
                    col = 0;
                    state = State::CheckChild;
                    continue;
                        }
                    }
                }
                State::CheckChild => {
                    if self.eof() {
                        on_event(Event::ElementEnd { span: self.span() });
                        return;
                    }
                    match self.peek() {
                        _ if col <= elem_col => {
                    on_event(Event::ElementEnd { span: self.span() });
                    return;
                        }
                        _ => {
                    state = State::ChildDispatch;
                    continue;
                        }
                    }
                }
                State::ChildDispatch => {
                    if self.eof() {
                        on_event(Event::ElementEnd { span: self.span() });
                        return;
                    }
                    match self.peek() {
                        Some(b'|') => {
                    self.advance();
                    state = State::ChildPipe;
                    continue;
                        }
                        Some(b':') => {
                    self.advance();
                    self.parse_block_attr(on_event);
                    state = State::Children;
                    continue;
                        }
                        Some(b'!') => {
                    self.advance();
                    self.parse_block_directive(col, on_event);
                    state = State::Children;
                    continue;
                        }
                        Some(b';') => {
                    self.advance();
                    self.parse_line_comment(on_event);
                    state = State::Children;
                    continue;
                        }
                        Some(b'\'') => {
                    self.advance();
                    self.parse_prose(col, elem_col, on_event);
                    state = State::Children;
                    continue;
                        }
                        _ => {
                    self.parse_prose(col, elem_col, on_event);
                    state = State::Children;
                    continue;
                        }
                    }
                }
                State::ChildPipe => {
                    if self.eof() {
                        on_event(Event::ElementEnd { span: self.span() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.parse_embedded(on_event);
                    state = State::Children;
                    continue;
                        }
                        Some(b) if Self::is_letter(b) || b == b'\'' || b == b'[' || b == b'.' || b == b'?' || b == b'!' || b == b'*' || b == b'+' => {
                    self.parse_element(col, elem_col, on_event);
                    state = State::Children;
                    continue;
                        }
                        _ => {
                    self.parse_prose_pipe(col, elem_col, on_event);
                    state = State::Children;
                    continue;
                        }
                    }
                }
            }
        }
    }

    /// Parse name -> Name
    fn parse_name<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        self.mark();
        loop {
            if self.eof() {
                on_event(Event::Name { content: self.term(), span: self.span_from_mark() });
                return;
            }
            match self.peek() {
                Some(b) if Self::is_label_cont(b) => {
                    self.advance();
                    continue;
                }
                _ => {
                    self.set_term(0);
                    on_event(Event::Name { content: self.term(), span: self.span_from_mark() });
                    return;
                }
            }
        }
    }

    /// Parse skip_single_quoted
    fn parse_skip_single_quoted<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        loop {
            match self.scan_to2(b'\'', b'\\') {
                Some(b'\'') => {
                    self.advance();
                    return;
                }
                Some(b'\\') => {
                    self.advance();
                    self.advance();
                    continue;
                }
                None => {
                    on_event(Event::Error { code: ParseErrorCode::Unclosed, span: self.span() });
                    return;
                }
                _ => unreachable!("scan_to only returns target chars"),
            }
        }
    }

    /// Parse quoted_name -> Name
    fn parse_quoted_name<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        self.mark();
        loop {
            if self.eof() {
                on_event(Event::Name { content: self.term(), span: self.span_from_mark() });
                return;
            }
            match self.peek() {
                _ => {
                    self.parse_skip_single_quoted(on_event);
                    self.set_term(-1);
                    on_event(Event::Name { content: self.term(), span: self.span_from_mark() });
                    return;
                }
            }
        }
    }

    /// Parse class_name -> StringValue
    fn parse_class_name<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        self.mark();
        loop {
            if self.eof() {
                on_event(Event::StringValue { content: self.term(), span: self.span_from_mark() });
                return;
            }
            match self.peek() {
                Some(b) if Self::is_label_cont(b) => {
                    self.advance();
                    continue;
                }
                _ => {
                    self.set_term(0);
                    on_event(Event::StringValue { content: self.term(), span: self.span_from_mark() });
                    return;
                }
            }
        }
    }

    /// Parse quoted_class -> StringValue
    fn parse_quoted_class<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        self.mark();
        loop {
            if self.eof() {
                on_event(Event::StringValue { content: self.term(), span: self.span_from_mark() });
                return;
            }
            match self.peek() {
                _ => {
                    self.parse_skip_single_quoted(on_event);
                    self.set_term(-1);
                    on_event(Event::StringValue { content: self.term(), span: self.span_from_mark() });
                    return;
                }
            }
        }
    }

    /// Parse suffix
    fn parse_suffix<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        loop {
            if self.eof() {
                return;
            }
            match self.peek() {
                Some(b'?') => {
                    on_event(Event::Attr { content: b"?", span: self.span() });
                    on_event(Event::BoolTrue { content: b"", span: self.span() });
                    self.advance();
                    return;
                }
                Some(b'!') => {
                    on_event(Event::Attr { content: b"!", span: self.span() });
                    on_event(Event::BoolTrue { content: b"", span: self.span() });
                    self.advance();
                    return;
                }
                Some(b'*') => {
                    on_event(Event::Attr { content: b"*", span: self.span() });
                    on_event(Event::BoolTrue { content: b"", span: self.span() });
                    self.advance();
                    return;
                }
                Some(b'+') => {
                    on_event(Event::Attr { content: b"+", span: self.span() });
                    on_event(Event::BoolTrue { content: b"", span: self.span() });
                    self.advance();
                    return;
                }
                _ => {
                    return;
                }
            }
        }
    }

    /// Parse block_attr
    fn parse_block_attr<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        #[derive(Clone, Copy)]
        enum State { Key, ValueStart,  }
        let mut state = State::Key;
        loop {
            match state {
                State::Key => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b) if Self::is_letter(b) => {
                    self.parse_attr_key(on_event);
                    state = State::ValueStart;
                    continue;
                        }
                        Some(b'\'') => {
                    self.advance();
                    self.parse_attr_key_quoted(on_event);
                    state = State::ValueStart;
                    continue;
                        }
                        _ => {
                            return;
                        }
                    }
                }
                State::ValueStart => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b' ' | b'\t') => {
                    self.advance();
                    continue;
                        }
                        Some(b'\n') => {
                    on_event(Event::BoolTrue { content: b"", span: self.span() });
                    return;
                        }
                        _ => {
                    self.parse_value(on_event);
                    return;
                        }
                    }
                }
            }
        }
    }

    /// Parse inline_attr
    fn parse_inline_attr<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        #[derive(Clone, Copy)]
        enum State { Key, ValueStart,  }
        let mut state = State::Key;
        loop {
            match state {
                State::Key => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b) if Self::is_letter(b) => {
                    self.parse_attr_key(on_event);
                    state = State::ValueStart;
                    continue;
                        }
                        Some(b'\'') => {
                    self.advance();
                    self.parse_attr_key_quoted(on_event);
                    state = State::ValueStart;
                    continue;
                        }
                        _ => {
                            return;
                        }
                    }
                }
                State::ValueStart => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        Some(b' ' | b'\t') => {
                    self.advance();
                    continue;
                        }
                        Some(b'\n' | b':' | b'|') => {
                    on_event(Event::BoolTrue { content: b"", span: self.span() });
                    return;
                        }
                        _ => {
                    self.parse_value_inline(on_event);
                    return;
                        }
                    }
                }
            }
        }
    }

    /// Parse attr_key -> Attr
    fn parse_attr_key<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        self.mark();
        loop {
            if self.eof() {
                on_event(Event::Attr { content: self.term(), span: self.span_from_mark() });
                return;
            }
            match self.peek() {
                Some(b) if Self::is_label_cont(b) => {
                    self.advance();
                    continue;
                }
                _ => {
                    self.set_term(0);
                    on_event(Event::Attr { content: self.term(), span: self.span_from_mark() });
                    return;
                }
            }
        }
    }

    /// Parse attr_key_quoted -> Attr
    fn parse_attr_key_quoted<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        self.mark();
        loop {
            if self.eof() {
                on_event(Event::Attr { content: self.term(), span: self.span_from_mark() });
                return;
            }
            match self.peek() {
                _ => {
                    self.parse_skip_single_quoted(on_event);
                    self.set_term(-1);
                    on_event(Event::Attr { content: self.term(), span: self.span_from_mark() });
                    return;
                }
            }
        }
    }

    /// Parse value
    fn parse_value<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        loop {
            if self.eof() {
                return;
            }
            match self.peek() {
                Some(b'"') => {
                    self.advance();
                    self.parse_quoted_string(b'"', on_event);
                    return;
                }
                Some(b'\'') => {
                    self.advance();
                    self.parse_quoted_string(b'\'', on_event);
                    return;
                }
                Some(b'[') => {
                    self.parse_array(on_event);
                    return;
                }
                _ => {
                    self.parse_bare_value(on_event);
                    return;
                }
            }
        }
    }

    /// Parse value_inline
    fn parse_value_inline<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        loop {
            if self.eof() {
                return;
            }
            match self.peek() {
                Some(b'"') => {
                    self.advance();
                    self.parse_quoted_string(b'"', on_event);
                    return;
                }
                Some(b'\'') => {
                    self.advance();
                    self.parse_quoted_string(b'\'', on_event);
                    return;
                }
                Some(b'[') => {
                    self.parse_array_inline(on_event);
                    return;
                }
                _ => {
                    self.parse_bare_value_inline(on_event);
                    return;
                }
            }
        }
    }

    /// Parse quoted_string -> StringValue
    fn parse_quoted_string<F>(&mut self, quote: u8, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        self.mark();
        loop {
            match self.scan_to1(b'\\') {
                Some(b) if b == quote => {
                    self.set_term(0);
                    self.advance();
                    on_event(Event::StringValue { content: self.term(), span: self.span_from_mark() });
                    return;
                }
                Some(b'\\') => {
                    self.advance();
                    self.advance();
                    continue;
                }
                None => {
                    on_event(Event::StringValue { content: self.term(), span: self.span_from_mark() });
                    return;
                }
                _ => unreachable!("scan_to only returns target chars"),
            }
        }
    }

    /// Parse bare_value -> BareValue
    fn parse_bare_value<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        self.mark();
        loop {
            match self.scan_to2(b'\n', b' ') {
                Some(b'\n' | b' ') => {
                    self.set_term(0);
                    on_event(Event::BareValue { content: self.term(), span: self.span_from_mark() });
                    return;
                }
                None => {
                    on_event(Event::BareValue { content: self.term(), span: self.span_from_mark() });
                    return;
                }
                _ => unreachable!("scan_to only returns target chars"),
            }
        }
    }

    /// Parse bare_value_inline -> BareValue
    fn parse_bare_value_inline<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        self.mark();
        loop {
            match self.scan_to4(b'\n', b' ', b':', b'|') {
                Some(b'\n' | b' ' | b':' | b'|') => {
                    self.set_term(0);
                    on_event(Event::BareValue { content: self.term(), span: self.span_from_mark() });
                    return;
                }
                None => {
                    on_event(Event::BareValue { content: self.term(), span: self.span_from_mark() });
                    return;
                }
                _ => unreachable!("scan_to only returns target chars"),
            }
        }
    }

    /// Parse array -> Array
    fn parse_array<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        let start_span = self.span();
        on_event(Event::ArrayStart { span: start_span.clone() });
        loop {
            if self.eof() {
                on_event(Event::Error { code: ParseErrorCode::UnclosedArray, span: self.span() });
                return;
            }
            match self.peek() {
                Some(b']') => {
                    self.advance();
                    on_event(Event::ArrayEnd { span: self.span() });
                    return;
                }
                Some(b' ' | b'\t' | b'\n') => {
                    self.advance();
                    continue;
                }
                _ => {
                    self.parse_value(on_event);
                    continue;
                }
            }
        }
    }

    /// Parse array_inline -> Array
    fn parse_array_inline<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        let start_span = self.span();
        on_event(Event::ArrayStart { span: start_span.clone() });
        loop {
            if self.eof() {
                on_event(Event::Error { code: ParseErrorCode::UnclosedArray, span: self.span() });
                return;
            }
            match self.peek() {
                Some(b']') => {
                    self.advance();
                    on_event(Event::ArrayEnd { span: self.span() });
                    return;
                }
                Some(b' ' | b'\t' | b'\n') => {
                    self.advance();
                    continue;
                }
                _ => {
                    self.parse_value_inline(on_event);
                    continue;
                }
            }
        }
    }

    /// Parse prose
    fn parse_prose<F>(&mut self, line_col: i32, parent_col: i32, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        loop {
            if self.eof() {
                return;
            }
            match self.peek() {
                _ => {
                    self.parse_text(line_col, parent_col, 0, on_event);
                    return;
                }
            }
        }
    }

    /// Parse prose_pipe
    fn parse_prose_pipe<F>(&mut self, line_col: i32, parent_col: i32, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        loop {
            if self.eof() {
                return;
            }
            match self.peek() {
                _ => {
                    self.parse_text(line_col, parent_col, b'|', on_event);
                    return;
                }
            }
        }
    }

    /// Parse text -> Text
    fn parse_text<F>(&mut self, line_col: i32, parent_col: i32, prepend: u8, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        self.mark();
        #[derive(Clone, Copy)]
        enum State { Entry, Main, CheckPipe, CheckSemi, CheckBang,  }
        let mut state = State::Entry;
        loop {
            match state {
                State::Entry => {
                    if self.eof() {
                        on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        _ => {
                    if prepend != 0 {
                        let content: &'static [u8] = match prepend {
                            b'|' => b"|",
                            b'!' => b"!",
                            b';' => b";",
                            b':' => b":",
                            b'#' => b"#",
                            b'*' => b"*",
                            b'-' => b"-",
                            b'_' => b"_",
                            b'[' => b"[",
                            b']' => b"]",
                            b'{' => b"{",
                            b'}' => b"}",
                            b'(' => b"(",
                            b')' => b")",
                            b'<' => b"<",
                            b'>' => b">",
                            b'/' => b"/",
                            b'\\' => b"\\",
                            b'\'' => b"'",
                            b'"' => b"\"",
                            b'`' => b"`",
                            b'~' => b"~",
                            b'@' => b"@",
                            b'$' => b"$",
                            b'%' => b"%",
                            b'^' => b"^",
                            b'&' => b"&",
                            b'+' => b"+",
                            b'=' => b"=",
                            b'?' => b"?",
                            b',' => b",",
                            b'.' => b".",
                            b' ' => b" ",
                            b'\t' => b"\t",
                            b'\n' => b"\n",
                            _ => b"",
                        };
                        if !content.is_empty() {
                            on_event(Event::Text { content, span: self.span() });
                        }
                    }
                    state = State::Main;
                    continue;
                        }
                    }
                }
                State::Main => {
                    match self.scan_to4(b'\n', b'|', b';', b'!') {
                        Some(b'\n') => {
                    self.set_term(0);
                    on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        Some(b'|') => {
                    self.set_term(0);
                    self.advance();
                    state = State::CheckPipe;
                    continue;
                        }
                        Some(b';') => {
                    self.set_term(0);
                    self.advance();
                    state = State::CheckSemi;
                    continue;
                        }
                        Some(b'!') => {
                    self.set_term(0);
                    self.advance();
                    state = State::CheckBang;
                    continue;
                        }
                        None => {
                            on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                            return;
                        }
                        _ => unreachable!("scan_to only returns target chars"),
                    }
                }
                State::CheckPipe => {
                    if self.eof() {
                        on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.parse_embedded(on_event);
                    self.mark();
                    state = State::Main;
                    continue;
                        }
                        _ => {
                    self.mark();
                    // Unknown command: raw
                    // Unknown command: raw
                    state = State::Main;
                    continue;
                        }
                    }
                }
                State::CheckSemi => {
                    if self.eof() {
                        on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.parse_brace_comment(on_event);
                    self.mark();
                    state = State::Main;
                    continue;
                        }
                        _ => {
                    self.parse_line_comment_content(on_event);
                    on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                    }
                }
                State::CheckBang => {
                    if self.eof() {
                        on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.advance();
                    self.parse_inline_directive(on_event);
                    self.mark();
                    state = State::Main;
                    continue;
                        }
                        _ => {
                    self.mark();
                    on_event(Event::Text { content: b"!", span: self.span() });
                    state = State::Main;
                    continue;
                        }
                    }
                }
            }
        }
    }

    /// Parse inline_text -> Text
    fn parse_inline_text<F>(&mut self, elem_col: i32, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        self.mark();
        #[derive(Clone, Copy)]
        enum State { Main, CheckPipe, CheckSemi, CheckBang,  }
        let mut state = State::Main;
        loop {
            match state {
                State::Main => {
                    match self.scan_to4(b'\n', b'|', b';', b'!') {
                        Some(b'\n') => {
                    self.set_term(0);
                    on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        Some(b'|') => {
                    self.set_term(0);
                    self.advance();
                    state = State::CheckPipe;
                    continue;
                        }
                        Some(b';') => {
                    self.set_term(0);
                    self.advance();
                    state = State::CheckSemi;
                    continue;
                        }
                        Some(b'!') => {
                    self.set_term(0);
                    self.advance();
                    state = State::CheckBang;
                    continue;
                        }
                        None => {
                            on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                            return;
                        }
                        _ => unreachable!("scan_to only returns target chars"),
                    }
                }
                State::CheckPipe => {
                    if self.eof() {
                        on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.parse_embedded(on_event);
                    self.mark();
                    state = State::Main;
                    continue;
                        }
                        Some(b) if Self::is_letter(b) || b == b'\'' || b == b'[' || b == b'.' || b == b'?' || b == b'!' || b == b'*' || b == b'+' => {
                    self.parse_element(self.col(), elem_col, on_event);
                    self.mark();
                    state = State::Main;
                    continue;
                        }
                        _ => {
                    self.mark();
                    // Unknown command: raw
                    // Unknown command: raw
                    state = State::Main;
                    continue;
                        }
                    }
                }
                State::CheckSemi => {
                    if self.eof() {
                        on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.parse_brace_comment(on_event);
                    self.mark();
                    state = State::Main;
                    continue;
                        }
                        _ => {
                    self.set_term(0);
                    self.parse_line_comment_content(on_event);
                    on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                    }
                }
                State::CheckBang => {
                    if self.eof() {
                        on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.advance();
                    self.parse_inline_directive(on_event);
                    self.mark();
                    state = State::Main;
                    continue;
                        }
                        _ => {
                    self.mark();
                    on_event(Event::Text { content: b"!", span: self.span() });
                    state = State::Main;
                    continue;
                        }
                    }
                }
            }
        }
    }

    /// Parse inline_text_pipe -> Text
    fn parse_inline_text_pipe<F>(&mut self, elem_col: i32, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        self.mark();
        #[derive(Clone, Copy)]
        enum State { Main, CheckPipe, CheckSemi, CheckBang,  }
        let mut state = State::Main;
        loop {
            match state {
                State::Main => {
                    match self.scan_to4(b'\n', b'|', b';', b'!') {
                        Some(b'\n') => {
                    self.set_term(0);
                    on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        Some(b'|') => {
                    self.set_term(0);
                    self.advance();
                    state = State::CheckPipe;
                    continue;
                        }
                        Some(b';') => {
                    self.set_term(0);
                    self.advance();
                    state = State::CheckSemi;
                    continue;
                        }
                        Some(b'!') => {
                    self.set_term(0);
                    self.advance();
                    state = State::CheckBang;
                    continue;
                        }
                        None => {
                            on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                            return;
                        }
                        _ => unreachable!("scan_to only returns target chars"),
                    }
                }
                State::CheckPipe => {
                    if self.eof() {
                        on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.parse_embedded(on_event);
                    self.mark();
                    state = State::Main;
                    continue;
                        }
                        Some(b) if Self::is_letter(b) || b == b'\'' || b == b'[' || b == b'.' || b == b'?' || b == b'!' || b == b'*' || b == b'+' => {
                    self.parse_element(self.col(), elem_col, on_event);
                    self.mark();
                    state = State::Main;
                    continue;
                        }
                        _ => {
                    self.mark();
                    // Unknown command: raw
                    // Unknown command: raw
                    state = State::Main;
                    continue;
                        }
                    }
                }
                State::CheckSemi => {
                    if self.eof() {
                        on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.parse_brace_comment(on_event);
                    self.mark();
                    state = State::Main;
                    continue;
                        }
                        _ => {
                    self.set_term(0);
                    self.parse_line_comment_content(on_event);
                    on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                    }
                }
                State::CheckBang => {
                    if self.eof() {
                        on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.advance();
                    self.parse_inline_directive(on_event);
                    self.mark();
                    state = State::Main;
                    continue;
                        }
                        _ => {
                    self.mark();
                    on_event(Event::Text { content: b"!", span: self.span() });
                    state = State::Main;
                    continue;
                        }
                    }
                }
            }
        }
    }

    /// Parse inline_text_bang -> Text
    fn parse_inline_text_bang<F>(&mut self, elem_col: i32, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        self.mark();
        #[derive(Clone, Copy)]
        enum State { Main, CheckPipe, CheckSemi, CheckBang,  }
        let mut state = State::Main;
        loop {
            match state {
                State::Main => {
                    match self.scan_to4(b'\n', b'|', b';', b'!') {
                        Some(b'\n') => {
                    self.set_term(0);
                    on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        Some(b'|') => {
                    self.set_term(0);
                    self.advance();
                    state = State::CheckPipe;
                    continue;
                        }
                        Some(b';') => {
                    self.set_term(0);
                    self.advance();
                    state = State::CheckSemi;
                    continue;
                        }
                        Some(b'!') => {
                    self.set_term(0);
                    self.advance();
                    state = State::CheckBang;
                    continue;
                        }
                        None => {
                            on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                            return;
                        }
                        _ => unreachable!("scan_to only returns target chars"),
                    }
                }
                State::CheckPipe => {
                    if self.eof() {
                        on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.parse_embedded(on_event);
                    self.mark();
                    state = State::Main;
                    continue;
                        }
                        Some(b) if Self::is_letter(b) || b == b'\'' || b == b'[' || b == b'.' || b == b'?' || b == b'!' || b == b'*' || b == b'+' => {
                    self.parse_element(self.col(), elem_col, on_event);
                    self.mark();
                    state = State::Main;
                    continue;
                        }
                        _ => {
                    self.mark();
                    // Unknown command: raw
                    // Unknown command: raw
                    state = State::Main;
                    continue;
                        }
                    }
                }
                State::CheckSemi => {
                    if self.eof() {
                        on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.parse_brace_comment(on_event);
                    self.mark();
                    state = State::Main;
                    continue;
                        }
                        _ => {
                    self.set_term(0);
                    self.parse_line_comment_content(on_event);
                    on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                    }
                }
                State::CheckBang => {
                    if self.eof() {
                        on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.advance();
                    self.parse_inline_directive(on_event);
                    self.mark();
                    state = State::Main;
                    continue;
                        }
                        _ => {
                    self.mark();
                    on_event(Event::Text { content: b"!", span: self.span() });
                    state = State::Main;
                    continue;
                        }
                    }
                }
            }
        }
    }

    /// Parse line_comment
    fn parse_line_comment<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        loop {
            if self.eof() {
                return;
            }
            match self.peek() {
                Some(b'{') => {
                    self.parse_brace_comment(on_event);
                    return;
                }
                _ => {
                    self.parse_line_comment_content(on_event);
                    return;
                }
            }
        }
    }

    /// Parse line_comment_content -> Comment
    fn parse_line_comment_content<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        self.mark();
        loop {
            match self.scan_to1(b'\n') {
                Some(b'\n') => {
                    self.set_term(0);
                    on_event(Event::Comment { content: self.term(), span: self.span_from_mark() });
                    return;
                }
                None => {
                    on_event(Event::Comment { content: self.term(), span: self.span_from_mark() });
                    on_event(Event::Error { code: ParseErrorCode::UnclosedComment, span: self.span() });
                    return;
                }
                _ => unreachable!("scan_to only returns target chars"),
            }
        }
    }

    /// Parse skip_brace_balanced
    fn parse_skip_brace_balanced<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        let mut depth: i32 = 0;
        #[derive(Clone, Copy)]
        enum State { Main, Check,  }
        let mut state = State::Main;
        loop {
            match state {
                State::Main => {
                    match self.scan_to2(b'{', b'}') {
                        Some(b'{') => {
                    self.advance();
                    depth += 1;
                    continue;
                        }
                        Some(b'}') => {
                    self.advance();
                    depth -= 1;
                    state = State::Check;
                    continue;
                        }
                        None => {
                            return;
                        }
                        _ => unreachable!("scan_to only returns target chars"),
                    }
                }
                State::Check => {
                    if self.eof() {
                        return;
                    }
                    match self.peek() {
                        _ if depth == 0 => {
                    return;
                        }
                        _ => {
                    state = State::Main;
                    continue;
                        }
                    }
                }
            }
        }
    }

    /// Parse brace_comment -> Comment
    fn parse_brace_comment<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        self.mark();
        loop {
            if self.eof() {
                on_event(Event::Comment { content: self.term(), span: self.span_from_mark() });
                return;
            }
            match self.peek() {
                _ => {
                    self.parse_skip_brace_balanced(on_event);
                    self.set_term(-1);
                    on_event(Event::Comment { content: self.term(), span: self.span_from_mark() });
                    return;
                }
            }
        }
    }

    /// Parse embedded -> Embedded
    fn parse_embedded<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        let start_span = self.span();
        on_event(Event::EmbeddedStart { span: start_span.clone() });
        #[derive(Clone, Copy)]
        enum State { Identity, PostIdentity, PreContent,  }
        let mut state = State::Identity;
        loop {
            match state {
                State::Identity => {
                    if self.eof() {
                        on_event(Event::EmbeddedEnd { span: self.span() });
                        return;
                    }
                    match self.peek() {
                        _ => {
                    self.parse_parse_element_identity(b'}', on_event);
                    state = State::PostIdentity;
                    continue;
                        }
                    }
                }
                State::PostIdentity => {
                    if self.eof() {
                        on_event(Event::EmbeddedEnd { span: self.span() });
                        return;
                    }
                    match self.peek() {
                        Some(b'}') => {
                    self.advance();
                    on_event(Event::EmbeddedEnd { span: self.span() });
                    return;
                        }
                        Some(b' ' | b'\t') => {
                    self.advance();
                    state = State::PreContent;
                    continue;
                        }
                        _ => {
                    self.parse_embed_content(on_event);
                    on_event(Event::EmbeddedEnd { span: self.span() });
                    return;
                        }
                    }
                }
                State::PreContent => {
                    if self.eof() {
                        on_event(Event::EmbeddedEnd { span: self.span() });
                        return;
                    }
                    match self.peek() {
                        Some(b'}') => {
                    self.advance();
                    on_event(Event::EmbeddedEnd { span: self.span() });
                    return;
                        }
                        Some(b' ' | b'\t') => {
                    self.advance();
                    continue;
                        }
                        Some(b':') => {
                    self.advance();
                    self.parse_inline_attr(on_event);
                    continue;
                        }
                        _ => {
                    self.parse_embed_content(on_event);
                    on_event(Event::EmbeddedEnd { span: self.span() });
                    return;
                        }
                    }
                }
            }
        }
    }

    /// Parse embed_content -> Text
    fn parse_embed_content<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        self.mark();
        #[derive(Clone, Copy)]
        enum State { Main, CheckPipe, CheckSemi, CheckBang,  }
        let mut state = State::Main;
        loop {
            match state {
                State::Main => {
                    match self.scan_to4(b'}', b'|', b';', b'!') {
                        Some(b'}') => {
                    self.set_term(0);
                    on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                    return;
                        }
                        Some(b'|') => {
                    self.set_term(0);
                    self.advance();
                    state = State::CheckPipe;
                    continue;
                        }
                        Some(b';') => {
                    self.set_term(0);
                    self.advance();
                    state = State::CheckSemi;
                    continue;
                        }
                        Some(b'!') => {
                    self.set_term(0);
                    self.advance();
                    state = State::CheckBang;
                    continue;
                        }
                        None => {
                            on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                            on_event(Event::Error { code: ParseErrorCode::UnclosedText, span: self.span() });
                            return;
                        }
                        _ => unreachable!("scan_to only returns target chars"),
                    }
                }
                State::CheckPipe => {
                    if self.eof() {
                        on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                        on_event(Event::Error { code: ParseErrorCode::UnclosedText, span: self.span() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.parse_embedded(on_event);
                    self.mark();
                    state = State::Main;
                    continue;
                        }
                        _ => {
                    self.mark();
                    // Unknown command: raw
                    // Unknown command: raw
                    state = State::Main;
                    continue;
                        }
                    }
                }
                State::CheckSemi => {
                    if self.eof() {
                        on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                        on_event(Event::Error { code: ParseErrorCode::UnclosedText, span: self.span() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.parse_brace_comment(on_event);
                    self.mark();
                    state = State::Main;
                    continue;
                        }
                        _ => {
                    self.mark();
                    // Unknown command: raw
                        }
                    }
                }
                State::CheckBang => {
                    if self.eof() {
                        on_event(Event::Text { content: self.term(), span: self.span_from_mark() });
                        on_event(Event::Error { code: ParseErrorCode::UnclosedText, span: self.span() });
                        return;
                    }
                    match self.peek() {
                        Some(b'{') => {
                    self.advance();
                    self.parse_inline_directive(on_event);
                    self.mark();
                    state = State::Main;
                    continue;
                        }
                        _ => {
                    self.mark();
                    on_event(Event::Text { content: b"!", span: self.span() });
                    state = State::Main;
                    continue;
                        }
                    }
                }
            }
        }
    }

    /// Parse block_directive -> Directive
    fn parse_block_directive<F>(&mut self, line_col: i32, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        let start_span = self.span();
        on_event(Event::DirectiveStart { span: start_span.clone() });
        loop {
            match self.scan_to1(b'\n') {
                Some(b'\n') => {
                    on_event(Event::DirectiveEnd { span: self.span() });
                    return;
                }
                None => {
                    on_event(Event::Error { code: ParseErrorCode::UnclosedDirective, span: self.span() });
                    return;
                }
                _ => unreachable!("scan_to only returns target chars"),
            }
        }
    }

    /// Parse inline_directive -> Directive
    fn parse_inline_directive<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        let start_span = self.span();
        on_event(Event::DirectiveStart { span: start_span.clone() });
        loop {
            if self.eof() {
                on_event(Event::DirectiveEnd { span: self.span() });
                return;
            }
            match self.peek() {
                _ => {
                    self.parse_skip_brace_balanced(on_event);
                    on_event(Event::DirectiveEnd { span: self.span() });
                    return;
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_parse_basic() {
        // Basic smoke test - actual tests depend on parser semantics
        let input = b"";
        let mut events = Vec::new();
        Parser::new(input).parse(|e| events.push(e));
        // Events depend on the specific parser
    }
}
