//! UDON Streaming Parser - Generated by genmachine
//!
//! This is a generated file. Do not edit directly.
//! Source: generator/udon.machine
//!
//! This parser uses a ring buffer architecture for true streaming:
//! - Input arrives in chunks via feed()
//! - Events emit to a ring buffer as they're parsed
//! - Backpressure when buffer is full
//! - Chunk arena for zero-copy string references

use crate::span::Span;
use crate::streaming::{ChunkArena, ChunkSlice, EventRing, FeedResult, ParseErrorCode, StreamingEvent};

/// Parser state enum - persists across feed() calls.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ParserState {
    /// Initial state / document level
    Document,
    /// Need more input to complete current token
    NeedInput,
    /// Finished parsing (got finish() call)
    Finished,
    /// Inside a specific parse function
    InFunction { function: FunctionId, state: u16 },
}

/// Function identifiers for nested parsing.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FunctionId {
    Document,
    Element,
    Array,
    // Add more as needed based on DSL functions
}

/// Streaming parser with ring buffer output.
///
/// # Example
///
/// ```
/// use udon_core::StreamingParser;
///
/// let mut parser = StreamingParser::new(1024); // 1024 event capacity
///
/// // Feed chunks of input
/// parser.feed(b"|div Hello");
/// parser.feed(b" World\n");
/// parser.finish();
///
/// // Read events
/// while let Some(event) = parser.read() {
///     println!("{:?}", event);
/// }
/// ```
pub struct StreamingParser {
    // ========== State Machine ==========

    /// Current parser state
    state: ParserState,

    /// Call stack for nested function calls (element within element, etc.)
    /// Each entry is (function_id, local_state, return_state)
    call_stack: Vec<(FunctionId, u16, ParserState)>,

    // ========== Input Management ==========

    /// Arena storing input chunks (used for multi-chunk streaming and synthetic chunks)
    chunks: ChunkArena,

    /// Current chunk index being parsed
    current_chunk: u32,

    /// Cached pointer to current chunk data (hot path optimization)
    /// This avoids repeated arena lookups in peek()
    current_ptr: *const u8,
    current_len: usize,

    /// Position within current chunk
    pos: usize,

    /// Partial token buffer (for tokens split across chunks)
    partial: Vec<u8>,

    /// Whether we're continuing a partial token
    in_partial: bool,

    // ========== Position Tracking ==========

    /// Current line number (1-indexed)
    line: u32,

    /// Current column (1-indexed)
    column: u32,

    /// Position of line start (for column calculation)
    line_start: usize,

    /// Global byte offset (across all chunks)
    global_offset: u64,

    // ========== Accumulation ==========

    /// Mark position for MARK/TERM pattern
    mark_chunk: u32,
    mark_pos: u32,
    /// Column at the time mark() was called (for dedentation tracking)
    mark_column: i32,

    // ========== Indentation Tracking ==========

    /// Element stack for indentation-based hierarchy
    /// Each entry is (column, has_children)
    element_stack: Vec<(i32, bool)>,

    // ========== Output ==========

    /// Ring buffer for output events
    events: EventRing,

    /// Whether finish() has been called
    finished: bool,
}

impl StreamingParser {
    /// Create a new streaming parser with the given event buffer capacity.
    pub fn new(event_capacity: usize) -> Self {
        Self {
            state: ParserState::Document,
            call_stack: Vec::with_capacity(16),
            chunks: ChunkArena::new(),
            current_chunk: 0,
            current_ptr: std::ptr::null(),
            current_len: 0,
            pos: 0,
            partial: Vec::with_capacity(256),
            in_partial: false,
            line: 1,
            column: 1,
            line_start: 0,
            global_offset: 0,
            mark_chunk: 0,
            mark_pos: 0,
            mark_column: 1,
            element_stack: Vec::with_capacity(32),
            events: EventRing::new(event_capacity),
            finished: false,
        }
    }

    /// Create with default capacity (1024 events).
    pub fn with_default_capacity() -> Self {
        Self::new(1024)
    }

    // ========== Public API ==========

    /// Feed a chunk of input to the parser.
    ///
    /// Returns information about how much was consumed and how many events were generated.
    /// If the ring buffer fills up, parsing pauses (backpressure).
    pub fn feed(&mut self, chunk: &[u8]) -> FeedResult {
        if self.finished {
            return FeedResult {
                bytes_consumed: 0,
                events_written: 0,
                buffer_full: false,
            };
        }

        // Copy chunk to arena and update cached pointer
        let chunk_idx = self.chunks.push(chunk.to_vec());
        if let Some(c) = self.chunks.get(chunk_idx) {
            let data = c.data();
            self.current_ptr = data.as_ptr();
            self.current_len = data.len();
        }

        self.current_chunk = chunk_idx;
        self.pos = 0;

        let events_before = self.events.available();

        // Resume parsing
        self.parse_continue();

        let events_written = self.events.available() - events_before;

        FeedResult {
            bytes_consumed: self.pos,
            events_written,
            buffer_full: self.events.is_full(),
        }
    }

    /// Signal end of input stream.
    ///
    /// Flushes any pending partial tokens and emits final events.
    pub fn finish(&mut self) -> FeedResult {
        if self.finished {
            return FeedResult {
                bytes_consumed: 0,
                events_written: 0,
                buffer_full: false,
            };
        }

        self.finished = true;
        let events_before = self.events.available();

        // Emit any pending element ends
        while !self.element_stack.is_empty() {
            self.emit_element_end();
        }

        FeedResult {
            bytes_consumed: 0,
            events_written: self.events.available() - events_before,
            buffer_full: self.events.is_full(),
        }
    }

    /// Read the next event from the ring buffer.
    ///
    /// Returns None if no events are available.
    pub fn read(&mut self) -> Option<StreamingEvent> {
        self.events.pop()
    }

    /// Peek at the next event without consuming it.
    pub fn peek_event(&self) -> Option<&StreamingEvent> {
        self.events.peek()
    }

    /// Number of events available to read.
    pub fn available(&self) -> usize {
        self.events.available()
    }

    /// Check if parsing is complete (finish called and buffer drained).
    pub fn is_done(&self) -> bool {
        self.finished && self.events.is_empty()
    }

    /// Check if the ring buffer is full (backpressure).
    pub fn is_buffer_full(&self) -> bool {
        self.events.is_full()
    }

    /// Get access to the chunk arena (for resolving ChunkSlice to bytes).
    pub fn arena(&self) -> &ChunkArena {
        &self.chunks
    }

    /// Reset the parser for reuse.
    ///
    /// Clears all state but keeps allocated capacity, allowing efficient
    /// reuse of the parser across multiple parse operations.
    pub fn reset(&mut self) {
        self.state = ParserState::Document;
        self.call_stack.clear();
        self.chunks.clear();
        self.current_chunk = 0;
        self.current_ptr = std::ptr::null();
        self.current_len = 0;
        self.pos = 0;
        self.partial.clear();
        self.in_partial = false;
        self.line = 1;
        self.column = 1;
        self.line_start = 0;
        self.global_offset = 0;
        self.mark_chunk = 0;
        self.mark_pos = 0;
        self.mark_column = 1;
        self.element_stack.clear();
        self.events.clear();
        self.finished = false;
    }

    // ========== Internal Helpers ==========
    //
    // These methods provide compatibility with the generated state machine code.
    // Hot path methods use cached pointer to avoid arena lookups.

    /// Get current byte without advancing.
    #[inline(always)]
    fn peek(&self) -> Option<u8> {
        if self.pos < self.current_len {
            // SAFETY: pos < current_len, and current_ptr points to valid data
            // that lives in the arena for the duration of parsing this chunk
            Some(unsafe { *self.current_ptr.add(self.pos) })
        } else {
            None
        }
    }

    /// Get current chunk's data (uses cached pointer).
    #[inline(always)]
    fn current_chunk_data(&self) -> &[u8] {
        if self.current_ptr.is_null() {
            &[]
        } else {
            // SAFETY: current_ptr/current_len set from valid chunk data in feed()
            unsafe { std::slice::from_raw_parts(self.current_ptr, self.current_len) }
        }
    }

    /// Advance one byte.
    #[inline(always)]
    fn advance(&mut self) {
        if self.pos < self.current_len {
            // SAFETY: pos < current_len, pointer is valid
            let b = unsafe { *self.current_ptr.add(self.pos) };
            if b == b'\n' {
                self.line += 1;
                self.column = 1;
                self.pos += 1;
                self.line_start = self.pos;
            } else {
                self.column += 1;
                self.pos += 1;
            }
            self.global_offset += 1;
        }
    }

    /// Mark current position for accumulation.
    /// Also saves the current column for dedentation tracking.
    #[inline]
    fn mark(&mut self) {
        self.mark_chunk = self.current_chunk;
        self.mark_pos = self.pos as u32;
        self.mark_column = self.current_column();
    }

    /// Get accumulated slice from mark to current position.
    ///
    /// Fast path: if mark and current are in same chunk, returns direct reference.
    /// Slow path: if token spans chunks, copies bytes into a synthetic chunk.
    #[inline]
    fn term(&mut self) -> ChunkSlice {
        if self.mark_chunk == self.current_chunk {
            // Fast path: same chunk, no copy needed
            ChunkSlice::new(self.mark_chunk, self.mark_pos, self.pos as u32)
        } else {
            // Slow path: token spans multiple chunks, need to copy
            self.term_cross_chunk()
        }
    }

    /// Like term() but with an adjustment to the end position.
    /// Used for freeform blocks where we've advanced past closing backticks.
    #[inline]
    fn term_adjusted(&mut self, adjustment: i32) -> ChunkSlice {
        let adjusted_pos = (self.pos as i32 + adjustment).max(self.mark_pos as i32) as u32;
        if self.mark_chunk == self.current_chunk {
            // Fast path: same chunk, no copy needed
            ChunkSlice::new(self.mark_chunk, self.mark_pos, adjusted_pos)
        } else {
            // Slow path: token spans multiple chunks
            self.term_cross_chunk_adjusted(adjusted_pos)
        }
    }

    /// Handle token that spans multiple chunks (cold path).
    ///
    /// Copies bytes from mark position through current position across all
    /// intervening chunks, pushes as a synthetic chunk, returns slice to it.
    #[cold]
    fn term_cross_chunk(&mut self) -> ChunkSlice {
        // Reuse the partial buffer for accumulation
        self.partial.clear();

        // Copy from mark_chunk[mark_pos..end]
        if let Some(chunk) = self.chunks.get(self.mark_chunk) {
            let data = chunk.data();
            self.partial.extend_from_slice(&data[self.mark_pos as usize..]);
        }

        // Copy from any intermediate chunks (mark_chunk + 1 .. current_chunk)
        for chunk_idx in (self.mark_chunk + 1)..self.current_chunk {
            if let Some(chunk) = self.chunks.get(chunk_idx) {
                self.partial.extend_from_slice(chunk.data());
            }
        }

        // Copy from current_chunk[0..pos]
        if let Some(chunk) = self.chunks.get(self.current_chunk) {
            let data = chunk.data();
            self.partial.extend_from_slice(&data[..self.pos]);
        }

        // Push as synthetic chunk and return slice to it
        let synthetic_data = std::mem::take(&mut self.partial);
        let len = synthetic_data.len() as u32;
        let chunk_idx = self.chunks.push(synthetic_data);
        ChunkSlice::new(chunk_idx, 0, len)
    }

    /// Handle adjusted token that spans multiple chunks (cold path).
    #[cold]
    fn term_cross_chunk_adjusted(&mut self, adjusted_pos: u32) -> ChunkSlice {
        self.partial.clear();

        // Copy from mark_chunk[mark_pos..end]
        if let Some(chunk) = self.chunks.get(self.mark_chunk) {
            let data = chunk.data();
            self.partial.extend_from_slice(&data[self.mark_pos as usize..]);
        }

        // Copy from any intermediate chunks (mark_chunk + 1 .. current_chunk)
        for chunk_idx in (self.mark_chunk + 1)..self.current_chunk {
            if let Some(chunk) = self.chunks.get(chunk_idx) {
                self.partial.extend_from_slice(chunk.data());
            }
        }

        // Copy from current_chunk[0..adjusted_pos]
        if let Some(chunk) = self.chunks.get(self.current_chunk) {
            let data = chunk.data();
            let end = (adjusted_pos as usize).min(data.len());
            self.partial.extend_from_slice(&data[..end]);
        }

        let synthetic_data = std::mem::take(&mut self.partial);
        let len = synthetic_data.len() as u32;
        let chunk_idx = self.chunks.push(synthetic_data);
        ChunkSlice::new(chunk_idx, 0, len)
    }

    /// Get current column (0-indexed from line start).
    #[inline]
    fn current_column(&self) -> i32 {
        (self.pos - self.line_start) as i32
    }

    /// Create a span from mark to current position.
    #[inline]
    fn span_from_mark(&self) -> Span {
        let start = self.chunks.get(self.mark_chunk)
            .map(|c| c.stream_offset() as usize + self.mark_pos as usize)
            .unwrap_or(0);
        let end = self.chunks.get(self.current_chunk)
            .map(|c| c.stream_offset() as usize + self.pos)
            .unwrap_or(0);
        Span::new(start, end)
    }

    /// Emit an event to the ring buffer.
    #[inline]
    fn emit(&mut self, event: StreamingEvent) {
        // If buffer is full, we'd need to handle backpressure
        // For now, just push (will panic if full)
        let _ = self.events.try_push(event);
    }

    /// Emit ElementEnd event.
    fn emit_element_end(&mut self) {
        if self.element_stack.pop().is_some() {
            self.emit(StreamingEvent::ElementEnd {
                span: Span::new(self.global_offset as usize, self.global_offset as usize),
            });
        }
    }

    /// Emit special attribute for identity parsing ($id, $class, suffixes).
    /// The key is a static string (not from input), pushed to arena as synthetic chunk.
    fn emit_special_attribute(&mut self, key: &str) {
        // Push static key string to arena as synthetic chunk
        let key_bytes = key.as_bytes().to_vec();
        let chunk_idx = self.chunks.push(key_bytes);
        let len = key.len() as u32;
        let key_slice = ChunkSlice::new(chunk_idx, 0, len);
        let span = self.span_from_mark();
        self.emit(StreamingEvent::Attribute { key: key_slice, span });
    }

    /// Emit a literal "|" as text. Used when pipe in inline content is not followed
    /// by a valid element starter (per SPEC.md:645-651, | is prose unless followed
    /// by letter, [, ., {, ', or suffix).
    fn emit_pipe_text(&mut self) {
        let pipe_bytes = b"|".to_vec();
        let chunk_idx = self.chunks.push(pipe_bytes);
        let pipe_slice = ChunkSlice::new(chunk_idx, 0, 1);
        let span = Span::new(self.global_offset as usize - 1, self.global_offset as usize);
        self.emit(StreamingEvent::Text { content: pipe_slice, span });
    }

    /// Emit a literal "!" as text. Used when bang in inline content is not followed
    /// by { (meaning it's not an interpolation/directive).
    fn emit_bang_text(&mut self) {
        let bang_bytes = b"!".to_vec();
        let chunk_idx = self.chunks.push(bang_bytes);
        let bang_slice = ChunkSlice::new(chunk_idx, 0, 1);
        let span = Span::new(self.global_offset as usize - 1, self.global_offset as usize);
        self.emit(StreamingEvent::Text { content: bang_slice, span });
    }

    /// Emit dedented text with content_base tracking.
    ///
    /// Handles three cases:
    /// 1. First prose line: sets content_base, emits text as-is
    /// 2. Lesser indent: emits Warning, updates content_base, emits text
    /// 3. Greater indent: prepends extra spaces (mark_column - content_base)
    ///
    /// The content_base parameter is a mutable reference to the function-local
    /// content_base variable. A value of -1 means "not yet set".
    fn emit_dedented_text(&mut self, content_base: &mut i32) {
        let content = self.term();
        let span = self.span_from_mark();
        let mark_col = self.mark_column;

        // First prose line: set content_base
        if *content_base < 0 {
            *content_base = mark_col;
            self.emit(StreamingEvent::Text { content, span });
            return;
        }

        // Lesser indent: emit warning and update content_base
        if mark_col < *content_base {
            self.emit(StreamingEvent::Warning {
                message: "inconsistent indentation".to_string(),
                span: Span::new(span.start as usize, span.start as usize),
            });
            *content_base = mark_col;
            self.emit(StreamingEvent::Text { content, span });
            return;
        }

        // Greater indent: prepend extra spaces
        let extra_spaces = mark_col - *content_base;
        if extra_spaces > 0 {
            // Create synthetic chunk with spaces + original content
            let mut combined = vec![b' '; extra_spaces as usize];
            // Resolve original content and append
            if let Some(bytes) = self.chunks.resolve(content) {
                combined.extend_from_slice(bytes);
            }
            let combined_len = combined.len() as u32;
            let chunk_idx = self.chunks.push(combined);
            let combined_slice = ChunkSlice::new(chunk_idx, 0, combined_len);
            self.emit(StreamingEvent::Text { content: combined_slice, span });
        } else {
            // Exact match: emit as-is
            self.emit(StreamingEvent::Text { content, span });
        }
    }

    // ========== SIMD-Accelerated Scanning ==========
    //
    // These methods use memchr for fast bulk scanning. They advance position
    // and return the terminating byte (or None for EOF).

    /// Scan until one of the target bytes. Returns the found byte or None for EOF.
    #[inline]
    fn scan_to1(&mut self, b1: u8) -> Option<u8> {
        if self.pos >= self.current_len {
            return None;
        }
        let remaining = unsafe {
            std::slice::from_raw_parts(self.current_ptr.add(self.pos), self.current_len - self.pos)
        };
        match memchr::memchr(b1, remaining) {
            Some(offset) => {
                self.pos += offset;
                self.column += offset as u32;
                self.global_offset += offset as u64;
                Some(remaining[offset])
            }
            None => {
                let len = remaining.len();
                self.pos += len;
                self.column += len as u32;
                self.global_offset += len as u64;
                None
            }
        }
    }

    /// Scan until one of two target bytes. Returns the found byte or None for EOF.
    #[inline]
    fn scan_to2(&mut self, b1: u8, b2: u8) -> Option<u8> {
        if self.pos >= self.current_len {
            return None;
        }
        let remaining = unsafe {
            std::slice::from_raw_parts(self.current_ptr.add(self.pos), self.current_len - self.pos)
        };
        match memchr::memchr2(b1, b2, remaining) {
            Some(offset) => {
                self.pos += offset;
                self.column += offset as u32;
                self.global_offset += offset as u64;
                Some(remaining[offset])
            }
            None => {
                let len = remaining.len();
                self.pos += len;
                self.column += len as u32;
                self.global_offset += len as u64;
                None
            }
        }
    }

    /// Scan until one of three target bytes. Returns the found byte or None for EOF.
    #[inline]
    fn scan_to3(&mut self, b1: u8, b2: u8, b3: u8) -> Option<u8> {
        if self.pos >= self.current_len {
            return None;
        }
        let remaining = unsafe {
            std::slice::from_raw_parts(self.current_ptr.add(self.pos), self.current_len - self.pos)
        };
        match memchr::memchr3(b1, b2, b3, remaining) {
            Some(offset) => {
                self.pos += offset;
                self.column += offset as u32;
                self.global_offset += offset as u64;
                Some(remaining[offset])
            }
            None => {
                let len = remaining.len();
                self.pos += len;
                self.column += len as u32;
                self.global_offset += len as u64;
                None
            }
        }
    }

    /// Scan until one of four target bytes. Returns the found byte or None for EOF.
    /// Uses memchr3 for first 3 bytes and memchr for the 4th, taking whichever is first.
    #[inline]
    fn scan_to4(&mut self, b1: u8, b2: u8, b3: u8, b4: u8) -> Option<u8> {
        if self.pos >= self.current_len {
            return None;
        }
        let remaining = unsafe {
            std::slice::from_raw_parts(self.current_ptr.add(self.pos), self.current_len - self.pos)
        };
        // Find first occurrence of b1/b2/b3 and first occurrence of b4
        let pos_123 = memchr::memchr3(b1, b2, b3, remaining);
        let pos_4 = memchr::memchr(b4, remaining);

        // Take whichever is first
        match (pos_123, pos_4) {
            (Some(p123), Some(p4)) => {
                let offset = p123.min(p4);
                self.pos += offset;
                self.column += offset as u32;
                self.global_offset += offset as u64;
                Some(remaining[offset])
            }
            (Some(offset), None) => {
                self.pos += offset;
                self.column += offset as u32;
                self.global_offset += offset as u64;
                Some(remaining[offset])
            }
            (None, Some(offset)) => {
                self.pos += offset;
                self.column += offset as u32;
                self.global_offset += offset as u64;
                Some(b4)
            }
            (None, None) => {
                let len = remaining.len();
                self.pos += len;
                self.column += len as u32;
                self.global_offset += len as u64;
                None
            }
        }
    }

    /// Check if byte can start a LABEL.
    #[inline]
    fn is_label_start(&self, b: u8) -> bool {
        matches!(b, b'a'..=b'z' | b'A'..=b'Z' | b'_') ||
        (b >= 0x80 && self.is_unicode_letter_at(self.pos))
    }

    /// Check if byte can continue a LABEL.
    #[inline]
    fn is_label_continue(&self, b: u8) -> bool {
        matches!(b, b'a'..=b'z' | b'A'..=b'Z' | b'0'..=b'9' | b'_' | b'-') ||
        (b >= 0x80 && self.is_unicode_letter_or_number_at(self.pos))
    }

    /// Check for Unicode letter at position.
    fn is_unicode_letter_at(&self, pos: usize) -> bool {
        if let Some(slice) = self.current_chunk_data().get(pos..) {
            if let Ok(s) = std::str::from_utf8(slice) {
                if let Some(c) = s.chars().next() {
                    return unicode_xid::UnicodeXID::is_xid_start(c);
                }
            }
        }
        false
    }

    /// Check for Unicode letter or number at position.
    fn is_unicode_letter_or_number_at(&self, pos: usize) -> bool {
        if let Some(slice) = self.current_chunk_data().get(pos..) {
            if let Ok(s) = std::str::from_utf8(slice) {
                if let Some(c) = s.chars().next() {
                    return unicode_xid::UnicodeXID::is_xid_continue(c);
                }
            }
        }
        false
    }

    /// Emit a typed value based on accumulated content.
    fn emit_typed_value(&mut self) {
        let slice = self.term();
        let span = self.span_from_mark();

        // Resolve slice to check content
        if let Some(bytes) = self.chunks.resolve(slice) {
            // Check for nil
            if bytes == b"null" || bytes == b"nil" || bytes == b"~" {
                self.emit(StreamingEvent::NilValue { span });
                return;
            }

            // Check for bool
            if bytes == b"true" {
                self.emit(StreamingEvent::BoolValue { value: true, span });
                return;
            }
            if bytes == b"false" {
                self.emit(StreamingEvent::BoolValue { value: false, span });
                return;
            }

            // Try to parse as number
            if let Some(event) = self.try_parse_number(bytes, span) {
                self.emit(event);
                return;
            }
        }

        // Default to string
        self.emit(StreamingEvent::StringValue { value: slice, span });
    }

    /// Try to parse bytes as a number.
    fn try_parse_number(&self, bytes: &[u8], span: Span) -> Option<StreamingEvent> {
        use crate::Value;
        match Value::parse(bytes) {
            Value::Integer(i) => Some(StreamingEvent::IntegerValue { value: i, span }),
            Value::Float(f) => Some(StreamingEvent::FloatValue { value: f, span }),
            Value::Rational { numerator, denominator } => {
                Some(StreamingEvent::RationalValue { numerator, denominator, span })
            }
            Value::Complex { real, imag } => {
                Some(StreamingEvent::ComplexValue { real, imag, span })
            }
            _ => None,
        }
    }

    // ========== State Machine Entry Point ==========

    /// Continue parsing from current state.
    fn parse_continue(&mut self) {
        // For now, just run the document parser
        // TODO: Proper state restoration for streaming
        self.parse_document();
    }

    // ========== Generated State Machine ==========

    fn parse_document(&mut self) {
        #[derive(Clone, Copy)]
        enum State { SStart, SEscaped, SEscapedText, SProse, SCheckInlineComment, SInlineComment, SInlineCommentNested, SInlineCommentNested2, SInlineCommentNested3, SLineComment, SBlockComment, SMaybeFreeform, SMaybeFreeform2, SFreeformStart, SFreeform, SFreeformEnd1, SFreeformEnd2, SStartDispatch, SSkipLine }

        let mut state = State::SStart;
        loop {
            match state {
                State::SStart => {
                    match self.peek() {
                        None => {
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            self.advance();
                            state = State::SStart;
                        }
                        b' ' => {
                            self.advance();
                            state = State::SStart;
                        }
                        b'\t' => {
                            self.advance();
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::NoTabs, span: self.span_from_mark() });
                            state = State::SSkipLine;
                        }
                        b'\'' => {
                            self.advance();
                            state = State::SEscaped;
                        }
                        b';' => {
                            self.advance();
                            self.mark();
                            state = State::SBlockComment;
                        }
                        b'|' => {
                            self.parse_element(self.current_column());
                            state = State::SStart;
                        }
                        b'`' => {
                            self.advance();
                            state = State::SMaybeFreeform;
                        }
                        b'!' => {
                            self.parse_directive(self.current_column());
                            state = State::SStartDispatch;
                        }
                        _ => {
                            self.mark();
                            state = State::SProse;
                        }
                            }
                        }
                    }
                }
                State::SEscaped => {
                    match self.peek() {
                        None => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            state = State::SStart;
                        }
                        _ => {
                            self.mark();
                            state = State::SEscapedText;
                        }
                            }
                        }
                    }
                }
                State::SEscapedText => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to1(b'\n') {
                        Some(b'\n') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            state = State::SStart;
                        }
                        None => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SProse => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to3(b'\n', b';', b'|') {
                        Some(b'\n') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            state = State::SStart;
                        }
                        Some(b';') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.advance();
                            state = State::SCheckInlineComment;
                        }
                        Some(b'|') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.parse_element(self.current_column());
                            state = State::SStart;
                        }
                        None => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SCheckInlineComment => {
                    match self.peek() {
                        None => {
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'{' => {
                            self.advance();
                            self.mark();
                            state = State::SInlineComment;
                        }
                        _ => {
                            self.mark();
                            state = State::SLineComment;
                        }
                            }
                        }
                    }
                }
                State::SInlineComment => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedComment, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Comment { content, span }); }
                            self.advance();
                            state = State::SProse;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SInlineCommentNested;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SInlineCommentNested => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedComment, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            state = State::SInlineComment;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SInlineCommentNested2;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SInlineCommentNested2 => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedComment, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            state = State::SInlineCommentNested;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SInlineCommentNested3;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SInlineCommentNested3 => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedComment, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            state = State::SInlineCommentNested2;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SLineComment => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to1(b'\n') {
                        Some(b'\n') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Comment { content, span }); }
                            state = State::SStart;
                        }
                        None => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Comment { content, span }); }
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SBlockComment => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to1(b'\n') {
                        Some(b'\n') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Comment { content, span }); }
                            state = State::SStart;
                        }
                        None => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Comment { content, span }); }
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SMaybeFreeform => {
                    match self.peek() {
                        None => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'`' => {
                            self.advance();
                            state = State::SMaybeFreeform2;
                        }
                        _ => {
                            self.mark();
                            state = State::SProse;
                        }
                            }
                        }
                    }
                }
                State::SMaybeFreeform2 => {
                    match self.peek() {
                        None => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'`' => {
                            self.advance();
                            state = State::SFreeformStart;
                        }
                        _ => {
                            self.mark();
                            state = State::SProse;
                        }
                            }
                        }
                    }
                }
                State::SFreeformStart => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedFreeform, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            self.advance();
                            self.mark();
                            state = State::SFreeform;
                        }
                        _ => {
                            self.mark();
                            state = State::SFreeform;
                        }
                            }
                        }
                    }
                }
                State::SFreeform => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedFreeform, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'`' => {
                            self.advance();
                            state = State::SFreeformEnd1;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SFreeformEnd1 => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedFreeform, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'`' => {
                            self.advance();
                            state = State::SFreeformEnd2;
                        }
                        _ => {
                            self.advance();
                            state = State::SFreeform;
                        }
                            }
                        }
                    }
                }
                State::SFreeformEnd2 => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedFreeform, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'`' => {
                            { let content = self.term_adjusted(-2); let span = self.span_from_mark(); self.emit(StreamingEvent::RawContent { content, span }); }
                            self.advance();
                            state = State::SStart;
                        }
                        _ => {
                            self.advance();
                            state = State::SFreeform;
                        }
                            }
                        }
                    }
                }
                State::SStartDispatch => {
                    match self.peek() {
                        None => {
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            self.advance();
                            state = State::SStart;
                        }
                        b' ' => {
                            self.advance();
                            state = State::SStart;
                        }
                        b'\t' => {
                            self.advance();
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::NoTabs, span: self.span_from_mark() });
                            state = State::SSkipLine;
                        }
                        b'\'' => {
                            self.advance();
                            state = State::SEscaped;
                        }
                        b';' => {
                            self.advance();
                            self.mark();
                            state = State::SBlockComment;
                        }
                        b'|' => {
                            self.parse_element(self.current_column());
                            state = State::SStart;
                        }
                        b'`' => {
                            self.advance();
                            state = State::SMaybeFreeform;
                        }
                        b'!' => {
                            self.parse_directive(self.current_column());
                            state = State::SStartDispatch;
                        }
                        _ => {
                            self.mark();
                            state = State::SProse;
                        }
                            }
                        }
                    }
                }
                State::SSkipLine => {
                    match self.peek() {
                        None => {
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            state = State::SStart;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
            }
        }
    }

    fn parse_element(&mut self, elem_col: i32) {
        let mut content_base: i32 = -1;

        #[derive(Clone, Copy)]
        enum State { SIdentity, SEmbedIdentity, SEmbedName, SEmbedAfterNameSuffix, SEmbedAnonBracket, SEmbedBracketStart, SEmbedBracketValue, SEmbedAfterBracket, SEmbedClassStart, SEmbedClassName, SEmbedClassQuoted, SEmbedClassQuotedContent, SEmbedClassQuotedEsc, SEmbedClassCheck, SEmbedAfterIdentity, SEmbedAttrKey, SEmbedAttrKeyScan, SEmbedAttrKeyQuoted, SEmbedAttrKeyQuotedContent, SEmbedAttrKeyQuotedEsc, SEmbedAttrValue, SEmbedAttrDquote, SEmbedAttrDquoteContent, SEmbedAttrDquoteEsc, SEmbedAttrSquote, SEmbedAttrSquoteContent, SEmbedAttrSquoteEsc, SEmbedAttrBare, SEmbedAttrAfterValue, SEmbedCheckNested, SEmbedAfterNested, SEmbedContent, SEmbedContentNested, SEmbedContentNested2, SEmbedContentNested3, SEmbedCommentCheck, SEmbedInlineComment, SEmbedInlineCommentNested, SEmbedContentAfterComment, SIdName, SIdAfterName, SIdCheckBracket, SIdBracketStart, SIdAnonBracket, SIdBracketValue, SIdAfterBracket, SIdCheckClass, SIdSpaceClassOrSuffix, SIdClassStart, SIdClassName, SIdClassCheckMore, SIdSpaceSuffix, SIdQuotedName, SIdQuotedNameContent, SIdQuotedNameEscape, SIdClassQuoted, SIdClassQuotedContent, SIdClassQuotedEscape, SIdCheckMore, SAfterIdentity, SInlineContent, SInlineText, SInlineDirective, SInlineDirBrace, SInlineRawLabel, SInlineRawContent, SInlineRawBody, SInlineRawN1, SInlineRawN2, SInlineRawN3, SInlineInterp, SInlineInterpClose, SInlineInterpClose2, SInlineInterpNested, SInlineInterpNested2, SInlineAfterInterp, SInlineInlineDirName, SInlineInlineDirNs, SInlineInlineDirKind, SInlineInlineDirBody, SInlineInlineDirNested, SInlineInlineDirNested2, SInlineCheckPipe, SInlineAfterElement, SElemCommentCheck, SElemInlineComment, SElemInlineCommentNested, SElemInlineCommentNested2, SElemLineComment, SInlineAttrKey, SInlineAttrMerge, SInlineAttrAfterMerge, SInlineAttrKeyScan, SInlineAttrKeyQuoted, SInlineAttrKeyQuotedContent, SInlineAttrKeyQuotedEsc, SInlineAttrWs, SInlineAttrValue, SInlineAttrDquote, SInlineAttrDquoteContent, SInlineAttrDquoteEsc, SInlineAttrSquote, SInlineAttrSquoteContent, SInlineAttrSquoteEsc, SInlineAttrBare, SInlineAttrAfterValue, SChildren, SChildrenContent, SChildrenAfterElement, SChildrenAfterDirective, SChildrenCountWs, SChildEscaped, SChildEscapedText, SChildProse, SChildProseCont, SChildIdRef, SChildIdRefValue, SChildCommentStart, SChildCommentCheck, SChildInlineComment, SChildInlineCommentNested, SChildInlineCommentNested2, SChildProseAfterComment, SChildLineComment, SChildBlockComment, SChildFreeformCheck, SChildFreeformCheck2, SChildFreeformStart, SChildFreeform, SChildFreeformEnd1, SChildFreeformEnd2, SSkipChild, SAttrKey, SAttrMerge, SAttrAfterMerge, SAttrKeyScan, SAttrKeyQuoted, SAttrKeyQuotedContent, SAttrKeyQuotedEsc, SAttrWs, SAttrValue, SAttrComment, SAttrDquote, SAttrDquoteContent, SAttrDquoteEsc, SAttrSquote, SAttrSquoteContent, SAttrSquoteEsc, SAttrBare, SAttrAfterValue, SAttrSkipLine }

        let mut state = State::SIdentity;
        loop {
            match state {
                State::SIdentity => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'|' => {
                            self.advance();
                        }
                        b if self.is_label_start(b) => {
                            self.mark();
                            state = State::SIdName;
                        }
                        b'[' => {
                            self.advance();
                            state = State::SIdAnonBracket;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SEmbedIdentity;
                        }
                        b'.' => {
                            self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            state = State::SIdClassStart;
                        }
                        b'?' => {
                            self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.emit_special_attribute("?");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SIdCheckMore;
                        }
                        b'!' => {
                            self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.emit_special_attribute("!");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SIdCheckMore;
                        }
                        b'*' => {
                            self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.emit_special_attribute("*");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SIdCheckMore;
                        }
                        b'+' => {
                            self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.emit_special_attribute("+");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SIdCheckMore;
                        }
                        b'\'' => {
                            self.advance();
                            state = State::SIdQuotedName;
                        }
                        _ => {
                            self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            state = State::SAfterIdentity;
                        }
                            }
                        }
                    }
                }
                State::SEmbedIdentity => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b if self.is_label_start(b) => {
                            self.mark();
                            state = State::SEmbedName;
                        }
                        b'[' => {
                            self.advance();
                            state = State::SEmbedAnonBracket;
                        }
                        b'.' => {
                            self.emit(StreamingEvent::EmbeddedStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            state = State::SEmbedClassStart;
                        }
                        b' ' | b'\t' => {
                            self.emit(StreamingEvent::EmbeddedStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            state = State::SEmbedAfterIdentity;
                        }
                        b'}' => {
                            self.emit(StreamingEvent::EmbeddedStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            return;
                        }
                        _ => {
                            self.emit(StreamingEvent::EmbeddedStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.mark();
                            state = State::SEmbedContent;
                        }
                            }
                        }
                    }
                }
                State::SEmbedName => {
                    match self.peek() {
                        None => {
                            { let name = Some(self.term()); let span = self.span_from_mark(); self.emit(StreamingEvent::EmbeddedStart { name, span }); }
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b if self.is_label_continue(b) => {
                            self.advance();
                        }
                        b'[' => {
                            { let name = Some(self.term()); let span = self.span_from_mark(); self.emit(StreamingEvent::EmbeddedStart { name, span }); }
                            self.advance();
                            state = State::SEmbedBracketStart;
                        }
                        b'.' => {
                            { let name = Some(self.term()); let span = self.span_from_mark(); self.emit(StreamingEvent::EmbeddedStart { name, span }); }
                            self.advance();
                            state = State::SEmbedClassStart;
                        }
                        b':' => {
                            { let name = Some(self.term()); let span = self.span_from_mark(); self.emit(StreamingEvent::EmbeddedStart { name, span }); }
                            self.advance();
                            state = State::SEmbedAttrKey;
                        }
                        b'?' => {
                            { let name = Some(self.term()); let span = self.span_from_mark(); self.emit(StreamingEvent::EmbeddedStart { name, span }); }
                            self.emit_special_attribute("?");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SEmbedAfterNameSuffix;
                        }
                        b'!' => {
                            { let name = Some(self.term()); let span = self.span_from_mark(); self.emit(StreamingEvent::EmbeddedStart { name, span }); }
                            self.emit_special_attribute("!");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SEmbedAfterNameSuffix;
                        }
                        b'*' => {
                            { let name = Some(self.term()); let span = self.span_from_mark(); self.emit(StreamingEvent::EmbeddedStart { name, span }); }
                            self.emit_special_attribute("*");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SEmbedAfterNameSuffix;
                        }
                        b'+' => {
                            { let name = Some(self.term()); let span = self.span_from_mark(); self.emit(StreamingEvent::EmbeddedStart { name, span }); }
                            self.emit_special_attribute("+");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SEmbedAfterNameSuffix;
                        }
                        b' ' | b'\t' => {
                            { let name = Some(self.term()); let span = self.span_from_mark(); self.emit(StreamingEvent::EmbeddedStart { name, span }); }
                            state = State::SEmbedAfterIdentity;
                        }
                        b'}' => {
                            { let name = Some(self.term()); let span = self.span_from_mark(); self.emit(StreamingEvent::EmbeddedStart { name, span }); }
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            return;
                        }
                        _ => {
                            { let name = Some(self.term()); let span = self.span_from_mark(); self.emit(StreamingEvent::EmbeddedStart { name, span }); }
                            self.mark();
                            state = State::SEmbedContent;
                        }
                            }
                        }
                    }
                }
                State::SEmbedAfterNameSuffix => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'?' => {
                            self.emit_special_attribute("?");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                        }
                        b'!' => {
                            self.emit_special_attribute("!");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                        }
                        b'*' => {
                            self.emit_special_attribute("*");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                        }
                        b'+' => {
                            self.emit_special_attribute("+");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                        }
                        b'[' => {
                            self.advance();
                            state = State::SEmbedBracketStart;
                        }
                        b'.' => {
                            self.advance();
                            state = State::SEmbedClassStart;
                        }
                        b':' => {
                            self.advance();
                            state = State::SEmbedAttrKey;
                        }
                        b' ' | b'\t' => {
                            state = State::SEmbedAfterIdentity;
                        }
                        b'}' => {
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            return;
                        }
                        _ => {
                            self.mark();
                            state = State::SEmbedContent;
                        }
                            }
                        }
                    }
                }
                State::SEmbedAnonBracket => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::EmbeddedStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b']' => {
                            self.emit(StreamingEvent::EmbeddedStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            state = State::SEmbedAfterBracket;
                        }
                        _ => {
                            self.emit(StreamingEvent::EmbeddedStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.emit_special_attribute("$id");
                            self.mark();
                            state = State::SEmbedBracketValue;
                        }
                            }
                        }
                    }
                }
                State::SEmbedBracketStart => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedBracket, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b']' => {
                            self.advance();
                            state = State::SEmbedAfterBracket;
                        }
                        _ => {
                            self.emit_special_attribute("$id");
                            self.mark();
                            state = State::SEmbedBracketValue;
                        }
                            }
                        }
                    }
                }
                State::SEmbedBracketValue => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to1(b']') {
                        Some(b']') => {
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::StringValue { value, span }); }
                            self.advance();
                            state = State::SEmbedAfterBracket;
                        }
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedBracket, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SEmbedAfterBracket => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'.' => {
                            self.advance();
                            state = State::SEmbedClassStart;
                        }
                        b':' => {
                            self.advance();
                            state = State::SEmbedAttrKey;
                        }
                        b' ' | b'\t' => {
                            self.advance();
                            state = State::SEmbedAfterIdentity;
                        }
                        b'}' => {
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            return;
                        }
                        _ => {
                            self.mark();
                            state = State::SEmbedContent;
                        }
                            }
                        }
                    }
                }
                State::SEmbedClassStart => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::ExpectedClassName, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b if self.is_label_start(b) => {
                            self.emit_special_attribute("$class");
                            self.mark();
                            state = State::SEmbedClassName;
                        }
                        b'\'' => {
                            self.emit_special_attribute("$class");
                            self.advance();
                            state = State::SEmbedClassQuoted;
                        }
                        _ => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::ExpectedClassName, span: self.span_from_mark() });
                            state = State::SEmbedAfterIdentity;
                        }
                            }
                        }
                    }
                }
                State::SEmbedClassName => {
                    match self.peek() {
                        None => {
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::StringValue { value, span }); }
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b if self.is_label_continue(b) => {
                            self.advance();
                        }
                        b'.' => {
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::StringValue { value, span }); }
                            self.advance();
                            state = State::SEmbedClassStart;
                        }
                        b':' => {
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::StringValue { value, span }); }
                            self.advance();
                            state = State::SEmbedAttrKey;
                        }
                        b' ' | b'\t' => {
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::StringValue { value, span }); }
                            state = State::SEmbedAfterIdentity;
                        }
                        b'}' => {
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::StringValue { value, span }); }
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            return;
                        }
                        _ => {
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::StringValue { value, span }); }
                            self.mark();
                            state = State::SEmbedContent;
                        }
                            }
                        }
                    }
                }
                State::SEmbedClassQuoted => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedQuote, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\'' => {
                            self.mark();
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SEmbedClassCheck;
                        }
                        _ => {
                            self.mark();
                            state = State::SEmbedClassQuotedContent;
                        }
                            }
                        }
                    }
                }
                State::SEmbedClassQuotedContent => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to2(b'\'', b'\\') {
                        Some(b'\'') => {
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SEmbedClassCheck;
                        }
                        Some(b'\\') => {
                            self.advance();
                            state = State::SEmbedClassQuotedEsc;
                        }
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedQuote, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SEmbedClassQuotedEsc => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedQuote, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        _ => {
                            self.advance();
                            state = State::SEmbedClassQuotedContent;
                        }
                            }
                        }
                    }
                }
                State::SEmbedClassCheck => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'.' => {
                            self.advance();
                            state = State::SEmbedClassStart;
                        }
                        b':' => {
                            self.advance();
                            state = State::SEmbedAttrKey;
                        }
                        b' ' | b'\t' => {
                            self.advance();
                            state = State::SEmbedAfterIdentity;
                        }
                        b'}' => {
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            return;
                        }
                        _ => {
                            self.mark();
                            state = State::SEmbedContent;
                        }
                            }
                        }
                    }
                }
                State::SEmbedAfterIdentity => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b' ' | b'\t' => {
                            self.advance();
                        }
                        b':' => {
                            self.advance();
                            state = State::SEmbedAttrKey;
                        }
                        b'}' => {
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            return;
                        }
                        b'|' => {
                            self.advance();
                            state = State::SEmbedCheckNested;
                        }
                        _ => {
                            self.mark();
                            state = State::SEmbedContent;
                        }
                            }
                        }
                    }
                }
                State::SEmbedAttrKey => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::ExpectedAttrKey, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b if self.is_label_start(b) => {
                            self.mark();
                            state = State::SEmbedAttrKeyScan;
                        }
                        b'\'' => {
                            self.advance();
                            state = State::SEmbedAttrKeyQuoted;
                        }
                        _ => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::ExpectedAttrKey, span: self.span_from_mark() });
                            state = State::SEmbedAfterIdentity;
                        }
                            }
                        }
                    }
                }
                State::SEmbedAttrKeyScan => {
                    match self.peek() {
                        None => {
                            { let key = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Attribute { key, span }); }
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b if self.is_label_continue(b) => {
                            self.advance();
                        }
                        b' ' | b'\t' => {
                            { let key = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Attribute { key, span }); }
                            state = State::SEmbedAttrValue;
                        }
                        b'}' => {
                            { let key = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Attribute { key, span }); }
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            return;
                        }
                        b':' => {
                            { let key = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Attribute { key, span }); }
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SEmbedAttrKey;
                        }
                        _ => {
                            { let key = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Attribute { key, span }); }
                            state = State::SEmbedAttrValue;
                        }
                            }
                        }
                    }
                }
                State::SEmbedAttrKeyQuoted => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedQuote, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\'' => {
                            self.mark();
                            { let key = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Attribute { key, span }); }
                            self.advance();
                            state = State::SEmbedAttrValue;
                        }
                        _ => {
                            self.mark();
                            state = State::SEmbedAttrKeyQuotedContent;
                        }
                            }
                        }
                    }
                }
                State::SEmbedAttrKeyQuotedContent => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedQuote, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\'' => {
                            { let key = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Attribute { key, span }); }
                            state = State::SEmbedAttrValue;
                        }
                        b'\\' => {
                            self.advance();
                            state = State::SEmbedAttrKeyQuotedEsc;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SEmbedAttrKeyQuotedEsc => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedQuote, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        _ => {
                            self.advance();
                            state = State::SEmbedAttrKeyQuotedContent;
                        }
                            }
                        }
                    }
                }
                State::SEmbedAttrValue => {
                    match self.peek() {
                        None => {
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b' ' | b'\t' => {
                            self.advance();
                        }
                        b':' => {
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SEmbedAttrKey;
                        }
                        b'}' => {
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            return;
                        }
                        b'|' => {
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SEmbedCheckNested;
                        }
                        b'"' => {
                            self.advance();
                            state = State::SEmbedAttrDquote;
                        }
                        b'\'' => {
                            self.advance();
                            state = State::SEmbedAttrSquote;
                        }
                        b'[' => {
                            self.emit(StreamingEvent::ArrayStart { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            self.parse_array();
                            state = State::SEmbedAttrAfterValue;
                        }
                        _ => {
                            self.mark();
                            state = State::SEmbedAttrBare;
                        }
                            }
                        }
                    }
                }
                State::SEmbedAttrDquote => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedString, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'"' => {
                            self.mark();
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SEmbedAttrAfterValue;
                        }
                        _ => {
                            self.mark();
                            state = State::SEmbedAttrDquoteContent;
                        }
                            }
                        }
                    }
                }
                State::SEmbedAttrDquoteContent => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to2(b'"', b'\\') {
                        Some(b'"') => {
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SEmbedAttrAfterValue;
                        }
                        Some(b'\\') => {
                            self.advance();
                            state = State::SEmbedAttrDquoteEsc;
                        }
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedString, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SEmbedAttrDquoteEsc => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedString, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        _ => {
                            self.advance();
                            state = State::SEmbedAttrDquoteContent;
                        }
                            }
                        }
                    }
                }
                State::SEmbedAttrSquote => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedString, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\'' => {
                            self.mark();
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SEmbedAttrAfterValue;
                        }
                        _ => {
                            self.mark();
                            state = State::SEmbedAttrSquoteContent;
                        }
                            }
                        }
                    }
                }
                State::SEmbedAttrSquoteContent => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to2(b'\'', b'\\') {
                        Some(b'\'') => {
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SEmbedAttrAfterValue;
                        }
                        Some(b'\\') => {
                            self.advance();
                            state = State::SEmbedAttrSquoteEsc;
                        }
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedString, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SEmbedAttrSquoteEsc => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedString, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        _ => {
                            self.advance();
                            state = State::SEmbedAttrSquoteContent;
                        }
                            }
                        }
                    }
                }
                State::SEmbedAttrBare => {
                    match self.peek() {
                        None => {
                            self.emit_typed_value();
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b' ' | b'\t' => {
                            self.emit_typed_value();
                            state = State::SEmbedAttrAfterValue;
                        }
                        b'}' => {
                            self.emit_typed_value();
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            return;
                        }
                        b':' => {
                            self.emit_typed_value();
                            self.advance();
                            state = State::SEmbedAttrKey;
                        }
                        b'|' => {
                            self.emit_typed_value();
                            self.advance();
                            state = State::SEmbedCheckNested;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SEmbedAttrAfterValue => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b' ' | b'\t' => {
                            self.advance();
                        }
                        b':' => {
                            self.advance();
                            state = State::SEmbedAttrKey;
                        }
                        b'}' => {
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            return;
                        }
                        b'|' => {
                            self.advance();
                            state = State::SEmbedCheckNested;
                        }
                        _ => {
                            self.mark();
                            state = State::SEmbedContent;
                        }
                            }
                        }
                    }
                }
                State::SEmbedCheckNested => {
                    match self.peek() {
                        None => {
                            self.emit_pipe_text();
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'{' => {
                            self.parse_element(self.current_column());
                            state = State::SEmbedAfterNested;
                        }
                        _ => {
                            self.emit_pipe_text();
                            self.mark();
                            state = State::SEmbedContent;
                        }
                            }
                        }
                    }
                }
                State::SEmbedAfterNested => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            return;
                        }
                        b'|' => {
                            self.advance();
                            state = State::SEmbedCheckNested;
                        }
                        b';' => {
                            self.advance();
                            state = State::SEmbedCommentCheck;
                        }
                        _ => {
                            self.mark();
                            state = State::SEmbedContent;
                        }
                            }
                        }
                    }
                }
                State::SEmbedContent => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to4(b'}', b'{', b'|', b';') {
                        Some(b'}') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            return;
                        }
                        Some(b'{') => {
                            self.advance();
                            state = State::SEmbedContentNested;
                        }
                        Some(b'|') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.advance();
                            state = State::SEmbedCheckNested;
                        }
                        Some(b';') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.advance();
                            state = State::SEmbedCommentCheck;
                        }
                        None => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SEmbedContentNested => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            state = State::SEmbedContent;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SEmbedContentNested2;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SEmbedContentNested2 => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            state = State::SEmbedContentNested;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SEmbedContentNested3;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SEmbedContentNested3 => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            state = State::SEmbedContentNested2;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SEmbedCommentCheck => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'{' => {
                            self.advance();
                            self.mark();
                            state = State::SEmbedInlineComment;
                        }
                        _ => {
                            self.mark();
                            state = State::SEmbedContent;
                        }
                            }
                        }
                    }
                }
                State::SEmbedInlineComment => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedComment, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Comment { content, span }); }
                            self.advance();
                            state = State::SEmbedContentAfterComment;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SEmbedInlineCommentNested;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SEmbedInlineCommentNested => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedComment, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            state = State::SEmbedInlineComment;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SEmbedContentAfterComment => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.emit(StreamingEvent::EmbeddedEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            return;
                        }
                        b'|' => {
                            self.advance();
                            state = State::SEmbedCheckNested;
                        }
                        _ => {
                            self.mark();
                            state = State::SEmbedContent;
                        }
                            }
                        }
                    }
                }
                State::SIdName => {
                    match self.peek() {
                        None => {
                            { let name = Some(self.term()); let span = self.span_from_mark(); self.emit(StreamingEvent::ElementStart { name, span }); }
                            state = State::SAfterIdentity;
                        }
                        Some(b) => {
                            match b {
                        b if self.is_label_continue(b) => {
                            self.advance();
                        }
                        _ => {
                            { let name = Some(self.term()); let span = self.span_from_mark(); self.emit(StreamingEvent::ElementStart { name, span }); }
                            state = State::SIdAfterName;
                        }
                            }
                        }
                    }
                }
                State::SIdAfterName => {
                    match self.peek() {
                        None => {
                            state = State::SAfterIdentity;
                        }
                        Some(b) => {
                            match b {
                        b'?' => {
                            self.emit_special_attribute("?");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SIdCheckBracket;
                        }
                        b'!' => {
                            self.emit_special_attribute("!");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SIdCheckBracket;
                        }
                        b'*' => {
                            self.emit_special_attribute("*");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SIdCheckBracket;
                        }
                        b'+' => {
                            self.emit_special_attribute("+");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SIdCheckBracket;
                        }
                        b'[' => {
                            self.advance();
                            state = State::SIdBracketStart;
                        }
                        b'.' => {
                            self.advance();
                            state = State::SIdClassStart;
                        }
                        _ => {
                            state = State::SAfterIdentity;
                        }
                            }
                        }
                    }
                }
                State::SIdCheckBracket => {
                    match self.peek() {
                        None => {
                            state = State::SAfterIdentity;
                        }
                        Some(b) => {
                            match b {
                        b'?' => {
                            self.emit_special_attribute("?");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                        }
                        b'!' => {
                            self.emit_special_attribute("!");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                        }
                        b'*' => {
                            self.emit_special_attribute("*");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                        }
                        b'+' => {
                            self.emit_special_attribute("+");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                        }
                        b'[' => {
                            self.advance();
                            state = State::SIdBracketStart;
                        }
                        b'.' => {
                            self.advance();
                            state = State::SIdClassStart;
                        }
                        _ => {
                            state = State::SAfterIdentity;
                        }
                            }
                        }
                    }
                }
                State::SIdBracketStart => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedBracket, span: self.span_from_mark() });
                            state = State::SAfterIdentity;
                        }
                        Some(b) => {
                            match b {
                        b']' => {
                            self.advance();
                            state = State::SIdAfterBracket;
                        }
                        _ => {
                            self.emit_special_attribute("$id");
                            self.mark();
                            state = State::SIdBracketValue;
                        }
                            }
                        }
                    }
                }
                State::SIdAnonBracket => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedBracket, span: self.span_from_mark() });
                            state = State::SAfterIdentity;
                        }
                        Some(b) => {
                            match b {
                        b']' => {
                            self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            state = State::SIdAfterBracket;
                        }
                        _ => {
                            self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.emit_special_attribute("$id");
                            self.mark();
                            state = State::SIdBracketValue;
                        }
                            }
                        }
                    }
                }
                State::SIdBracketValue => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to1(b']') {
                        Some(b']') => {
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::StringValue { value, span }); }
                            self.advance();
                            state = State::SIdAfterBracket;
                        }
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedBracket, span: self.span_from_mark() });
                            state = State::SAfterIdentity;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SIdAfterBracket => {
                    match self.peek() {
                        None => {
                            state = State::SAfterIdentity;
                        }
                        Some(b) => {
                            match b {
                        b'?' => {
                            self.emit_special_attribute("?");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SIdCheckClass;
                        }
                        b'!' => {
                            self.emit_special_attribute("!");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SIdCheckClass;
                        }
                        b'*' => {
                            self.emit_special_attribute("*");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SIdCheckClass;
                        }
                        b'+' => {
                            self.emit_special_attribute("+");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SIdCheckClass;
                        }
                        b'.' => {
                            self.advance();
                            state = State::SIdClassStart;
                        }
                        _ => {
                            state = State::SAfterIdentity;
                        }
                            }
                        }
                    }
                }
                State::SIdCheckClass => {
                    match self.peek() {
                        None => {
                            state = State::SAfterIdentity;
                        }
                        Some(b) => {
                            match b {
                        b'?' => {
                            self.emit_special_attribute("?");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                        }
                        b'!' => {
                            self.emit_special_attribute("!");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                        }
                        b'*' => {
                            self.emit_special_attribute("*");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                        }
                        b'+' => {
                            self.emit_special_attribute("+");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                        }
                        b'.' => {
                            self.advance();
                            state = State::SIdClassStart;
                        }
                        b' ' => {
                            self.advance();
                            state = State::SIdSpaceClassOrSuffix;
                        }
                        _ => {
                            state = State::SAfterIdentity;
                        }
                            }
                        }
                    }
                }
                State::SIdSpaceClassOrSuffix => {
                    match self.peek() {
                        None => {
                            state = State::SAfterIdentity;
                        }
                        Some(b) => {
                            match b {
                        b'?' => {
                            self.emit_special_attribute("?");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SAfterIdentity;
                        }
                        b'!' => {
                            self.emit_special_attribute("!");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SAfterIdentity;
                        }
                        b'*' => {
                            self.emit_special_attribute("*");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SAfterIdentity;
                        }
                        b'+' => {
                            self.emit_special_attribute("+");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SAfterIdentity;
                        }
                        b'.' => {
                            self.advance();
                            state = State::SIdClassStart;
                        }
                        b' ' => {
                            self.advance();
                        }
                        _ => {
                            state = State::SAfterIdentity;
                        }
                            }
                        }
                    }
                }
                State::SIdClassStart => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::ExpectedClassName, span: self.span_from_mark() });
                            state = State::SAfterIdentity;
                        }
                        Some(b) => {
                            match b {
                        b if self.is_label_start(b) => {
                            self.emit_special_attribute("$class");
                            self.mark();
                            state = State::SIdClassName;
                        }
                        b'\'' => {
                            self.emit_special_attribute("$class");
                            self.advance();
                            state = State::SIdClassQuoted;
                        }
                        _ => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::ExpectedClassName, span: self.span_from_mark() });
                            state = State::SAfterIdentity;
                        }
                            }
                        }
                    }
                }
                State::SIdClassName => {
                    match self.peek() {
                        None => {
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::StringValue { value, span }); }
                            state = State::SAfterIdentity;
                        }
                        Some(b) => {
                            match b {
                        b if self.is_label_continue(b) => {
                            self.advance();
                        }
                        _ => {
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::StringValue { value, span }); }
                            state = State::SIdClassCheckMore;
                        }
                            }
                        }
                    }
                }
                State::SIdClassCheckMore => {
                    match self.peek() {
                        None => {
                            state = State::SAfterIdentity;
                        }
                        Some(b) => {
                            match b {
                        b'.' => {
                            self.advance();
                            state = State::SIdClassStart;
                        }
                        b' ' => {
                            self.advance();
                            state = State::SIdSpaceSuffix;
                        }
                        _ => {
                            state = State::SAfterIdentity;
                        }
                            }
                        }
                    }
                }
                State::SIdSpaceSuffix => {
                    match self.peek() {
                        None => {
                            state = State::SAfterIdentity;
                        }
                        Some(b) => {
                            match b {
                        b'?' => {
                            self.emit_special_attribute("?");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SAfterIdentity;
                        }
                        b'!' => {
                            self.emit_special_attribute("!");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SAfterIdentity;
                        }
                        b'*' => {
                            self.emit_special_attribute("*");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SAfterIdentity;
                        }
                        b'+' => {
                            self.emit_special_attribute("+");
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SAfterIdentity;
                        }
                        b' ' => {
                            self.advance();
                        }
                        _ => {
                            state = State::SAfterIdentity;
                        }
                            }
                        }
                    }
                }
                State::SIdQuotedName => {
                    match self.peek() {
                        None => {
                            { let name = Some(self.term()); let span = self.span_from_mark(); self.emit(StreamingEvent::ElementStart { name, span }); }
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedQuote, span: self.span_from_mark() });
                            state = State::SAfterIdentity;
                        }
                        Some(b) => {
                            match b {
                        b'\'' => {
                            self.mark();
                            { let name = Some(self.term()); let span = self.span_from_mark(); self.emit(StreamingEvent::ElementStart { name, span }); }
                            self.advance();
                            state = State::SIdAfterName;
                        }
                        _ => {
                            self.mark();
                            state = State::SIdQuotedNameContent;
                        }
                            }
                        }
                    }
                }
                State::SIdQuotedNameContent => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to2(b'\'', b'\\') {
                        Some(b'\'') => {
                            { let name = Some(self.term()); let span = self.span_from_mark(); self.emit(StreamingEvent::ElementStart { name, span }); }
                            self.advance();
                            state = State::SIdAfterName;
                        }
                        Some(b'\\') => {
                            self.advance();
                            state = State::SIdQuotedNameEscape;
                        }
                        None => {
                            { let name = Some(self.term()); let span = self.span_from_mark(); self.emit(StreamingEvent::ElementStart { name, span }); }
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedQuote, span: self.span_from_mark() });
                            state = State::SAfterIdentity;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SIdQuotedNameEscape => {
                    match self.peek() {
                        None => {
                            { let name = Some(self.term()); let span = self.span_from_mark(); self.emit(StreamingEvent::ElementStart { name, span }); }
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedQuote, span: self.span_from_mark() });
                            state = State::SAfterIdentity;
                        }
                        Some(b) => {
                            match b {
                        _ => {
                            self.advance();
                            state = State::SIdQuotedNameContent;
                        }
                            }
                        }
                    }
                }
                State::SIdClassQuoted => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedQuote, span: self.span_from_mark() });
                            state = State::SAfterIdentity;
                        }
                        Some(b) => {
                            match b {
                        b'\'' => {
                            self.mark();
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SIdClassCheckMore;
                        }
                        _ => {
                            self.mark();
                            state = State::SIdClassQuotedContent;
                        }
                            }
                        }
                    }
                }
                State::SIdClassQuotedContent => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to2(b'\'', b'\\') {
                        Some(b'\'') => {
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SIdClassCheckMore;
                        }
                        Some(b'\\') => {
                            self.advance();
                            state = State::SIdClassQuotedEscape;
                        }
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedQuote, span: self.span_from_mark() });
                            state = State::SAfterIdentity;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SIdClassQuotedEscape => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedQuote, span: self.span_from_mark() });
                            state = State::SAfterIdentity;
                        }
                        Some(b) => {
                            match b {
                        _ => {
                            self.advance();
                            state = State::SIdClassQuotedContent;
                        }
                            }
                        }
                    }
                }
                State::SIdCheckMore => {
                    match self.peek() {
                        None => {
                            state = State::SAfterIdentity;
                        }
                        Some(b) => {
                            match b {
                        b'[' => {
                            self.advance();
                            state = State::SIdBracketStart;
                        }
                        b'.' => {
                            self.advance();
                            state = State::SIdClassStart;
                        }
                        _ => {
                            state = State::SAfterIdentity;
                        }
                            }
                        }
                    }
                }
                State::SAfterIdentity => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            self.advance();
                            state = State::SChildren;
                        }
                        b' ' | b'\t' => {
                            self.advance();
                            state = State::SInlineContent;
                        }
                        b';' => {
                            self.advance();
                            state = State::SElemCommentCheck;
                        }
                        b':' => {
                            self.advance();
                            state = State::SInlineAttrKey;
                        }
                        b'|' => {
                            self.advance();
                            state = State::SInlineCheckPipe;
                        }
                        b'!' => {
                            self.advance();
                            state = State::SInlineDirective;
                        }
                        _ => {
                            self.mark();
                            state = State::SInlineText;
                        }
                            }
                        }
                    }
                }
                State::SInlineContent => {
                    if self.current_column()  <=  elem_col {
    self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
    return;
}
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            self.advance();
                            state = State::SChildren;
                        }
                        b';' => {
                            self.advance();
                            state = State::SElemCommentCheck;
                        }
                        b':' => {
                            self.advance();
                            state = State::SInlineAttrKey;
                        }
                        b'|' => {
                            self.advance();
                            state = State::SInlineCheckPipe;
                        }
                        b'!' => {
                            self.advance();
                            state = State::SInlineDirective;
                        }
                        _ => {
                            self.mark();
                            state = State::SInlineText;
                        }
                            }
                        }
                    }
                }
                State::SInlineText => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to4(b'\n', b';', b'|', b'!') {
                        Some(b'\n') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.advance();
                            state = State::SChildren;
                        }
                        Some(b';') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.advance();
                            state = State::SElemCommentCheck;
                        }
                        Some(b'|') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.advance();
                            state = State::SInlineCheckPipe;
                        }
                        Some(b'!') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.advance();
                            state = State::SInlineDirective;
                        }
                        None => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SInlineDirective => {
                    match self.peek() {
                        None => {
                            self.emit_bang_text();
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'{' => {
                            self.advance();
                            state = State::SInlineDirBrace;
                        }
                        _ => {
                            self.emit_bang_text();
                            self.mark();
                            state = State::SInlineText;
                        }
                            }
                        }
                    }
                }
                State::SInlineDirBrace => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'{' => {
                            self.advance();
                            self.mark();
                            state = State::SInlineInterp;
                        }
                        b':' => {
                            self.advance();
                            self.mark();
                            state = State::SInlineRawLabel;
                        }
                        b if self.is_label_start(b) => {
                            self.mark();
                            state = State::SInlineInlineDirName;
                        }
                        _ => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::IncompleteDirective, span: self.span_from_mark() });
                            state = State::SInlineText;
                        }
                            }
                        }
                    }
                }
                State::SInlineRawLabel => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b':' => {
                            { let name = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::DirectiveStart { name, raw: true, span }); }
                            self.advance();
                            state = State::SInlineRawContent;
                        }
                        b if self.is_label_continue(b) => {
                            self.advance();
                        }
                        _ => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::InvalidLabel, span: self.span_from_mark() });
                            state = State::SInlineText;
                        }
                            }
                        }
                    }
                }
                State::SInlineRawContent => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            self.mark();
                            state = State::SInlineText;
                        }
                        _ => {
                            self.mark();
                            state = State::SInlineRawBody;
                        }
                            }
                        }
                    }
                }
                State::SInlineRawBody => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::DirectiveBody { content, span }); }
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            self.mark();
                            state = State::SInlineText;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SInlineRawN1;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SInlineRawN1 => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            state = State::SInlineRawBody;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SInlineRawN2;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SInlineRawN2 => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            state = State::SInlineRawN1;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SInlineRawN3;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SInlineRawN3 => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            state = State::SInlineRawN2;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SInlineInterp => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to2(b'}', b'{') {
                        Some(b'}') => {
                            { let expression = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Interpolation { expression, span }); }
                            state = State::SInlineInterpClose;
                        }
                        Some(b'{') => {
                            self.advance();
                            state = State::SInlineInterpNested;
                        }
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SInlineInterpClose => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            state = State::SInlineInterpClose2;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SInlineInterp;
                        }
                        _ => {
                            self.advance();
                            state = State::SInlineInterp;
                        }
                            }
                        }
                    }
                }
                State::SInlineInterpClose2 => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            state = State::SInlineAfterInterp;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SInlineInterp;
                        }
                        _ => {
                            self.advance();
                            state = State::SInlineInterp;
                        }
                            }
                        }
                    }
                }
                State::SInlineInterpNested => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            state = State::SInlineInterp;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SInlineInterpNested2;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SInlineInterpNested2 => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            state = State::SInlineInterpNested;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SInlineAfterInterp => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            self.advance();
                            state = State::SChildren;
                        }
                        b';' => {
                            self.advance();
                            state = State::SElemCommentCheck;
                        }
                        b'|' => {
                            self.advance();
                            state = State::SInlineCheckPipe;
                        }
                        b'!' => {
                            self.advance();
                            state = State::SInlineDirective;
                        }
                        _ => {
                            self.mark();
                            state = State::SInlineText;
                        }
                            }
                        }
                    }
                }
                State::SInlineInlineDirName => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b if self.is_label_continue(b) => {
                            self.advance();
                        }
                        b':' => {
                            // TODO: emit DirectiveName
                            state = State::SInlineInlineDirNs;
                        }
                        b' ' | b'\t' => {
                            // TODO: emit DirectiveName
                            state = State::SInlineInlineDirBody;
                        }
                        b'}' => {
                            // TODO: emit DirectiveName
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            state = State::SInlineAfterInterp;
                        }
                        _ => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::IncompleteDirective, span: self.span_from_mark() });
                            state = State::SInlineText;
                        }
                            }
                        }
                    }
                }
                State::SInlineInlineDirNs => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b if self.is_label_start(b) => {
                            self.mark();
                            state = State::SInlineInlineDirKind;
                        }
                        _ => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::IncompleteDirective, span: self.span_from_mark() });
                            state = State::SInlineText;
                        }
                            }
                        }
                    }
                }
                State::SInlineInlineDirKind => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b if self.is_label_continue(b) => {
                            self.advance();
                        }
                        b' ' | b'\t' => {
                            // TODO: emit DirectiveKind
                            state = State::SInlineInlineDirBody;
                        }
                        b'}' => {
                            // TODO: emit DirectiveKind
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            state = State::SInlineAfterInterp;
                        }
                        _ => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::IncompleteDirective, span: self.span_from_mark() });
                            state = State::SInlineText;
                        }
                            }
                        }
                    }
                }
                State::SInlineInlineDirBody => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::DirectiveBody { content, span }); }
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            state = State::SInlineAfterInterp;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SInlineInlineDirNested;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SInlineInlineDirNested => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            state = State::SInlineInlineDirBody;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SInlineInlineDirNested2;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SInlineInlineDirNested2 => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            state = State::SInlineInlineDirNested;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SInlineCheckPipe => {
                    match self.peek() {
                        None => {
                            self.emit_pipe_text();
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'{' => {
                            self.parse_element(self.current_column());
                            state = State::SInlineAfterElement;
                        }
                        b if self.is_label_start(b) => {
                            self.parse_element(self.current_column());
                            state = State::SInlineAfterElement;
                        }
                        b'[' => {
                            self.parse_element(self.current_column());
                            state = State::SInlineAfterElement;
                        }
                        b'.' => {
                            self.parse_element(self.current_column());
                            state = State::SInlineAfterElement;
                        }
                        b'?' => {
                            self.parse_element(self.current_column());
                            state = State::SInlineAfterElement;
                        }
                        b'!' => {
                            self.parse_element(self.current_column());
                            state = State::SInlineAfterElement;
                        }
                        b'*' => {
                            self.parse_element(self.current_column());
                            state = State::SInlineAfterElement;
                        }
                        b'+' => {
                            self.parse_element(self.current_column());
                            state = State::SInlineAfterElement;
                        }
                        b'\'' => {
                            self.parse_element(self.current_column());
                            state = State::SInlineAfterElement;
                        }
                        _ => {
                            self.emit_pipe_text();
                            self.mark();
                            state = State::SInlineText;
                        }
                            }
                        }
                    }
                }
                State::SInlineAfterElement => {
                    if self.current_column()  <=  elem_col {
    self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
    return;
}
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            self.advance();
                            state = State::SChildren;
                        }
                        b';' => {
                            self.advance();
                            state = State::SElemCommentCheck;
                        }
                        b':' => {
                            self.advance();
                            state = State::SInlineAttrKey;
                        }
                        b'|' => {
                            self.advance();
                            state = State::SInlineCheckPipe;
                        }
                        b' ' | b'\t' => {
                            self.mark();
                            state = State::SInlineText;
                        }
                        b'!' => {
                            self.advance();
                            state = State::SInlineDirective;
                        }
                        b'?' | b'.' | b',' | b')' | b'}' | b'\\' => {
                            self.mark();
                            state = State::SInlineText;
                        }
                        _ => {
                            state = State::SChildrenContent;
                        }
                            }
                        }
                    }
                }
                State::SElemCommentCheck => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'{' => {
                            self.advance();
                            self.mark();
                            state = State::SElemInlineComment;
                        }
                        _ => {
                            self.mark();
                            state = State::SElemLineComment;
                        }
                            }
                        }
                    }
                }
                State::SElemInlineComment => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedComment, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Comment { content, span }); }
                            self.advance();
                            state = State::SInlineContent;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SElemInlineCommentNested;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SElemInlineCommentNested => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedComment, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            state = State::SElemInlineComment;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SElemInlineCommentNested2;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SElemInlineCommentNested2 => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedComment, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            state = State::SElemInlineCommentNested;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SElemLineComment => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to1(b'\n') {
                        Some(b'\n') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Comment { content, span }); }
                            self.advance();
                            state = State::SChildren;
                        }
                        None => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Comment { content, span }); }
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SInlineAttrKey => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::ExpectedAttrKey, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b if self.is_label_start(b) => {
                            self.mark();
                            state = State::SInlineAttrKeyScan;
                        }
                        b'\'' => {
                            self.advance();
                            state = State::SInlineAttrKeyQuoted;
                        }
                        b'[' => {
                            self.advance();
                            self.mark();
                            state = State::SInlineAttrMerge;
                        }
                        _ => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::ExpectedAttrKey, span: self.span_from_mark() });
                            state = State::SInlineContent;
                        }
                            }
                        }
                    }
                }
                State::SInlineAttrMerge => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedRef, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b']' => {
                            { let id = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::AttributeMerge { id, span }); }
                            self.advance();
                            state = State::SInlineAttrAfterMerge;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SInlineAttrAfterMerge => {
                    match self.peek() {
                        None => {
                            state = State::SInlineContent;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            state = State::SChildren;
                        }
                        b';' => {
                            state = State::SElemCommentCheck;
                        }
                        b':' => {
                            self.advance();
                            state = State::SInlineAttrKey;
                        }
                        b' ' | b'\t' => {
                            self.advance();
                        }
                        b'|' => {
                            self.parse_element(self.current_column());
                            state = State::SChildrenAfterElement;
                        }
                        _ => {
                            self.mark();
                            state = State::SInlineText;
                        }
                            }
                        }
                    }
                }
                State::SInlineAttrKeyScan => {
                    match self.peek() {
                        None => {
                            { let key = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Attribute { key, span }); }
                            state = State::SInlineAttrWs;
                        }
                        Some(b) => {
                            match b {
                        b if self.is_label_continue(b) => {
                            self.advance();
                        }
                        _ => {
                            { let key = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Attribute { key, span }); }
                            state = State::SInlineAttrWs;
                        }
                            }
                        }
                    }
                }
                State::SInlineAttrKeyQuoted => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedQuote, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\'' => {
                            self.mark();
                            { let key = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Attribute { key, span }); }
                            self.advance();
                            state = State::SInlineAttrWs;
                        }
                        _ => {
                            self.mark();
                            state = State::SInlineAttrKeyQuotedContent;
                        }
                            }
                        }
                    }
                }
                State::SInlineAttrKeyQuotedContent => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedQuote, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\'' => {
                            { let key = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Attribute { key, span }); }
                            self.advance();
                            state = State::SInlineAttrWs;
                        }
                        b'\\' => {
                            self.advance();
                            state = State::SInlineAttrKeyQuotedEsc;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SInlineAttrKeyQuotedEsc => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedQuote, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        _ => {
                            self.advance();
                            state = State::SInlineAttrKeyQuotedContent;
                        }
                            }
                        }
                    }
                }
                State::SInlineAttrWs => {
                    match self.peek() {
                        None => {
                            state = State::SInlineAttrValue;
                        }
                        Some(b) => {
                            match b {
                        b' ' | b'\t' => {
                            self.advance();
                        }
                        _ => {
                            state = State::SInlineAttrValue;
                        }
                            }
                        }
                    }
                }
                State::SInlineAttrValue => {
                    match self.peek() {
                        None => {
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            state = State::SInlineContent;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            state = State::SChildren;
                        }
                        b';' => {
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            state = State::SElemCommentCheck;
                        }
                        b':' => {
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            self.advance();
                            state = State::SInlineAttrKey;
                        }
                        b'[' => {
                            self.emit(StreamingEvent::ArrayStart { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            self.parse_array();
                            state = State::SInlineAttrAfterValue;
                        }
                        b'"' => {
                            self.advance();
                            state = State::SInlineAttrDquote;
                        }
                        b'\'' => {
                            self.advance();
                            state = State::SInlineAttrSquote;
                        }
                        _ => {
                            self.mark();
                            state = State::SInlineAttrBare;
                        }
                            }
                        }
                    }
                }
                State::SInlineAttrDquote => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedString, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'"' => {
                            self.mark();
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SInlineAttrAfterValue;
                        }
                        _ => {
                            self.mark();
                            state = State::SInlineAttrDquoteContent;
                        }
                            }
                        }
                    }
                }
                State::SInlineAttrDquoteContent => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to2(b'"', b'\\') {
                        Some(b'"') => {
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SInlineAttrAfterValue;
                        }
                        Some(b'\\') => {
                            self.advance();
                            state = State::SInlineAttrDquoteEsc;
                        }
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedString, span: self.span_from_mark() });
                            state = State::SInlineContent;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SInlineAttrDquoteEsc => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedString, span: self.span_from_mark() });
                            state = State::SInlineContent;
                        }
                        Some(b) => {
                            match b {
                        _ => {
                            self.advance();
                            state = State::SInlineAttrDquoteContent;
                        }
                            }
                        }
                    }
                }
                State::SInlineAttrSquote => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedString, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\'' => {
                            self.mark();
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SInlineAttrAfterValue;
                        }
                        _ => {
                            self.mark();
                            state = State::SInlineAttrSquoteContent;
                        }
                            }
                        }
                    }
                }
                State::SInlineAttrSquoteContent => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to2(b'\'', b'\\') {
                        Some(b'\'') => {
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SInlineAttrAfterValue;
                        }
                        Some(b'\\') => {
                            self.advance();
                            state = State::SInlineAttrSquoteEsc;
                        }
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedString, span: self.span_from_mark() });
                            state = State::SInlineContent;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SInlineAttrSquoteEsc => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedString, span: self.span_from_mark() });
                            state = State::SInlineContent;
                        }
                        Some(b) => {
                            match b {
                        _ => {
                            self.advance();
                            state = State::SInlineAttrSquoteContent;
                        }
                            }
                        }
                    }
                }
                State::SInlineAttrBare => {
                    match self.peek() {
                        None => {
                            self.emit_typed_value();
                            state = State::SInlineContent;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            self.emit_typed_value();
                            state = State::SChildren;
                        }
                        b' ' | b'\t' => {
                            self.emit_typed_value();
                            state = State::SInlineAttrAfterValue;
                        }
                        b';' => {
                            self.emit_typed_value();
                            state = State::SElemCommentCheck;
                        }
                        b':' => {
                            self.emit_typed_value();
                            state = State::SInlineAttrKey;
                        }
                        b'|' => {
                            self.emit_typed_value();
                            self.parse_element(self.current_column());
                            state = State::SChildrenAfterElement;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SInlineAttrAfterValue => {
                    match self.peek() {
                        None => {
                            state = State::SInlineContent;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            state = State::SChildren;
                        }
                        b';' => {
                            state = State::SElemCommentCheck;
                        }
                        b':' => {
                            self.advance();
                            state = State::SInlineAttrKey;
                        }
                        b' ' | b'\t' => {
                            self.advance();
                        }
                        b'|' => {
                            self.parse_element(self.current_column());
                            state = State::SChildrenAfterElement;
                        }
                        _ => {
                            self.mark();
                            state = State::SInlineText;
                        }
                            }
                        }
                    }
                }
                State::SChildren => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            self.advance();
                            state = State::SChildren;
                        }
                        b' ' => {
                            self.advance();
                            state = State::SChildren;
                        }
                        b'\t' => {
                            self.advance();
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::NoTabs, span: self.span_from_mark() });
                            state = State::SSkipChild;
                        }
                        _ => {
                            state = State::SChildrenContent;
                        }
                            }
                        }
                    }
                }
                State::SChildrenContent => {
                    if self.current_column()  <=  elem_col {
    self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
    return;
}
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\'' => {
                            self.advance();
                            state = State::SChildEscaped;
                        }
                        b';' => {
                            self.advance();
                            state = State::SChildCommentStart;
                        }
                        b'|' => {
                            self.parse_element(self.current_column());
                            state = State::SChildrenAfterElement;
                        }
                        b':' => {
                            self.advance();
                            state = State::SAttrKey;
                        }
                        b'@' => {
                            self.advance();
                            state = State::SChildIdRef;
                        }
                        b'`' => {
                            self.advance();
                            state = State::SChildFreeformCheck;
                        }
                        b'!' => {
                            self.parse_directive(self.current_column());
                            state = State::SChildrenAfterDirective;
                        }
                        _ => {
                            self.mark();
                            state = State::SChildProse;
                        }
                            }
                        }
                    }
                }
                State::SChildrenAfterElement => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            self.advance();
                            state = State::SChildren;
                        }
                        b' ' => {
                            self.advance();
                            state = State::SChildrenCountWs;
                        }
                        b'\t' => {
                            self.advance();
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::NoTabs, span: self.span_from_mark() });
                            state = State::SSkipChild;
                        }
                        _ => {
                            state = State::SChildrenContent;
                        }
                            }
                        }
                    }
                }
                State::SChildrenAfterDirective => {
                    if self.current_column()  <=  elem_col {
    self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
    return;
}
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            self.advance();
                            state = State::SChildren;
                        }
                        b'\t' => {
                            self.advance();
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::NoTabs, span: self.span_from_mark() });
                            state = State::SSkipChild;
                        }
                        _ => {
                            self.mark();
                            state = State::SChildProseCont;
                        }
                            }
                        }
                    }
                }
                State::SChildrenCountWs => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            self.advance();
                            state = State::SChildren;
                        }
                        b' ' => {
                            self.advance();
                            state = State::SChildrenCountWs;
                        }
                        b'\t' => {
                            self.advance();
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::NoTabs, span: self.span_from_mark() });
                            state = State::SSkipChild;
                        }
                        _ => {
                            state = State::SChildrenContent;
                        }
                            }
                        }
                    }
                }
                State::SChildEscaped => {
                    match self.peek() {
                        None => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.advance();
                            state = State::SChildren;
                        }
                        _ => {
                            self.mark();
                            state = State::SChildEscapedText;
                        }
                            }
                        }
                    }
                }
                State::SChildEscapedText => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to1(b'\n') {
                        Some(b'\n') => {
                            self.emit_dedented_text(&mut content_base);
                            self.advance();
                            state = State::SChildren;
                        }
                        None => {
                            self.emit_dedented_text(&mut content_base);
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SChildProse => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to4(b'\n', b';', b'|', b'!') {
                        Some(b'\n') => {
                            self.emit_dedented_text(&mut content_base);
                            self.advance();
                            state = State::SChildren;
                        }
                        Some(b';') => {
                            self.emit_dedented_text(&mut content_base);
                            self.advance();
                            state = State::SChildCommentCheck;
                        }
                        Some(b'|') => {
                            self.emit_dedented_text(&mut content_base);
                            self.parse_element(self.current_column());
                            state = State::SChildrenAfterElement;
                        }
                        Some(b'!') => {
                            self.emit_dedented_text(&mut content_base);
                            self.parse_directive(self.current_column());
                            state = State::SChildrenAfterDirective;
                        }
                        None => {
                            self.emit_dedented_text(&mut content_base);
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SChildProseCont => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to4(b'\n', b';', b'|', b'!') {
                        Some(b'\n') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.advance();
                            state = State::SChildren;
                        }
                        Some(b';') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.advance();
                            state = State::SChildCommentCheck;
                        }
                        Some(b'|') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.parse_element(self.current_column());
                            state = State::SChildrenAfterElement;
                        }
                        Some(b'!') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.parse_directive(self.current_column());
                            state = State::SChildrenAfterDirective;
                        }
                        None => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SChildIdRef => {
                    match self.peek() {
                        None => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'[' => {
                            self.advance();
                            self.mark();
                            state = State::SChildIdRefValue;
                        }
                        _ => {
                            self.mark();
                            state = State::SChildProse;
                        }
                            }
                        }
                    }
                }
                State::SChildIdRefValue => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedRef, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b']' => {
                            { let id = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::IdReference { id, span }); }
                            self.advance();
                            state = State::SChildren;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SChildCommentStart => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'{' => {
                            self.advance();
                            self.mark();
                            state = State::SChildInlineComment;
                        }
                        _ => {
                            self.mark();
                            state = State::SChildBlockComment;
                        }
                            }
                        }
                    }
                }
                State::SChildCommentCheck => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'{' => {
                            self.advance();
                            self.mark();
                            state = State::SChildInlineComment;
                        }
                        _ => {
                            self.mark();
                            state = State::SChildLineComment;
                        }
                            }
                        }
                    }
                }
                State::SChildInlineComment => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedComment, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Comment { content, span }); }
                            self.advance();
                            state = State::SChildProseAfterComment;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SChildInlineCommentNested;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SChildInlineCommentNested => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedComment, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            state = State::SChildInlineComment;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SChildInlineCommentNested2;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SChildInlineCommentNested2 => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedComment, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            state = State::SChildInlineCommentNested;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SChildProseAfterComment => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            self.advance();
                            state = State::SChildren;
                        }
                        b';' => {
                            self.advance();
                            state = State::SChildCommentCheck;
                        }
                        b'|' => {
                            self.emit_dedented_text(&mut content_base);
                            self.parse_element(self.current_column());
                            state = State::SChildrenAfterElement;
                        }
                        _ => {
                            self.mark();
                            state = State::SChildProse;
                        }
                            }
                        }
                    }
                }
                State::SChildLineComment => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to1(b'\n') {
                        Some(b'\n') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Comment { content, span }); }
                            self.advance();
                            state = State::SChildren;
                        }
                        None => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Comment { content, span }); }
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SChildBlockComment => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to1(b'\n') {
                        Some(b'\n') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Comment { content, span }); }
                            self.advance();
                            state = State::SChildren;
                        }
                        None => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Comment { content, span }); }
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SChildFreeformCheck => {
                    match self.peek() {
                        None => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'`' => {
                            self.advance();
                            state = State::SChildFreeformCheck2;
                        }
                        _ => {
                            self.mark();
                            state = State::SChildProse;
                        }
                            }
                        }
                    }
                }
                State::SChildFreeformCheck2 => {
                    match self.peek() {
                        None => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'`' => {
                            self.advance();
                            state = State::SChildFreeformStart;
                        }
                        _ => {
                            self.mark();
                            state = State::SChildProse;
                        }
                            }
                        }
                    }
                }
                State::SChildFreeformStart => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedFreeform, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            self.advance();
                            self.mark();
                            state = State::SChildFreeform;
                        }
                        _ => {
                            self.mark();
                            state = State::SChildFreeform;
                        }
                            }
                        }
                    }
                }
                State::SChildFreeform => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedFreeform, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'`' => {
                            self.advance();
                            state = State::SChildFreeformEnd1;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SChildFreeformEnd1 => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedFreeform, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'`' => {
                            self.advance();
                            state = State::SChildFreeformEnd2;
                        }
                        _ => {
                            self.advance();
                            state = State::SChildFreeform;
                        }
                            }
                        }
                    }
                }
                State::SChildFreeformEnd2 => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedFreeform, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'`' => {
                            { let content = self.term_adjusted(-2); let span = self.span_from_mark(); self.emit(StreamingEvent::RawContent { content, span }); }
                            self.advance();
                            state = State::SChildren;
                        }
                        _ => {
                            self.advance();
                            state = State::SChildFreeform;
                        }
                            }
                        }
                    }
                }
                State::SSkipChild => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            self.advance();
                            state = State::SChildren;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SAttrKey => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::ExpectedAttrKey, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b if self.is_label_start(b) => {
                            self.mark();
                            state = State::SAttrKeyScan;
                        }
                        b'\'' => {
                            self.advance();
                            state = State::SAttrKeyQuoted;
                        }
                        b'[' => {
                            self.advance();
                            self.mark();
                            state = State::SAttrMerge;
                        }
                        _ => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::ExpectedAttrKey, span: self.span_from_mark() });
                            state = State::SChildren;
                        }
                            }
                        }
                    }
                }
                State::SAttrMerge => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedRef, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b']' => {
                            { let id = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::AttributeMerge { id, span }); }
                            self.advance();
                            state = State::SAttrAfterMerge;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SAttrAfterMerge => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            self.advance();
                            state = State::SChildren;
                        }
                        b';' => {
                            self.advance();
                            self.mark();
                            state = State::SChildBlockComment;
                        }
                        b':' => {
                            self.advance();
                            state = State::SAttrKey;
                        }
                        b' ' | b'\t' => {
                            self.advance();
                        }
                        _ => {
                            self.mark();
                            state = State::SChildProse;
                        }
                            }
                        }
                    }
                }
                State::SAttrKeyScan => {
                    match self.peek() {
                        None => {
                            { let key = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Attribute { key, span }); }
                            state = State::SAttrWs;
                        }
                        Some(b) => {
                            match b {
                        b if self.is_label_continue(b) => {
                            self.advance();
                        }
                        _ => {
                            { let key = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Attribute { key, span }); }
                            state = State::SAttrWs;
                        }
                            }
                        }
                    }
                }
                State::SAttrKeyQuoted => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedQuote, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\'' => {
                            self.mark();
                            { let key = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Attribute { key, span }); }
                            self.advance();
                            state = State::SAttrWs;
                        }
                        _ => {
                            self.mark();
                            state = State::SAttrKeyQuotedContent;
                        }
                            }
                        }
                    }
                }
                State::SAttrKeyQuotedContent => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedQuote, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\'' => {
                            { let key = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Attribute { key, span }); }
                            state = State::SAttrWs;
                        }
                        b'\\' => {
                            self.advance();
                            state = State::SAttrKeyQuotedEsc;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SAttrKeyQuotedEsc => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedQuote, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        _ => {
                            self.advance();
                            state = State::SAttrKeyQuotedContent;
                        }
                            }
                        }
                    }
                }
                State::SAttrWs => {
                    match self.peek() {
                        None => {
                            state = State::SAttrValue;
                        }
                        Some(b) => {
                            match b {
                        b' ' | b'\t' => {
                            self.advance();
                        }
                        _ => {
                            state = State::SAttrValue;
                        }
                            }
                        }
                    }
                }
                State::SAttrValue => {
                    match self.peek() {
                        None => {
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            state = State::SChildren;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            state = State::SChildren;
                        }
                        b';' => {
                            { let span = self.span_from_mark(); self.emit(StreamingEvent::BoolValue { value: true, span }); }
                            state = State::SAttrComment;
                        }
                        b'[' => {
                            self.emit(StreamingEvent::ArrayStart { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            self.parse_array();
                            state = State::SAttrAfterValue;
                        }
                        b'"' => {
                            self.advance();
                            state = State::SAttrDquote;
                        }
                        b'\'' => {
                            self.advance();
                            state = State::SAttrSquote;
                        }
                        _ => {
                            self.mark();
                            state = State::SAttrBare;
                        }
                            }
                        }
                    }
                }
                State::SAttrComment => {
                    match self.peek() {
                        None => {
                            state = State::SChildren;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            state = State::SChildren;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SAttrDquote => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedString, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'"' => {
                            self.mark();
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SAttrAfterValue;
                        }
                        _ => {
                            self.mark();
                            state = State::SAttrDquoteContent;
                        }
                            }
                        }
                    }
                }
                State::SAttrDquoteContent => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to2(b'"', b'\\') {
                        Some(b'"') => {
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SAttrAfterValue;
                        }
                        Some(b'\\') => {
                            self.advance();
                            state = State::SAttrDquoteEsc;
                        }
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedString, span: self.span_from_mark() });
                            state = State::SChildren;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SAttrDquoteEsc => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedString, span: self.span_from_mark() });
                            state = State::SChildren;
                        }
                        Some(b) => {
                            match b {
                        _ => {
                            self.advance();
                            state = State::SAttrDquoteContent;
                        }
                            }
                        }
                    }
                }
                State::SAttrSquote => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedString, span: self.span_from_mark() });
                            self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\'' => {
                            self.mark();
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SAttrAfterValue;
                        }
                        _ => {
                            self.mark();
                            state = State::SAttrSquoteContent;
                        }
                            }
                        }
                    }
                }
                State::SAttrSquoteContent => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to2(b'\'', b'\\') {
                        Some(b'\'') => {
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SAttrAfterValue;
                        }
                        Some(b'\\') => {
                            self.advance();
                            state = State::SAttrSquoteEsc;
                        }
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedString, span: self.span_from_mark() });
                            state = State::SChildren;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SAttrSquoteEsc => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedString, span: self.span_from_mark() });
                            state = State::SChildren;
                        }
                        Some(b) => {
                            match b {
                        _ => {
                            self.advance();
                            state = State::SAttrSquoteContent;
                        }
                            }
                        }
                    }
                }
                State::SAttrBare => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to2(b'\n', b';') {
                        Some(b'\n') => {
                            self.emit_typed_value();
                            state = State::SChildren;
                        }
                        Some(b';') => {
                            self.emit_typed_value();
                            state = State::SAttrComment;
                        }
                        None => {
                            self.emit_typed_value();
                            state = State::SChildren;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SAttrAfterValue => {
                    match self.peek() {
                        None => {
                            state = State::SChildren;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            state = State::SChildren;
                        }
                        b';' => {
                            state = State::SAttrComment;
                        }
                        b' ' | b'\t' => {
                            self.advance();
                        }
                        _ => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnexpectedAfterValue, span: self.span_from_mark() });
                            state = State::SAttrSkipLine;
                        }
                            }
                        }
                    }
                }
                State::SAttrSkipLine => {
                    match self.peek() {
                        None => {
                            state = State::SChildren;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            state = State::SChildren;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
            }
        }
    }

    fn parse_array(&mut self) {
        #[derive(Clone, Copy)]
        enum State { SValues, SDquote, SDquoteContent, SDquoteEsc, SSquote, SSquoteContent, SSquoteEsc, SBare }

        let mut state = State::SValues;
        loop {
            match state {
                State::SValues => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedArray, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b' ' | b'\t' => {
                            self.advance();
                        }
                        b'\n' => {
                            self.advance();
                        }
                        b']' => {
                            self.emit(StreamingEvent::ArrayEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            return;
                        }
                        b'"' => {
                            self.advance();
                            state = State::SDquote;
                        }
                        b'\'' => {
                            self.advance();
                            state = State::SSquote;
                        }
                        b'[' => {
                            self.emit(StreamingEvent::ArrayStart { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            self.parse_array();
                            state = State::SValues;
                        }
                        _ => {
                            self.mark();
                            state = State::SBare;
                        }
                            }
                        }
                    }
                }
                State::SDquote => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedString, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'"' => {
                            self.mark();
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SValues;
                        }
                        _ => {
                            self.mark();
                            state = State::SDquoteContent;
                        }
                            }
                        }
                    }
                }
                State::SDquoteContent => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to2(b'"', b'\\') {
                        Some(b'"') => {
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SValues;
                        }
                        Some(b'\\') => {
                            self.advance();
                            state = State::SDquoteEsc;
                        }
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedString, span: self.span_from_mark() });
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SDquoteEsc => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedString, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        _ => {
                            self.advance();
                            state = State::SDquoteContent;
                        }
                            }
                        }
                    }
                }
                State::SSquote => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedString, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\'' => {
                            self.mark();
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SValues;
                        }
                        _ => {
                            self.mark();
                            state = State::SSquoteContent;
                        }
                            }
                        }
                    }
                }
                State::SSquoteContent => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to2(b'\'', b'\\') {
                        Some(b'\'') => {
                            { let value = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::QuotedStringValue { value, span }); }
                            self.advance();
                            state = State::SValues;
                        }
                        Some(b'\\') => {
                            self.advance();
                            state = State::SSquoteEsc;
                        }
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedString, span: self.span_from_mark() });
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SSquoteEsc => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedString, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        _ => {
                            self.advance();
                            state = State::SSquoteContent;
                        }
                            }
                        }
                    }
                }
                State::SBare => {
                    match self.peek() {
                        None => {
                            self.emit_typed_value();
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedArray, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b' ' | b'\t' | b'\n' => {
                            self.emit_typed_value();
                            state = State::SValues;
                        }
                        b']' => {
                            self.emit_typed_value();
                            self.emit(StreamingEvent::ArrayEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            return;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
            }
        }
    }

    fn parse_directive(&mut self, dir_col: i32) {
        let mut content_base: i32 = -1;

        #[derive(Clone, Copy)]
        enum State { SStart, SDispatch, SRawLabel, SRawAfterLabel, SRawInlineWs, SRawInlineContent, SRawChildren, SRawChildrenWs, SRawChildrenContent, SRawLine, SRawSkipLine, SInlineBrace, SInlineRawLabel, SInlineRawContent, SInlineRawBody, SInlineRawN1, SInlineRawN2, SInlineRawN3, SInlineInterp, SInlineInterpClose, SInlineInterpClose2, SInlineInterpN1, SInlineInterpN2, SInlineInterpN3, SInlineName, SInlineNs, SInlineKind, SInlineBodyStart, SInlineBody, SInlineBodyN1, SInlineBodyN2, SInlineBodyN3, SInlineSkip, SBlockName, SBlockCheckRaw, SBlockStatement, SBlockStatementContent, SBlockChildren, SBlockChildrenWs, SBlockChildrenContent, SBlockAfterElement, SBlockAfterDirective, SBlockChildEscaped, SBlockChildEscapedText, SBlockChildComment, SBlockChildProse, SBlockChildCommentCheck, SBlockInlineComment, SBlockInlineCommentN1, SBlockInlineCommentN2, SBlockProseAfterComment, SBlockChildAttr, SBlockSkipLine }

        let mut state = State::SStart;
        loop {
            match state {
                State::SStart => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::IncompleteDirective, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'!' => {
                            self.advance();
                            state = State::SDispatch;
                        }
                        _ => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::IncompleteDirective, span: self.span_from_mark() });
                            return;
                        }
                            }
                        }
                    }
                }
                State::SDispatch => {
                    match self.peek() {
                        None => {
                            self.emit_bang_text();
                            return;
                        }
                        Some(b) => {
                            match b {
                        b':' => {
                            self.advance();
                            self.mark();
                            state = State::SRawLabel;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SInlineBrace;
                        }
                        b if self.is_label_start(b) => {
                            self.mark();
                            state = State::SBlockName;
                        }
                        _ => {
                            self.emit_bang_text();
                            return;
                        }
                            }
                        }
                    }
                }
                State::SRawLabel => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::IncompleteDirective, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b':' => {
                            { let name = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::DirectiveStart { name, raw: true, span }); }
                            self.advance();
                            state = State::SRawAfterLabel;
                        }
                        b if self.is_label_continue(b) => {
                            self.advance();
                        }
                        _ => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::InvalidLabel, span: self.span_from_mark() });
                            state = State::SBlockSkipLine;
                        }
                            }
                        }
                    }
                }
                State::SRawAfterLabel => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            self.advance();
                            state = State::SRawChildren;
                        }
                        b' ' | b'\t' => {
                            self.advance();
                            state = State::SRawInlineWs;
                        }
                        _ => {
                            self.mark();
                            state = State::SRawInlineContent;
                        }
                            }
                        }
                    }
                }
                State::SRawInlineWs => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            self.advance();
                            state = State::SRawChildren;
                        }
                        b' ' | b'\t' => {
                            self.advance();
                        }
                        _ => {
                            self.mark();
                            state = State::SRawInlineContent;
                        }
                            }
                        }
                    }
                }
                State::SRawInlineContent => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to1(b'\n') {
                        Some(b'\n') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.advance();
                            state = State::SRawChildren;
                        }
                        None => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SRawChildren => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            self.advance();
                        }
                        b' ' => {
                            self.advance();
                            state = State::SRawChildrenWs;
                        }
                        b'\t' => {
                            self.advance();
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::NoTabs, span: self.span_from_mark() });
                            state = State::SRawSkipLine;
                        }
                        _ => {
                            state = State::SRawChildrenContent;
                        }
                            }
                        }
                    }
                }
                State::SRawChildrenWs => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            self.advance();
                            state = State::SRawChildren;
                        }
                        b' ' => {
                            self.advance();
                        }
                        b'\t' => {
                            self.advance();
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::NoTabs, span: self.span_from_mark() });
                            state = State::SRawSkipLine;
                        }
                        _ => {
                            state = State::SRawChildrenContent;
                        }
                            }
                        }
                    }
                }
                State::SRawChildrenContent => {
                    if self.current_column()  <=  dir_col {
    self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
    return;
}
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        _ => {
                            self.mark();
                            state = State::SRawLine;
                        }
                            }
                        }
                    }
                }
                State::SRawLine => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to1(b'\n') {
                        Some(b'\n') => {
                            self.emit_dedented_text(&mut content_base);
                            self.advance();
                            state = State::SRawChildren;
                        }
                        None => {
                            self.emit_dedented_text(&mut content_base);
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SRawSkipLine => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to1(b'\n') {
                        Some(b'\n') => {
                            self.advance();
                            state = State::SRawChildren;
                        }
                        None => {
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SInlineBrace => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'{' => {
                            self.advance();
                            self.mark();
                            state = State::SInlineInterp;
                        }
                        b':' => {
                            self.advance();
                            self.mark();
                            state = State::SInlineRawLabel;
                        }
                        b if self.is_label_start(b) => {
                            self.mark();
                            state = State::SInlineName;
                        }
                        _ => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::IncompleteDirective, span: self.span_from_mark() });
                            return;
                        }
                            }
                        }
                    }
                }
                State::SInlineRawLabel => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b':' => {
                            { let name = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::DirectiveStart { name, raw: true, span }); }
                            self.advance();
                            state = State::SInlineRawContent;
                        }
                        b if self.is_label_continue(b) => {
                            self.advance();
                        }
                        _ => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::InvalidLabel, span: self.span_from_mark() });
                            state = State::SInlineSkip;
                        }
                            }
                        }
                    }
                }
                State::SInlineRawContent => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::DirectiveBody { content, span }); }
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        _ => {
                            self.mark();
                            state = State::SInlineRawBody;
                        }
                            }
                        }
                    }
                }
                State::SInlineRawBody => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::DirectiveBody { content, span }); }
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SInlineRawN1;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SInlineRawN1 => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            state = State::SInlineRawBody;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SInlineRawN2;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SInlineRawN2 => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            state = State::SInlineRawN1;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SInlineRawN3;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SInlineRawN3 => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            state = State::SInlineRawN2;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SInlineInterp => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to2(b'}', b'{') {
                        Some(b'}') => {
                            { let expression = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Interpolation { expression, span }); }
                            state = State::SInlineInterpClose;
                        }
                        Some(b'{') => {
                            self.advance();
                            state = State::SInlineInterpN1;
                        }
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SInlineInterpClose => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            state = State::SInlineInterpClose2;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SInlineInterp;
                        }
                        _ => {
                            self.advance();
                            state = State::SInlineInterp;
                        }
                            }
                        }
                    }
                }
                State::SInlineInterpClose2 => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            return;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SInlineInterp;
                        }
                        _ => {
                            self.advance();
                            state = State::SInlineInterp;
                        }
                            }
                        }
                    }
                }
                State::SInlineInterpN1 => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            state = State::SInlineInterp;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SInlineInterpN2;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SInlineInterpN2 => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            state = State::SInlineInterpN1;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SInlineInterpN3;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SInlineInterpN3 => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            state = State::SInlineInterpN2;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SInlineName => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b if self.is_label_continue(b) => {
                            self.advance();
                        }
                        b':' => {
                            // TODO: emit DirectiveName
                            state = State::SInlineNs;
                        }
                        b' ' | b'\t' => {
                            // TODO: emit DirectiveName
                            state = State::SInlineBodyStart;
                        }
                        b'}' => {
                            // TODO: emit DirectiveName
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        _ => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::IncompleteDirective, span: self.span_from_mark() });
                            state = State::SInlineSkip;
                        }
                            }
                        }
                    }
                }
                State::SInlineNs => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b if self.is_label_start(b) => {
                            self.mark();
                            state = State::SInlineKind;
                        }
                        _ => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::IncompleteDirective, span: self.span_from_mark() });
                            state = State::SInlineSkip;
                        }
                            }
                        }
                    }
                }
                State::SInlineKind => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b if self.is_label_continue(b) => {
                            self.advance();
                        }
                        b' ' | b'\t' => {
                            // TODO: emit DirectiveKind
                            state = State::SInlineBodyStart;
                        }
                        b'}' => {
                            // TODO: emit DirectiveKind
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        _ => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::IncompleteDirective, span: self.span_from_mark() });
                            state = State::SInlineSkip;
                        }
                            }
                        }
                    }
                }
                State::SInlineBodyStart => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b' ' | b'\t' => {
                            self.advance();
                        }
                        b'}' => {
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        _ => {
                            self.mark();
                            state = State::SInlineBody;
                        }
                            }
                        }
                    }
                }
                State::SInlineBody => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to2(b'}', b'{') {
                        Some(b'}') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::DirectiveBody { content, span }); }
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b'{') => {
                            self.advance();
                            state = State::SInlineBodyN1;
                        }
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SInlineBodyN1 => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to2(b'}', b'{') {
                        Some(b'}') => {
                            self.advance();
                            state = State::SInlineBody;
                        }
                        Some(b'{') => {
                            self.advance();
                            state = State::SInlineBodyN2;
                        }
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SInlineBodyN2 => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to2(b'}', b'{') {
                        Some(b'}') => {
                            self.advance();
                            state = State::SInlineBodyN1;
                        }
                        Some(b'{') => {
                            self.advance();
                            state = State::SInlineBodyN3;
                        }
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SInlineBodyN3 => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to1(b'}') {
                        Some(b'}') => {
                            self.advance();
                            state = State::SInlineBodyN2;
                        }
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::Unclosed, span: self.span_from_mark() });
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SInlineSkip => {
                    match self.peek() {
                        None => {
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            return;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SBlockName => {
                    match self.peek() {
                        None => {
                            { let name = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::DirectiveStart { name, raw: false, span }); }
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            { let name = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::DirectiveStart { name, raw: false, span }); }
                            self.advance();
                            state = State::SBlockChildren;
                        }
                        b':' => {
                            self.advance();
                            state = State::SBlockCheckRaw;
                        }
                        b' ' | b'\t' => {
                            { let name = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::DirectiveStart { name, raw: false, span }); }
                            self.advance();
                            state = State::SBlockStatement;
                        }
                        b if self.is_label_continue(b) => {
                            self.advance();
                        }
                        _ => {
                            { let name = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::DirectiveStart { name, raw: false, span }); }
                            state = State::SBlockStatement;
                        }
                            }
                        }
                    }
                }
                State::SBlockCheckRaw => {
                    match self.peek() {
                        None => {
                            { let name = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::DirectiveStart { name, raw: false, span }); }
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            { let name = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::DirectiveStart { name, raw: false, span }); }
                            self.advance();
                            state = State::SBlockChildren;
                        }
                        b' ' | b'\t' => {
                            { let name = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::DirectiveStart { name, raw: false, span }); }
                            self.advance();
                            state = State::SBlockStatement;
                        }
                        b if self.is_label_continue(b) => {
                            self.advance();
                            state = State::SBlockName;
                        }
                        _ => {
                            { let name = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::DirectiveStart { name, raw: false, span }); }
                            state = State::SBlockStatement;
                        }
                            }
                        }
                    }
                }
                State::SBlockStatement => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b' ' | b'\t' => {
                            self.advance();
                        }
                        b'\n' => {
                            self.advance();
                            state = State::SBlockChildren;
                        }
                        _ => {
                            self.mark();
                            state = State::SBlockStatementContent;
                        }
                            }
                        }
                    }
                }
                State::SBlockStatementContent => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to1(b'\n') {
                        Some(b'\n') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::DirectiveStatement { content, span }); }
                            self.advance();
                            state = State::SBlockChildren;
                        }
                        None => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::DirectiveStatement { content, span }); }
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SBlockChildren => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            self.advance();
                        }
                        b' ' => {
                            self.advance();
                            state = State::SBlockChildrenWs;
                        }
                        b'\t' => {
                            self.advance();
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::NoTabs, span: self.span_from_mark() });
                            state = State::SBlockSkipLine;
                        }
                        _ => {
                            state = State::SBlockChildrenContent;
                        }
                            }
                        }
                    }
                }
                State::SBlockChildrenWs => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            self.advance();
                            state = State::SBlockChildren;
                        }
                        b' ' => {
                            self.advance();
                        }
                        b'\t' => {
                            self.advance();
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::NoTabs, span: self.span_from_mark() });
                            state = State::SBlockSkipLine;
                        }
                        _ => {
                            state = State::SBlockChildrenContent;
                        }
                            }
                        }
                    }
                }
                State::SBlockChildrenContent => {
                    if self.current_column()  <=  dir_col {
    self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
    return;
}
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\'' => {
                            self.advance();
                            state = State::SBlockChildEscaped;
                        }
                        b';' => {
                            self.advance();
                            self.mark();
                            state = State::SBlockChildComment;
                        }
                        b'|' => {
                            self.parse_element(self.current_column());
                            state = State::SBlockAfterElement;
                        }
                        b'!' => {
                            self.parse_directive(self.current_column());
                            state = State::SBlockAfterDirective;
                        }
                        b':' => {
                            self.advance();
                            state = State::SBlockChildAttr;
                        }
                        _ => {
                            self.mark();
                            state = State::SBlockChildProse;
                        }
                            }
                        }
                    }
                }
                State::SBlockAfterElement => {
                    if self.current_column()  <=  dir_col {
    self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
    return;
}
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            self.advance();
                            state = State::SBlockChildren;
                        }
                        b' ' => {
                            self.advance();
                            state = State::SBlockChildrenWs;
                        }
                        b'\t' => {
                            self.advance();
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::NoTabs, span: self.span_from_mark() });
                            state = State::SBlockSkipLine;
                        }
                        _ => {
                            state = State::SBlockChildrenContent;
                        }
                            }
                        }
                    }
                }
                State::SBlockAfterDirective => {
                    if self.current_column()  <=  dir_col {
    self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
    return;
}
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            self.advance();
                            state = State::SBlockChildren;
                        }
                        b' ' => {
                            self.advance();
                            state = State::SBlockChildrenWs;
                        }
                        b'\t' => {
                            self.advance();
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::NoTabs, span: self.span_from_mark() });
                            state = State::SBlockSkipLine;
                        }
                        _ => {
                            state = State::SBlockChildrenContent;
                        }
                            }
                        }
                    }
                }
                State::SBlockChildEscaped => {
                    match self.peek() {
                        None => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.advance();
                            state = State::SBlockChildren;
                        }
                        _ => {
                            self.mark();
                            state = State::SBlockChildEscapedText;
                        }
                            }
                        }
                    }
                }
                State::SBlockChildEscapedText => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to1(b'\n') {
                        Some(b'\n') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.advance();
                            state = State::SBlockChildren;
                        }
                        None => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Text { content, span }); }
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SBlockChildComment => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to1(b'\n') {
                        Some(b'\n') => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Comment { content, span }); }
                            self.advance();
                            state = State::SBlockChildren;
                        }
                        None => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Comment { content, span }); }
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SBlockChildProse => {
                    // SCAN-first: bulk scan and match result
                    match self.scan_to4(b'\n', b';', b'|', b'!') {
                        Some(b'\n') => {
                            self.emit_dedented_text(&mut content_base);
                            self.advance();
                            state = State::SBlockChildren;
                        }
                        Some(b';') => {
                            self.emit_dedented_text(&mut content_base);
                            self.advance();
                            state = State::SBlockChildCommentCheck;
                        }
                        Some(b'|') => {
                            self.emit_dedented_text(&mut content_base);
                            self.parse_element(self.current_column());
                            state = State::SBlockAfterElement;
                        }
                        Some(b'!') => {
                            self.emit_dedented_text(&mut content_base);
                            self.parse_directive(self.current_column());
                            state = State::SBlockAfterDirective;
                        }
                        None => {
                            self.emit_dedented_text(&mut content_base);
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        _ => {} // Other bytes not possible after SCAN
                    }
                }
                State::SBlockChildCommentCheck => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'{' => {
                            self.advance();
                            self.mark();
                            state = State::SBlockInlineComment;
                        }
                        _ => {
                            self.mark();
                            state = State::SBlockChildComment;
                        }
                            }
                        }
                    }
                }
                State::SBlockInlineComment => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedComment, span: self.span_from_mark() });
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            { let content = self.term(); let span = self.span_from_mark(); self.emit(StreamingEvent::Comment { content, span }); }
                            self.advance();
                            state = State::SBlockProseAfterComment;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SBlockInlineCommentN1;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SBlockInlineCommentN1 => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedComment, span: self.span_from_mark() });
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            state = State::SBlockInlineComment;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SBlockInlineCommentN2;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SBlockInlineCommentN2 => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::Error { code: ParseErrorCode::UnclosedComment, span: self.span_from_mark() });
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'}' => {
                            self.advance();
                            state = State::SBlockInlineCommentN1;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
                State::SBlockProseAfterComment => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            self.advance();
                            state = State::SBlockChildren;
                        }
                        b';' => {
                            self.advance();
                            state = State::SBlockChildCommentCheck;
                        }
                        b'|' => {
                            self.parse_element(self.current_column());
                            state = State::SBlockAfterElement;
                        }
                        b'!' => {
                            self.parse_directive(self.current_column());
                            state = State::SBlockAfterDirective;
                        }
                        _ => {
                            self.mark();
                            state = State::SBlockChildProse;
                        }
                            }
                        }
                    }
                }
                State::SBlockChildAttr => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        _ => {
                            self.mark();
                            state = State::SBlockChildProse;
                        }
                            }
                        }
                    }
                }
                State::SBlockSkipLine => {
                    match self.peek() {
                        None => {
                            self.emit(StreamingEvent::DirectiveEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            return;
                        }
                        Some(b) => {
                            match b {
                        b'\n' => {
                            self.advance();
                            state = State::SBlockChildren;
                        }
                        _ => {
                            self.advance();
                        }
                            }
                        }
                    }
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_streaming_parser_creation() {
        let parser = StreamingParser::new(64);
        assert!(parser.is_done() == false);
        assert_eq!(parser.available(), 0);
    }

    #[test]
    fn test_streaming_parser_simple_text() {
        let mut parser = StreamingParser::new(64);

        // Feed some simple text
        let result = parser.feed(b"Hello world\n");
        println!("Feed result: {:?}", result);
        println!("Events available: {}", parser.available());

        // Finish parsing
        parser.finish();

        // Check what events we got
        let mut events = Vec::new();
        while let Some(event) = parser.read() {
            println!("Event: {:?}", event);
            events.push(event);
        }

        println!("Total events: {}", events.len());
        assert!(!events.is_empty(), "Should have at least one event");
    }

    #[test]
    fn test_streaming_parser_element() {
        let mut parser = StreamingParser::new(64);

        // Feed an element
        let result = parser.feed(b"|div Hello\n");
        println!("Feed result: {:?}", result);

        parser.finish();

        let mut events = Vec::new();
        while let Some(event) = parser.read() {
            println!("Event: {:?}", event);
            events.push(event);
        }

        println!("Total events: {}", events.len());

        // Should have ElementStart, Text, ElementEnd
        let has_element_start = events.iter().any(|e| matches!(e, StreamingEvent::ElementStart { .. }));
        assert!(has_element_start, "Should have ElementStart event");
    }
}
