//! UDON Streaming Parser - Generated by genmachine
//!
//! This is a generated file. Do not edit directly.
//! Source: generator/udon.machine
//!
//! This parser uses a ring buffer architecture for true streaming:
//! - Input arrives in chunks via feed()
//! - Events emit to a ring buffer as they're parsed
//! - Backpressure when buffer is full
//! - Chunk arena for zero-copy string references

use crate::span::Span;
use crate::streaming::{ChunkArena, ChunkSlice, EventRing, FeedResult, StreamingEvent};

/// Parser state enum - persists across feed() calls.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ParserState {
    /// Initial state / document level
    Document,
    /// Need more input to complete current token
    NeedInput,
    /// Finished parsing (got finish() call)
    Finished,
    /// Inside a specific parse function
    InFunction { function: FunctionId, state: u16 },
}

/// Function identifiers for nested parsing.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FunctionId {
    Document,
    Element,
    Array,
    // Add more as needed based on DSL functions
}

/// Streaming parser with ring buffer output.
///
/// # Example
///
/// ```ignore
/// let mut parser = StreamingParser::new(1024); // 1024 event capacity
///
/// // Feed chunks of input
/// parser.feed(b"|div Hello");
/// parser.feed(b" World\n");
/// parser.finish();
///
/// // Read events
/// while let Some(event) = parser.read() {
///     println!("{:?}", event);
/// }
/// ```
pub struct StreamingParser {
    // ========== State Machine ==========

    /// Current parser state
    state: ParserState,

    /// Call stack for nested function calls (element within element, etc.)
    /// Each entry is (function_id, local_state, return_state)
    call_stack: Vec<(FunctionId, u16, ParserState)>,

    // ========== Input Management ==========

    /// Arena storing input chunks
    chunks: ChunkArena,

    /// Current chunk index being parsed
    current_chunk: u32,

    /// Position within current chunk
    pos: usize,

    /// Partial token buffer (for tokens split across chunks)
    partial: Vec<u8>,

    /// Whether we're continuing a partial token
    in_partial: bool,

    // ========== Position Tracking ==========

    /// Current line number (1-indexed)
    line: u32,

    /// Current column (1-indexed)
    column: u32,

    /// Position of line start (for column calculation)
    line_start: usize,

    /// Global byte offset (across all chunks)
    global_offset: u64,

    // ========== Accumulation ==========

    /// Mark position for MARK/TERM pattern
    mark_chunk: u32,
    mark_pos: u32,

    // ========== Indentation Tracking ==========

    /// Element stack for indentation-based hierarchy
    /// Each entry is (column, has_children)
    element_stack: Vec<(i32, bool)>,

    // ========== Output ==========

    /// Ring buffer for output events
    events: EventRing,

    /// Whether finish() has been called
    finished: bool,
}

impl StreamingParser {
    /// Create a new streaming parser with the given event buffer capacity.
    pub fn new(event_capacity: usize) -> Self {
        Self {
            state: ParserState::Document,
            call_stack: Vec::with_capacity(16),
            chunks: ChunkArena::new(),
            current_chunk: 0,
            pos: 0,
            partial: Vec::with_capacity(256),
            in_partial: false,
            line: 1,
            column: 1,
            line_start: 0,
            global_offset: 0,
            mark_chunk: 0,
            mark_pos: 0,
            element_stack: Vec::with_capacity(32),
            events: EventRing::new(event_capacity),
            finished: false,
        }
    }

    /// Create with default capacity (1024 events).
    pub fn with_default_capacity() -> Self {
        Self::new(1024)
    }

    // ========== Public API ==========

    /// Feed a chunk of input to the parser.
    ///
    /// Returns information about how much was consumed and how many events were generated.
    /// If the ring buffer fills up, parsing pauses (backpressure).
    pub fn feed(&mut self, chunk: &[u8]) -> FeedResult {
        if self.finished {
            return FeedResult {
                bytes_consumed: 0,
                events_written: 0,
                buffer_full: false,
            };
        }

        // Add chunk to arena
        let chunk_idx = self.chunks.push(chunk.to_vec());
        self.current_chunk = chunk_idx;
        self.pos = 0;

        let events_before = self.events.available();

        // Resume parsing
        self.parse_continue();

        let events_written = self.events.available() - events_before;

        FeedResult {
            bytes_consumed: self.pos,
            events_written,
            buffer_full: self.events.is_full(),
        }
    }

    /// Signal end of input stream.
    ///
    /// Flushes any pending partial tokens and emits final events.
    pub fn finish(&mut self) -> FeedResult {
        if self.finished {
            return FeedResult {
                bytes_consumed: 0,
                events_written: 0,
                buffer_full: false,
            };
        }

        self.finished = true;
        let events_before = self.events.available();

        // Emit any pending element ends
        while !self.element_stack.is_empty() {
            self.emit_element_end();
        }

        FeedResult {
            bytes_consumed: 0,
            events_written: self.events.available() - events_before,
            buffer_full: self.events.is_full(),
        }
    }

    /// Read the next event from the ring buffer.
    ///
    /// Returns None if no events are available.
    pub fn read(&mut self) -> Option<StreamingEvent> {
        self.events.pop()
    }

    /// Peek at the next event without consuming it.
    pub fn peek_event(&self) -> Option<&StreamingEvent> {
        self.events.peek()
    }

    /// Number of events available to read.
    pub fn available(&self) -> usize {
        self.events.available()
    }

    /// Check if parsing is complete (finish called and buffer drained).
    pub fn is_done(&self) -> bool {
        self.finished && self.events.is_empty()
    }

    /// Check if the ring buffer is full (backpressure).
    pub fn is_buffer_full(&self) -> bool {
        self.events.is_full()
    }

    /// Get access to the chunk arena (for resolving ChunkSlice to bytes).
    pub fn arena(&self) -> &ChunkArena {
        &self.chunks
    }

    // ========== Internal Helpers ==========
    //
    // These methods provide compatibility with the generated state machine code.

    /// Check if at end of current chunk (compatibility alias for generated code).
    #[inline]
    fn eof(&self) -> bool {
        self.pos >= self.current_chunk_data().len()
    }

    /// Get current byte without advancing (compatibility alias for generated code).
    #[inline]
    fn peek(&self) -> Option<u8> {
        self.current_chunk_data().get(self.pos).copied()
    }

    /// Get current chunk's data.
    #[inline]
    fn current_chunk_data(&self) -> &[u8] {
        self.chunks.get(self.current_chunk)
            .map(|c| c.data())
            .unwrap_or(&[])
    }

    /// Advance one byte.
    #[inline]
    fn advance(&mut self) {
        if let Some(&b) = self.current_chunk_data().get(self.pos) {
            if b == b'\n' {
                self.line += 1;
                self.column = 1;
                self.pos += 1;
                self.line_start = self.pos;
            } else {
                self.column += 1;
                self.pos += 1;
            }
            self.global_offset += 1;
        }
    }

    /// Mark current position for accumulation.
    #[inline]
    fn mark(&mut self) {
        self.mark_chunk = self.current_chunk;
        self.mark_pos = self.pos as u32;
    }

    /// Get accumulated slice from mark to current position.
    #[inline]
    fn term(&self) -> ChunkSlice {
        // For now, assume mark and current are in same chunk
        // TODO: Handle cross-chunk terms via partial buffer
        ChunkSlice::new(self.mark_chunk, self.mark_pos, self.pos as u32)
    }

    /// Get current column (0-indexed from line start).
    #[inline]
    fn current_column(&self) -> i32 {
        (self.pos - self.line_start) as i32
    }

    /// Create a span from mark to current position.
    #[inline]
    fn span_from_mark(&self) -> Span {
        let start = self.chunks.get(self.mark_chunk)
            .map(|c| c.stream_offset() as usize + self.mark_pos as usize)
            .unwrap_or(0);
        let end = self.chunks.get(self.current_chunk)
            .map(|c| c.stream_offset() as usize + self.pos)
            .unwrap_or(0);
        Span::new(start, end)
    }

    /// Emit an event to the ring buffer.
    #[inline]
    fn emit(&mut self, event: StreamingEvent) {
        // If buffer is full, we'd need to handle backpressure
        // For now, just push (will panic if full)
        let _ = self.events.try_push(event);
    }

    /// Emit ElementEnd event.
    fn emit_element_end(&mut self) {
        if self.element_stack.pop().is_some() {
            self.emit(StreamingEvent::ElementEnd {
                span: Span::new(self.global_offset as usize, self.global_offset as usize),
            });
        }
    }

    /// Emit special attribute for identity parsing ($id, $class, suffixes).
    /// These are synthetic keys that don't come from the input.
    fn emit_special_attribute(&mut self, key: &str) {
        // For special attributes, we need to handle them differently
        // since the key is a static string, not from input.
        // We'll create a synthetic ChunkSlice pointing to the current position.
        let span = self.span_from_mark();
        // For now, use a workaround - store the key somehow
        // TODO: Better solution for static attribute keys
        self.emit(StreamingEvent::Attribute {
            key: self.term(), // Use the actual term for now
            span,
        });
    }

    /// Check if byte can start a LABEL.
    #[inline]
    fn is_label_start(&self, b: u8) -> bool {
        matches!(b, b'a'..=b'z' | b'A'..=b'Z' | b'_') ||
        (b >= 0x80 && self.is_unicode_letter_at(self.pos))
    }

    /// Check if byte can continue a LABEL.
    #[inline]
    fn is_label_continue(&self, b: u8) -> bool {
        matches!(b, b'a'..=b'z' | b'A'..=b'Z' | b'0'..=b'9' | b'_' | b'-') ||
        (b >= 0x80 && self.is_unicode_letter_or_number_at(self.pos))
    }

    /// Check for Unicode letter at position.
    fn is_unicode_letter_at(&self, pos: usize) -> bool {
        if let Some(slice) = self.current_chunk_data().get(pos..) {
            if let Ok(s) = std::str::from_utf8(slice) {
                if let Some(c) = s.chars().next() {
                    return unicode_xid::UnicodeXID::is_xid_start(c);
                }
            }
        }
        false
    }

    /// Check for Unicode letter or number at position.
    fn is_unicode_letter_or_number_at(&self, pos: usize) -> bool {
        if let Some(slice) = self.current_chunk_data().get(pos..) {
            if let Ok(s) = std::str::from_utf8(slice) {
                if let Some(c) = s.chars().next() {
                    return unicode_xid::UnicodeXID::is_xid_continue(c);
                }
            }
        }
        false
    }

    /// Emit a typed value based on accumulated content.
    fn emit_typed_value(&mut self) {
        let slice = self.term();
        let span = self.span_from_mark();

        // Resolve slice to check content
        if let Some(bytes) = self.chunks.resolve(slice) {
            // Check for nil
            if bytes == b"null" || bytes == b"nil" || bytes == b"~" {
                self.emit(StreamingEvent::NilValue { span });
                return;
            }

            // Check for bool
            if bytes == b"true" {
                self.emit(StreamingEvent::BoolValue { value: true, span });
                return;
            }
            if bytes == b"false" {
                self.emit(StreamingEvent::BoolValue { value: false, span });
                return;
            }

            // Try to parse as number
            if let Some(event) = self.try_parse_number(bytes, span) {
                self.emit(event);
                return;
            }
        }

        // Default to string
        self.emit(StreamingEvent::StringValue { value: slice, span });
    }

    /// Try to parse bytes as a number.
    fn try_parse_number(&self, bytes: &[u8], span: Span) -> Option<StreamingEvent> {
        use crate::Value;
        match Value::parse(bytes) {
            Value::Integer(i) => Some(StreamingEvent::IntegerValue { value: i, span }),
            Value::Float(f) => Some(StreamingEvent::FloatValue { value: f, span }),
            Value::Rational { numerator, denominator } => {
                Some(StreamingEvent::RationalValue { numerator, denominator, span })
            }
            Value::Complex { real, imag } => {
                Some(StreamingEvent::ComplexValue { real, imag, span })
            }
            _ => None,
        }
    }

    // ========== State Machine Entry Point ==========

    /// Continue parsing from current state.
    fn parse_continue(&mut self) {
        // For now, just run the document parser
        // TODO: Proper state restoration for streaming
        self.parse_document();
    }

    // ========== Generated State Machine ==========

    fn parse_document(&mut self) {
        #[derive(Clone, Copy)]
        enum State { SStart, SEscaped, SEscapedText, SProse, SCheckInlineComment, SInlineComment, SInlineCommentNested, SLineComment, SBlockComment, SMaybeFreeform, SMaybeFreeform2, SFreeform, SFreeformEnd1, SFreeformEnd2, SDirective, SDirectiveInterp, SDirectiveName, SDirectiveBody, SProseAfterDirective, SSkipLine }

        let mut state = State::SStart;
        loop {
            match state {
                State::SStart => {
                    if self.eof() {
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.advance();
                            state = State::SStart;
                        }
                        b' ' => {
                            self.advance();
                            state = State::SStart;
                        }
                        b'\t' => {
                            self.advance();
                            self.emit(StreamingEvent::Error { message: "no tabs".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            state = State::SSkipLine;
                        }
                        b'\'' => {
                            self.advance();
                            state = State::SEscaped;
                        }
                        b';' => {
                            self.advance();
                            self.mark();
                            state = State::SBlockComment;
                        }
                        b'|' => {
                            self.advance();
                            self.parse_element(self.current_column());
                            state = State::SStart;
                        }
                        b'`' => {
                            self.advance();
                            state = State::SMaybeFreeform;
                        }
                        b'!' => {
                            self.advance();
                            state = State::SDirective;
                        }
                        _ => {
                            self.mark();
                            state = State::SProse;
                        }
                        }
                    }
                }
                State::SEscaped => {
                    if self.eof() {
                        self.emit(StreamingEvent::Text { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.emit(StreamingEvent::Text { content: self.term(), span: self.span_from_mark() });
                            state = State::SStart;
                        }
                        _ => {
                            self.mark();
                            state = State::SEscapedText;
                        }
                        }
                    }
                }
                State::SEscapedText => {
                    if self.eof() {
                        self.emit(StreamingEvent::Text { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.emit(StreamingEvent::Text { content: self.term(), span: self.span_from_mark() });
                            state = State::SStart;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SProse => {
                    if self.eof() {
                        self.emit(StreamingEvent::Text { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.emit(StreamingEvent::Text { content: self.term(), span: self.span_from_mark() });
                            state = State::SStart;
                        }
                        b';' => {
                            self.emit(StreamingEvent::Text { content: self.term(), span: self.span_from_mark() });
                            self.advance();
                            state = State::SCheckInlineComment;
                        }
                        b'|' => {
                            self.emit(StreamingEvent::Text { content: self.term(), span: self.span_from_mark() });
                            self.advance();
                            self.parse_element(self.current_column());
                            state = State::SStart;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SCheckInlineComment => {
                    if self.eof() {
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'{' => {
                            self.advance();
                            state = State::SInlineComment;
                        }
                        _ => {
                            self.mark();
                            state = State::SLineComment;
                        }
                        }
                    }
                }
                State::SInlineComment => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed comment".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'}' => {
                            self.advance();
                            state = State::SProse;
                        }
                        b'{' => {
                            self.advance();
                            state = State::SInlineCommentNested;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SInlineCommentNested => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed comment".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'}' => {
                            self.advance();
                            state = State::SInlineComment;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SLineComment => {
                    if self.eof() {
                        self.emit(StreamingEvent::Comment { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.emit(StreamingEvent::Comment { content: self.term(), span: self.span_from_mark() });
                            state = State::SStart;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SBlockComment => {
                    if self.eof() {
                        self.emit(StreamingEvent::Comment { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.emit(StreamingEvent::Comment { content: self.term(), span: self.span_from_mark() });
                            state = State::SStart;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SMaybeFreeform => {
                    if self.eof() {
                        self.emit(StreamingEvent::Text { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'`' => {
                            self.advance();
                            state = State::SMaybeFreeform2;
                        }
                        _ => {
                            self.mark();
                            state = State::SProse;
                        }
                        }
                    }
                }
                State::SMaybeFreeform2 => {
                    if self.eof() {
                        self.emit(StreamingEvent::Text { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'`' => {
                            self.mark();
                            state = State::SFreeform;
                        }
                        _ => {
                            self.mark();
                            state = State::SProse;
                        }
                        }
                    }
                }
                State::SFreeform => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed freeform".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'`' => {
                            self.advance();
                            state = State::SFreeformEnd1;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SFreeformEnd1 => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed freeform".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'`' => {
                            self.advance();
                            state = State::SFreeformEnd2;
                        }
                        _ => {
                            self.advance();
                            state = State::SFreeform;
                        }
                        }
                    }
                }
                State::SFreeformEnd2 => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed freeform".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'`' => {
                            self.emit(StreamingEvent::RawContent { content: self.term(), span: self.span_from_mark() });
                            state = State::SStart;
                        }
                        _ => {
                            self.advance();
                            state = State::SFreeform;
                        }
                        }
                    }
                }
                State::SDirective => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "incomplete directive".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'{' => {
                            self.mark();
                            state = State::SDirectiveInterp;
                        }
                        _ => {
                            self.mark();
                            state = State::SDirectiveName;
                        }
                        }
                    }
                }
                State::SDirectiveInterp => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed directive".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'}' => {
                            self.emit(StreamingEvent::Interpolation { expression: self.term(), span: self.span_from_mark() });
                            state = State::SProseAfterDirective;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SDirectiveName => {
                    if self.eof() {
                        // TODO: emit Directive
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            // TODO: emit Directive
                            state = State::SStart;
                        }
                        b'{' => {
                            // TODO: emit Directive
                            state = State::SDirectiveBody;
                        }
                        b' ' | b'\t' => {
                            // TODO: emit Directive
                            state = State::SProseAfterDirective;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SDirectiveBody => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed directive".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'}' => {
                            // TODO: emit DirectiveBody
                            state = State::SProseAfterDirective;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SProseAfterDirective => {
                    if self.eof() {
                        self.emit(StreamingEvent::Text { content: self.term(), span: self.span_from_mark() });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.emit(StreamingEvent::Text { content: self.term(), span: self.span_from_mark() });
                            state = State::SStart;
                        }
                        b';' => {
                            self.emit(StreamingEvent::Text { content: self.term(), span: self.span_from_mark() });
                            self.advance();
                            state = State::SCheckInlineComment;
                        }
                        b'|' => {
                            self.emit(StreamingEvent::Text { content: self.term(), span: self.span_from_mark() });
                            self.advance();
                            self.parse_element(self.current_column());
                            state = State::SStart;
                        }
                        _ => {
                            self.mark();
                            state = State::SProse;
                        }
                        }
                    }
                }
                State::SSkipLine => {
                    if self.eof() {
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            state = State::SStart;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
            }
        }
    }

    fn parse_element(&mut self, elem_col: i32) {
        #[derive(Clone, Copy)]
        enum State { SIdentity, SIdName, SIdAfterName, SIdCheckBracket, SIdBracketStart, SIdAnonBracket, SIdBracketValue, SIdAfterBracket, SIdCheckClass, SIdClassStart, SIdClassName, SIdClassCheckMore, SIdSpaceSuffix, SIdQuotedName, SIdQuotedNameContent, SIdQuotedNameEscape, SIdClassQuoted, SIdClassQuotedContent, SIdClassQuotedEscape, SIdCheckMore, SAfterIdentity, SInlineContent, SInlineText, SElemCommentCheck, SElemInlineComment, SElemLineComment, SInlineAttrKey, SInlineAttrKeyScan, SInlineAttrKeyQuoted, SInlineAttrKeyQuotedContent, SInlineAttrKeyQuotedEsc, SInlineAttrWs, SInlineAttrValue, SInlineAttrDquote, SInlineAttrDquoteContent, SInlineAttrDquoteEsc, SInlineAttrSquote, SInlineAttrSquoteContent, SInlineAttrSquoteEsc, SInlineAttrBare, SInlineAttrAfterValue, SChildren, SChildrenContent, SChildrenAfterElement, SChildrenCountWs, SChildEscaped, SChildEscapedText, SChildProse, SChildCommentCheck, SChildInlineComment, SChildLineComment, SChildBlockComment, SChildFreeformCheck, SChildFreeformCheck2, SChildFreeform, SChildFreeformEnd1, SChildFreeformEnd2, SChildDirective, SChildDirectiveInterp, SChildDirectiveName, SChildDirectiveBody, SSkipChild, SAttrKey, SAttrKeyScan, SAttrKeyQuoted, SAttrKeyQuotedContent, SAttrKeyQuotedEsc, SAttrWs, SAttrValue, SAttrComment, SAttrDquote, SAttrDquoteContent, SAttrDquoteEsc, SAttrSquote, SAttrSquoteContent, SAttrSquoteEsc, SAttrBare, SAttrAfterValue, SAttrSkipLine }

        let mut state = State::SIdentity;
        loop {
            match state {
                State::SIdentity => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b if self.is_label_start(b) => {
                            self.mark();
                            state = State::SIdName;
                        }
                        b'[' => {
                            self.advance();
                            state = State::SIdAnonBracket;
                        }
                        b'.' => {
                            self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            state = State::SIdClassStart;
                        }
                        b'?' => {
                            self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.emit_special_attribute("?");
                            self.emit(StreamingEvent::BoolValue { value: true, span: self.span_from_mark() });
                            self.advance();
                            state = State::SIdCheckMore;
                        }
                        b'!' => {
                            self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.emit_special_attribute("!");
                            self.emit(StreamingEvent::BoolValue { value: true, span: self.span_from_mark() });
                            self.advance();
                            state = State::SIdCheckMore;
                        }
                        b'*' => {
                            self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.emit_special_attribute("*");
                            self.emit(StreamingEvent::BoolValue { value: true, span: self.span_from_mark() });
                            self.advance();
                            state = State::SIdCheckMore;
                        }
                        b'+' => {
                            self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.emit_special_attribute("+");
                            self.emit(StreamingEvent::BoolValue { value: true, span: self.span_from_mark() });
                            self.advance();
                            state = State::SIdCheckMore;
                        }
                        b'\'' => {
                            self.advance();
                            state = State::SIdQuotedName;
                        }
                        _ => {
                            self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            state = State::SAfterIdentity;
                        }
                        }
                    }
                }
                State::SIdName => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementStart { name: Some(self.term()), span: self.span_from_mark() });
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b if self.is_label_continue(b) => {
                            self.advance();
                        }
                        _ => {
                            self.emit(StreamingEvent::ElementStart { name: Some(self.term()), span: self.span_from_mark() });
                            state = State::SIdAfterName;
                        }
                        }
                    }
                }
                State::SIdAfterName => {
                    if self.eof() {
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'?' => {
                            self.emit_special_attribute("?");
                            self.emit(StreamingEvent::BoolValue { value: true, span: self.span_from_mark() });
                            self.advance();
                            state = State::SIdCheckBracket;
                        }
                        b'!' => {
                            self.emit_special_attribute("!");
                            self.emit(StreamingEvent::BoolValue { value: true, span: self.span_from_mark() });
                            self.advance();
                            state = State::SIdCheckBracket;
                        }
                        b'*' => {
                            self.emit_special_attribute("*");
                            self.emit(StreamingEvent::BoolValue { value: true, span: self.span_from_mark() });
                            self.advance();
                            state = State::SIdCheckBracket;
                        }
                        b'+' => {
                            self.emit_special_attribute("+");
                            self.emit(StreamingEvent::BoolValue { value: true, span: self.span_from_mark() });
                            self.advance();
                            state = State::SIdCheckBracket;
                        }
                        b'[' => {
                            self.advance();
                            state = State::SIdBracketStart;
                        }
                        b'.' => {
                            self.advance();
                            state = State::SIdClassStart;
                        }
                        _ => {
                            state = State::SAfterIdentity;
                        }
                        }
                    }
                }
                State::SIdCheckBracket => {
                    if self.eof() {
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'[' => {
                            self.advance();
                            state = State::SIdBracketStart;
                        }
                        b'.' => {
                            self.advance();
                            state = State::SIdClassStart;
                        }
                        _ => {
                            state = State::SAfterIdentity;
                        }
                        }
                    }
                }
                State::SIdBracketStart => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed bracket".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b']' => {
                            self.advance();
                            state = State::SIdAfterBracket;
                        }
                        _ => {
                            self.emit_special_attribute("$id");
                            self.mark();
                            state = State::SIdBracketValue;
                        }
                        }
                    }
                }
                State::SIdAnonBracket => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::Error { message: "unclosed bracket".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b']' => {
                            self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            state = State::SIdAfterBracket;
                        }
                        _ => {
                            self.emit(StreamingEvent::ElementStart { name: None, span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.emit_special_attribute("$id");
                            self.mark();
                            state = State::SIdBracketValue;
                        }
                        }
                    }
                }
                State::SIdBracketValue => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed bracket".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b']' => {
                            self.emit(StreamingEvent::StringValue { value: self.term(), span: self.span_from_mark() });
                            self.advance();
                            state = State::SIdAfterBracket;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SIdAfterBracket => {
                    if self.eof() {
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'?' => {
                            self.emit_special_attribute("?");
                            self.emit(StreamingEvent::BoolValue { value: true, span: self.span_from_mark() });
                            self.advance();
                            state = State::SIdCheckClass;
                        }
                        b'!' => {
                            self.emit_special_attribute("!");
                            self.emit(StreamingEvent::BoolValue { value: true, span: self.span_from_mark() });
                            self.advance();
                            state = State::SIdCheckClass;
                        }
                        b'*' => {
                            self.emit_special_attribute("*");
                            self.emit(StreamingEvent::BoolValue { value: true, span: self.span_from_mark() });
                            self.advance();
                            state = State::SIdCheckClass;
                        }
                        b'+' => {
                            self.emit_special_attribute("+");
                            self.emit(StreamingEvent::BoolValue { value: true, span: self.span_from_mark() });
                            self.advance();
                            state = State::SIdCheckClass;
                        }
                        b'.' => {
                            self.advance();
                            state = State::SIdClassStart;
                        }
                        _ => {
                            state = State::SAfterIdentity;
                        }
                        }
                    }
                }
                State::SIdCheckClass => {
                    if self.eof() {
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'.' => {
                            self.advance();
                            state = State::SIdClassStart;
                        }
                        _ => {
                            state = State::SAfterIdentity;
                        }
                        }
                    }
                }
                State::SIdClassStart => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "expected class name".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b if self.is_label_start(b) => {
                            self.emit_special_attribute("$class");
                            self.mark();
                            state = State::SIdClassName;
                        }
                        b'\'' => {
                            self.emit_special_attribute("$class");
                            self.advance();
                            state = State::SIdClassQuoted;
                        }
                        _ => {
                            self.emit(StreamingEvent::Error { message: "expected class name".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            state = State::SAfterIdentity;
                        }
                        }
                    }
                }
                State::SIdClassName => {
                    if self.eof() {
                        self.emit(StreamingEvent::StringValue { value: self.term(), span: self.span_from_mark() });
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b if self.is_label_continue(b) => {
                            self.advance();
                        }
                        _ => {
                            self.emit(StreamingEvent::StringValue { value: self.term(), span: self.span_from_mark() });
                            state = State::SIdClassCheckMore;
                        }
                        }
                    }
                }
                State::SIdClassCheckMore => {
                    if self.eof() {
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'.' => {
                            self.advance();
                            state = State::SIdClassStart;
                        }
                        b' ' => {
                            self.advance();
                            state = State::SIdSpaceSuffix;
                        }
                        _ => {
                            state = State::SAfterIdentity;
                        }
                        }
                    }
                }
                State::SIdSpaceSuffix => {
                    if self.eof() {
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'?' => {
                            self.emit_special_attribute("?");
                            self.emit(StreamingEvent::BoolValue { value: true, span: self.span_from_mark() });
                            self.advance();
                            state = State::SAfterIdentity;
                        }
                        b'!' => {
                            self.emit_special_attribute("!");
                            self.emit(StreamingEvent::BoolValue { value: true, span: self.span_from_mark() });
                            self.advance();
                            state = State::SAfterIdentity;
                        }
                        b'*' => {
                            self.emit_special_attribute("*");
                            self.emit(StreamingEvent::BoolValue { value: true, span: self.span_from_mark() });
                            self.advance();
                            state = State::SAfterIdentity;
                        }
                        b'+' => {
                            self.emit_special_attribute("+");
                            self.emit(StreamingEvent::BoolValue { value: true, span: self.span_from_mark() });
                            self.advance();
                            state = State::SAfterIdentity;
                        }
                        b' ' => {
                            self.advance();
                        }
                        _ => {
                            state = State::SAfterIdentity;
                        }
                        }
                    }
                }
                State::SIdQuotedName => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementStart { name: Some(self.term()), span: self.span_from_mark() });
                        self.emit(StreamingEvent::Error { message: "unclosed quote".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            self.mark();
                            self.emit(StreamingEvent::ElementStart { name: Some(self.term()), span: self.span_from_mark() });
                            self.advance();
                            state = State::SIdAfterName;
                        }
                        _ => {
                            self.mark();
                            state = State::SIdQuotedNameContent;
                        }
                        }
                    }
                }
                State::SIdQuotedNameContent => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementStart { name: Some(self.term()), span: self.span_from_mark() });
                        self.emit(StreamingEvent::Error { message: "unclosed quote".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            self.emit(StreamingEvent::ElementStart { name: Some(self.term()), span: self.span_from_mark() });
                            self.advance();
                            state = State::SIdAfterName;
                        }
                        b'\\' => {
                            self.advance();
                            state = State::SIdQuotedNameEscape;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SIdQuotedNameEscape => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementStart { name: Some(self.term()), span: self.span_from_mark() });
                        self.emit(StreamingEvent::Error { message: "unclosed quote".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        _ => {
                            self.advance();
                            state = State::SIdQuotedNameContent;
                        }
                        }
                    }
                }
                State::SIdClassQuoted => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed quote".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            self.mark();
                            self.emit(StreamingEvent::QuotedStringValue { value: self.term(), span: self.span_from_mark() });
                            self.advance();
                            state = State::SIdClassCheckMore;
                        }
                        _ => {
                            self.mark();
                            state = State::SIdClassQuotedContent;
                        }
                        }
                    }
                }
                State::SIdClassQuotedContent => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed quote".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            self.emit(StreamingEvent::QuotedStringValue { value: self.term(), span: self.span_from_mark() });
                            self.advance();
                            state = State::SIdClassCheckMore;
                        }
                        b'\\' => {
                            self.advance();
                            state = State::SIdClassQuotedEscape;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SIdClassQuotedEscape => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed quote".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        _ => {
                            self.advance();
                            state = State::SIdClassQuotedContent;
                        }
                        }
                    }
                }
                State::SIdCheckMore => {
                    if self.eof() {
                        state = State::SAfterIdentity;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'[' => {
                            self.advance();
                            state = State::SIdBracketStart;
                        }
                        b'.' => {
                            self.advance();
                            state = State::SIdClassStart;
                        }
                        _ => {
                            state = State::SAfterIdentity;
                        }
                        }
                    }
                }
                State::SAfterIdentity => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.advance();
                            state = State::SChildren;
                        }
                        b' ' | b'\t' => {
                            self.advance();
                            state = State::SInlineContent;
                        }
                        b';' => {
                            self.advance();
                            state = State::SElemCommentCheck;
                        }
                        b':' => {
                            self.advance();
                            state = State::SInlineAttrKey;
                        }
                        b'|' => {
                            self.advance();
                            self.parse_element(self.current_column());
                            state = State::SInlineContent;
                        }
                        _ => {
                            self.mark();
                            state = State::SInlineText;
                        }
                        }
                    }
                }
                State::SInlineContent => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.advance();
                            state = State::SChildren;
                        }
                        b' ' | b'\t' => {
                            self.advance();
                        }
                        b';' => {
                            self.advance();
                            state = State::SElemCommentCheck;
                        }
                        b':' => {
                            self.advance();
                            state = State::SInlineAttrKey;
                        }
                        b'|' => {
                            self.advance();
                            self.parse_element(self.current_column());
                            state = State::SInlineContent;
                        }
                        _ => {
                            self.mark();
                            state = State::SInlineText;
                        }
                        }
                    }
                }
                State::SInlineText => {
                    if self.eof() {
                        self.emit(StreamingEvent::Text { content: self.term(), span: self.span_from_mark() });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.emit(StreamingEvent::Text { content: self.term(), span: self.span_from_mark() });
                            self.advance();
                            state = State::SChildren;
                        }
                        b';' => {
                            self.emit(StreamingEvent::Text { content: self.term(), span: self.span_from_mark() });
                            self.advance();
                            state = State::SElemCommentCheck;
                        }
                        b'|' => {
                            self.emit(StreamingEvent::Text { content: self.term(), span: self.span_from_mark() });
                            self.advance();
                            self.parse_element(self.current_column());
                            state = State::SInlineContent;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SElemCommentCheck => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'{' => {
                            self.advance();
                            state = State::SElemInlineComment;
                        }
                        _ => {
                            self.mark();
                            state = State::SElemLineComment;
                        }
                        }
                    }
                }
                State::SElemInlineComment => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'}' => {
                            self.advance();
                            state = State::SInlineContent;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SElemLineComment => {
                    if self.eof() {
                        self.emit(StreamingEvent::Comment { content: self.term(), span: self.span_from_mark() });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.emit(StreamingEvent::Comment { content: self.term(), span: self.span_from_mark() });
                            self.advance();
                            state = State::SChildren;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SInlineAttrKey => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "expected attr key".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b if self.is_label_start(b) => {
                            self.mark();
                            state = State::SInlineAttrKeyScan;
                        }
                        b'\'' => {
                            self.advance();
                            state = State::SInlineAttrKeyQuoted;
                        }
                        _ => {
                            self.emit(StreamingEvent::Error { message: "expected attr key".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            state = State::SInlineContent;
                        }
                        }
                    }
                }
                State::SInlineAttrKeyScan => {
                    if self.eof() {
                        self.emit(StreamingEvent::Attribute { key: self.term(), span: self.span_from_mark() });
                        state = State::SInlineAttrWs;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b if self.is_label_continue(b) => {
                            self.advance();
                        }
                        _ => {
                            self.emit(StreamingEvent::Attribute { key: self.term(), span: self.span_from_mark() });
                            state = State::SInlineAttrWs;
                        }
                        }
                    }
                }
                State::SInlineAttrKeyQuoted => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed quote".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            self.mark();
                            self.emit(StreamingEvent::Attribute { key: self.term(), span: self.span_from_mark() });
                            self.advance();
                            state = State::SInlineAttrWs;
                        }
                        _ => {
                            self.mark();
                            state = State::SInlineAttrKeyQuotedContent;
                        }
                        }
                    }
                }
                State::SInlineAttrKeyQuotedContent => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed quote".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            self.emit(StreamingEvent::Attribute { key: self.term(), span: self.span_from_mark() });
                            state = State::SInlineAttrWs;
                        }
                        b'\\' => {
                            self.advance();
                            state = State::SInlineAttrKeyQuotedEsc;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SInlineAttrKeyQuotedEsc => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed quote".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        _ => {
                            self.advance();
                            state = State::SInlineAttrKeyQuotedContent;
                        }
                        }
                    }
                }
                State::SInlineAttrWs => {
                    if self.eof() {
                        state = State::SInlineAttrValue;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b' ' | b'\t' => {
                            self.advance();
                        }
                        _ => {
                            state = State::SInlineAttrValue;
                        }
                        }
                    }
                }
                State::SInlineAttrValue => {
                    if self.eof() {
                        self.emit(StreamingEvent::BoolValue { value: true, span: self.span_from_mark() });
                        state = State::SInlineContent;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.emit(StreamingEvent::BoolValue { value: true, span: self.span_from_mark() });
                            state = State::SChildren;
                        }
                        b';' => {
                            self.emit(StreamingEvent::BoolValue { value: true, span: self.span_from_mark() });
                            state = State::SElemCommentCheck;
                        }
                        b':' => {
                            self.emit(StreamingEvent::BoolValue { value: true, span: self.span_from_mark() });
                            state = State::SInlineAttrKey;
                        }
                        b'[' => {
                            self.emit(StreamingEvent::ArrayStart { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            self.parse_array();
                            state = State::SInlineAttrAfterValue;
                        }
                        b'"' => {
                            self.advance();
                            state = State::SInlineAttrDquote;
                        }
                        b'\'' => {
                            self.advance();
                            state = State::SInlineAttrSquote;
                        }
                        _ => {
                            self.mark();
                            state = State::SInlineAttrBare;
                        }
                        }
                    }
                }
                State::SInlineAttrDquote => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'"' => {
                            self.mark();
                            self.emit(StreamingEvent::QuotedStringValue { value: self.term(), span: self.span_from_mark() });
                            self.advance();
                            state = State::SInlineAttrAfterValue;
                        }
                        _ => {
                            self.mark();
                            state = State::SInlineAttrDquoteContent;
                        }
                        }
                    }
                }
                State::SInlineAttrDquoteContent => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SInlineContent;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'"' => {
                            self.emit(StreamingEvent::QuotedStringValue { value: self.term(), span: self.span_from_mark() });
                            self.advance();
                            state = State::SInlineAttrAfterValue;
                        }
                        b'\\' => {
                            self.advance();
                            state = State::SInlineAttrDquoteEsc;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SInlineAttrDquoteEsc => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SInlineContent;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        _ => {
                            self.advance();
                            state = State::SInlineAttrDquoteContent;
                        }
                        }
                    }
                }
                State::SInlineAttrSquote => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            self.mark();
                            self.emit(StreamingEvent::QuotedStringValue { value: self.term(), span: self.span_from_mark() });
                            self.advance();
                            state = State::SInlineAttrAfterValue;
                        }
                        _ => {
                            self.mark();
                            state = State::SInlineAttrSquoteContent;
                        }
                        }
                    }
                }
                State::SInlineAttrSquoteContent => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SInlineContent;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            self.emit(StreamingEvent::QuotedStringValue { value: self.term(), span: self.span_from_mark() });
                            self.advance();
                            state = State::SInlineAttrAfterValue;
                        }
                        b'\\' => {
                            self.advance();
                            state = State::SInlineAttrSquoteEsc;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SInlineAttrSquoteEsc => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SInlineContent;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        _ => {
                            self.advance();
                            state = State::SInlineAttrSquoteContent;
                        }
                        }
                    }
                }
                State::SInlineAttrBare => {
                    if self.eof() {
                        self.emit_typed_value();
                        state = State::SInlineContent;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.emit_typed_value();
                            state = State::SChildren;
                        }
                        b' ' | b'\t' => {
                            self.emit_typed_value();
                            state = State::SInlineAttrAfterValue;
                        }
                        b';' => {
                            self.emit_typed_value();
                            state = State::SElemCommentCheck;
                        }
                        b':' => {
                            self.emit_typed_value();
                            state = State::SInlineAttrKey;
                        }
                        b'|' => {
                            self.emit_typed_value();
                            self.parse_element(self.current_column());
                            state = State::SInlineContent;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SInlineAttrAfterValue => {
                    if self.eof() {
                        state = State::SInlineContent;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            state = State::SChildren;
                        }
                        b';' => {
                            state = State::SElemCommentCheck;
                        }
                        b':' => {
                            state = State::SInlineAttrKey;
                        }
                        b' ' | b'\t' => {
                            self.advance();
                        }
                        b'|' => {
                            self.parse_element(self.current_column());
                            state = State::SInlineContent;
                        }
                        _ => {
                            self.mark();
                            state = State::SInlineText;
                        }
                        }
                    }
                }
                State::SChildren => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.advance();
                            state = State::SChildren;
                        }
                        b' ' => {
                            self.advance();
                            state = State::SChildren;
                        }
                        b'\t' => {
                            self.advance();
                            self.emit(StreamingEvent::Error { message: "no tabs".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            state = State::SSkipChild;
                        }
                        _ => {
                            state = State::SChildrenContent;
                        }
                        }
                    }
                }
                State::SChildrenContent => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if self.current_column()  <=  elem_col {
    self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
    return;
}
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            self.advance();
                            state = State::SChildEscaped;
                        }
                        b';' => {
                            self.advance();
                            self.mark();
                            state = State::SChildBlockComment;
                        }
                        b'|' => {
                            self.advance();
                            self.parse_element(self.current_column());
                            state = State::SChildrenAfterElement;
                        }
                        b':' => {
                            self.advance();
                            state = State::SAttrKey;
                        }
                        b'`' => {
                            self.advance();
                            state = State::SChildFreeformCheck;
                        }
                        b'!' => {
                            self.advance();
                            state = State::SChildDirective;
                        }
                        _ => {
                            self.mark();
                            state = State::SChildProse;
                        }
                        }
                    }
                }
                State::SChildrenAfterElement => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.advance();
                            state = State::SChildren;
                        }
                        b' ' => {
                            self.advance();
                            state = State::SChildrenCountWs;
                        }
                        b'\t' => {
                            self.advance();
                            self.emit(StreamingEvent::Error { message: "no tabs".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            state = State::SSkipChild;
                        }
                        _ => {
                            state = State::SChildrenContent;
                        }
                        }
                    }
                }
                State::SChildrenCountWs => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.advance();
                            state = State::SChildren;
                        }
                        b' ' => {
                            self.advance();
                            state = State::SChildrenCountWs;
                        }
                        b'\t' => {
                            self.advance();
                            self.emit(StreamingEvent::Error { message: "no tabs".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            state = State::SSkipChild;
                        }
                        _ => {
                            state = State::SChildrenContent;
                        }
                        }
                    }
                }
                State::SChildEscaped => {
                    if self.eof() {
                        self.emit(StreamingEvent::Text { content: self.term(), span: self.span_from_mark() });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.emit(StreamingEvent::Text { content: self.term(), span: self.span_from_mark() });
                            self.advance();
                            state = State::SChildren;
                        }
                        _ => {
                            self.mark();
                            state = State::SChildEscapedText;
                        }
                        }
                    }
                }
                State::SChildEscapedText => {
                    if self.eof() {
                        self.emit(StreamingEvent::Text { content: self.term(), span: self.span_from_mark() });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.emit(StreamingEvent::Text { content: self.term(), span: self.span_from_mark() });
                            self.advance();
                            state = State::SChildren;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SChildProse => {
                    if self.eof() {
                        self.emit(StreamingEvent::Text { content: self.term(), span: self.span_from_mark() });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.emit(StreamingEvent::Text { content: self.term(), span: self.span_from_mark() });
                            self.advance();
                            state = State::SChildren;
                        }
                        b';' => {
                            self.emit(StreamingEvent::Text { content: self.term(), span: self.span_from_mark() });
                            self.advance();
                            state = State::SChildCommentCheck;
                        }
                        b'|' => {
                            self.emit(StreamingEvent::Text { content: self.term(), span: self.span_from_mark() });
                            self.advance();
                            self.parse_element(self.current_column());
                            state = State::SChildrenAfterElement;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SChildCommentCheck => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'{' => {
                            self.advance();
                            state = State::SChildInlineComment;
                        }
                        _ => {
                            self.mark();
                            state = State::SChildLineComment;
                        }
                        }
                    }
                }
                State::SChildInlineComment => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'}' => {
                            self.advance();
                            state = State::SChildProse;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SChildLineComment => {
                    if self.eof() {
                        self.emit(StreamingEvent::Comment { content: self.term(), span: self.span_from_mark() });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.emit(StreamingEvent::Comment { content: self.term(), span: self.span_from_mark() });
                            self.advance();
                            state = State::SChildren;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SChildBlockComment => {
                    if self.eof() {
                        self.emit(StreamingEvent::Comment { content: self.term(), span: self.span_from_mark() });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.emit(StreamingEvent::Comment { content: self.term(), span: self.span_from_mark() });
                            self.advance();
                            state = State::SChildren;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SChildFreeformCheck => {
                    if self.eof() {
                        self.emit(StreamingEvent::Text { content: self.term(), span: self.span_from_mark() });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'`' => {
                            self.advance();
                            state = State::SChildFreeformCheck2;
                        }
                        _ => {
                            self.mark();
                            state = State::SChildProse;
                        }
                        }
                    }
                }
                State::SChildFreeformCheck2 => {
                    if self.eof() {
                        self.emit(StreamingEvent::Text { content: self.term(), span: self.span_from_mark() });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'`' => {
                            self.mark();
                            state = State::SChildFreeform;
                        }
                        _ => {
                            self.mark();
                            state = State::SChildProse;
                        }
                        }
                    }
                }
                State::SChildFreeform => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed freeform".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'`' => {
                            self.advance();
                            state = State::SChildFreeformEnd1;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SChildFreeformEnd1 => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed freeform".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'`' => {
                            self.advance();
                            state = State::SChildFreeformEnd2;
                        }
                        _ => {
                            self.advance();
                            state = State::SChildFreeform;
                        }
                        }
                    }
                }
                State::SChildFreeformEnd2 => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed freeform".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'`' => {
                            self.emit(StreamingEvent::RawContent { content: self.term(), span: self.span_from_mark() });
                            state = State::SChildren;
                        }
                        _ => {
                            self.advance();
                            state = State::SChildFreeform;
                        }
                        }
                    }
                }
                State::SChildDirective => {
                    if self.eof() {
                        // TODO: emit Directive
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'{' => {
                            self.mark();
                            state = State::SChildDirectiveInterp;
                        }
                        _ => {
                            self.mark();
                            state = State::SChildDirectiveName;
                        }
                        }
                    }
                }
                State::SChildDirectiveInterp => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'}' => {
                            self.emit(StreamingEvent::Interpolation { expression: self.term(), span: self.span_from_mark() });
                            state = State::SChildProse;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SChildDirectiveName => {
                    if self.eof() {
                        // TODO: emit Directive
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            // TODO: emit Directive
                            self.advance();
                            state = State::SChildren;
                        }
                        b'{' => {
                            // TODO: emit Directive
                            state = State::SChildDirectiveBody;
                        }
                        b' ' | b'\t' => {
                            // TODO: emit Directive
                            state = State::SChildProse;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SChildDirectiveBody => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'}' => {
                            // TODO: emit DirectiveBody
                            state = State::SChildProse;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SSkipChild => {
                    if self.eof() {
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.advance();
                            state = State::SChildren;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SAttrKey => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "expected attr key".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b if self.is_label_start(b) => {
                            self.mark();
                            state = State::SAttrKeyScan;
                        }
                        b'\'' => {
                            self.advance();
                            state = State::SAttrKeyQuoted;
                        }
                        _ => {
                            self.emit(StreamingEvent::Error { message: "expected attr key".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            state = State::SChildren;
                        }
                        }
                    }
                }
                State::SAttrKeyScan => {
                    if self.eof() {
                        self.emit(StreamingEvent::Attribute { key: self.term(), span: self.span_from_mark() });
                        state = State::SAttrWs;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b if self.is_label_continue(b) => {
                            self.advance();
                        }
                        _ => {
                            self.emit(StreamingEvent::Attribute { key: self.term(), span: self.span_from_mark() });
                            state = State::SAttrWs;
                        }
                        }
                    }
                }
                State::SAttrKeyQuoted => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed quote".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            self.mark();
                            self.emit(StreamingEvent::Attribute { key: self.term(), span: self.span_from_mark() });
                            self.advance();
                            state = State::SAttrWs;
                        }
                        _ => {
                            self.mark();
                            state = State::SAttrKeyQuotedContent;
                        }
                        }
                    }
                }
                State::SAttrKeyQuotedContent => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed quote".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            self.emit(StreamingEvent::Attribute { key: self.term(), span: self.span_from_mark() });
                            state = State::SAttrWs;
                        }
                        b'\\' => {
                            self.advance();
                            state = State::SAttrKeyQuotedEsc;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SAttrKeyQuotedEsc => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed quote".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        _ => {
                            self.advance();
                            state = State::SAttrKeyQuotedContent;
                        }
                        }
                    }
                }
                State::SAttrWs => {
                    if self.eof() {
                        state = State::SAttrValue;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b' ' | b'\t' => {
                            self.advance();
                        }
                        _ => {
                            state = State::SAttrValue;
                        }
                        }
                    }
                }
                State::SAttrValue => {
                    if self.eof() {
                        self.emit(StreamingEvent::BoolValue { value: true, span: self.span_from_mark() });
                        state = State::SChildren;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.emit(StreamingEvent::BoolValue { value: true, span: self.span_from_mark() });
                            state = State::SChildren;
                        }
                        b';' => {
                            self.emit(StreamingEvent::BoolValue { value: true, span: self.span_from_mark() });
                            state = State::SAttrComment;
                        }
                        b'[' => {
                            self.emit(StreamingEvent::ArrayStart { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            self.parse_array();
                            state = State::SAttrAfterValue;
                        }
                        b'"' => {
                            self.advance();
                            state = State::SAttrDquote;
                        }
                        b'\'' => {
                            self.advance();
                            state = State::SAttrSquote;
                        }
                        _ => {
                            self.mark();
                            state = State::SAttrBare;
                        }
                        }
                    }
                }
                State::SAttrComment => {
                    if self.eof() {
                        state = State::SChildren;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            state = State::SChildren;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SAttrDquote => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'"' => {
                            self.mark();
                            self.emit(StreamingEvent::QuotedStringValue { value: self.term(), span: self.span_from_mark() });
                            self.advance();
                            state = State::SAttrAfterValue;
                        }
                        _ => {
                            self.mark();
                            state = State::SAttrDquoteContent;
                        }
                        }
                    }
                }
                State::SAttrDquoteContent => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SChildren;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'"' => {
                            self.emit(StreamingEvent::QuotedStringValue { value: self.term(), span: self.span_from_mark() });
                            self.advance();
                            state = State::SAttrAfterValue;
                        }
                        b'\\' => {
                            self.advance();
                            state = State::SAttrDquoteEsc;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SAttrDquoteEsc => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SChildren;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        _ => {
                            self.advance();
                            state = State::SAttrDquoteContent;
                        }
                        }
                    }
                }
                State::SAttrSquote => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        self.emit(StreamingEvent::ElementEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            self.mark();
                            self.emit(StreamingEvent::QuotedStringValue { value: self.term(), span: self.span_from_mark() });
                            self.advance();
                            state = State::SAttrAfterValue;
                        }
                        _ => {
                            self.mark();
                            state = State::SAttrSquoteContent;
                        }
                        }
                    }
                }
                State::SAttrSquoteContent => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SChildren;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            self.emit(StreamingEvent::QuotedStringValue { value: self.term(), span: self.span_from_mark() });
                            self.advance();
                            state = State::SAttrAfterValue;
                        }
                        b'\\' => {
                            self.advance();
                            state = State::SAttrSquoteEsc;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SAttrSquoteEsc => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        state = State::SChildren;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        _ => {
                            self.advance();
                            state = State::SAttrSquoteContent;
                        }
                        }
                    }
                }
                State::SAttrBare => {
                    if self.eof() {
                        self.emit_typed_value();
                        state = State::SChildren;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            self.emit_typed_value();
                            state = State::SChildren;
                        }
                        b';' => {
                            self.emit_typed_value();
                            state = State::SAttrComment;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SAttrAfterValue => {
                    if self.eof() {
                        state = State::SChildren;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            state = State::SChildren;
                        }
                        b';' => {
                            state = State::SAttrComment;
                        }
                        b' ' | b'\t' => {
                            self.advance();
                        }
                        _ => {
                            self.emit(StreamingEvent::Error { message: "unexpected after value".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            state = State::SAttrSkipLine;
                        }
                        }
                    }
                }
                State::SAttrSkipLine => {
                    if self.eof() {
                        state = State::SChildren;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\n' => {
                            state = State::SChildren;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
            }
        }
    }

    fn parse_array(&mut self) {
        #[derive(Clone, Copy)]
        enum State { SValues, SDquote, SDquoteContent, SDquoteEsc, SSquote, SSquoteContent, SSquoteEsc, SBare }

        let mut state = State::SValues;
        loop {
            match state {
                State::SValues => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed array".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b' ' | b'\t' => {
                            self.advance();
                        }
                        b'\n' => {
                            self.advance();
                        }
                        b']' => {
                            self.emit(StreamingEvent::ArrayEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            return;
                        }
                        b'"' => {
                            self.advance();
                            state = State::SDquote;
                        }
                        b'\'' => {
                            self.advance();
                            state = State::SSquote;
                        }
                        b'[' => {
                            self.emit(StreamingEvent::ArrayStart { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            self.parse_array();
                            state = State::SValues;
                        }
                        _ => {
                            self.mark();
                            state = State::SBare;
                        }
                        }
                    }
                }
                State::SDquote => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'"' => {
                            self.mark();
                            self.emit(StreamingEvent::QuotedStringValue { value: self.term(), span: self.span_from_mark() });
                            self.advance();
                            state = State::SValues;
                        }
                        _ => {
                            self.mark();
                            state = State::SDquoteContent;
                        }
                        }
                    }
                }
                State::SDquoteContent => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'"' => {
                            self.emit(StreamingEvent::QuotedStringValue { value: self.term(), span: self.span_from_mark() });
                            self.advance();
                            state = State::SValues;
                        }
                        b'\\' => {
                            self.advance();
                            state = State::SDquoteEsc;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SDquoteEsc => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        _ => {
                            self.advance();
                            state = State::SDquoteContent;
                        }
                        }
                    }
                }
                State::SSquote => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            self.mark();
                            self.emit(StreamingEvent::QuotedStringValue { value: self.term(), span: self.span_from_mark() });
                            self.advance();
                            state = State::SValues;
                        }
                        _ => {
                            self.mark();
                            state = State::SSquoteContent;
                        }
                        }
                    }
                }
                State::SSquoteContent => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b'\'' => {
                            self.emit(StreamingEvent::QuotedStringValue { value: self.term(), span: self.span_from_mark() });
                            self.advance();
                            state = State::SValues;
                        }
                        b'\\' => {
                            self.advance();
                            state = State::SSquoteEsc;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
                State::SSquoteEsc => {
                    if self.eof() {
                        self.emit(StreamingEvent::Error { message: "unclosed string".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        _ => {
                            self.advance();
                            state = State::SSquoteContent;
                        }
                        }
                    }
                }
                State::SBare => {
                    if self.eof() {
                        self.emit_typed_value();
                        self.emit(StreamingEvent::Error { message: "unclosed array".to_string(), span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                        return;
                    }
                    if let Some(b) = self.peek() {
                        match b {
                        b' ' | b'\t' | b'\n' => {
                            self.emit_typed_value();
                            state = State::SValues;
                        }
                        b']' => {
                            self.emit_typed_value();
                            self.emit(StreamingEvent::ArrayEnd { span: Span::new(self.global_offset as usize, self.global_offset as usize) });
                            self.advance();
                            return;
                        }
                        _ => {
                            self.advance();
                        }
                        }
                    }
                }
            }
        }
    }
}

// ========== Batch Parser (for backwards compatibility) ==========

/// Simple batch parser that parses entire input at once.
///
/// This is a convenience wrapper around StreamingParser for simple use cases.
pub struct Parser<'a> {
    input: &'a [u8],
    pos: usize,
    line: u32,
    column: u32,
    line_start: usize,
    mark_start: usize,
    events: Vec<crate::event::Event<'a>>,
}

impl<'a> Parser<'a> {
    /// Create a new parser for the given input.
    pub fn new(input: &'a [u8]) -> Self {
        let event_capacity = (input.len() / 50).max(16);
        Self {
            input,
            pos: 0,
            line: 1,
            column: 1,
            line_start: 0,
            mark_start: 0,
            events: Vec::with_capacity(event_capacity),
        }
    }

    /// Parse the entire input and return all events.
    pub fn parse(&mut self) -> Vec<crate::event::Event<'a>> {
        self.parse_document();
        std::mem::take(&mut self.events)
    }

    // Minimal implementation for batch mode
    #[inline] fn eof(&self) -> bool { self.pos >= self.input.len() }
    #[inline] fn peek(&self) -> Option<u8> { self.input.get(self.pos).copied() }
    #[inline] fn advance(&mut self) {
        if let Some(b) = self.input.get(self.pos) {
            if *b == b'\n' { self.line += 1; self.column = 1; self.pos += 1; self.line_start = self.pos; }
            else { self.column += 1; self.pos += 1; }
        }
    }
    #[inline] fn mark(&mut self) { self.mark_start = self.pos; }
    #[inline] fn term(&self) -> &'a [u8] { &self.input[self.mark_start..self.pos] }
    #[inline] fn current_column(&self) -> i32 { (self.pos - self.line_start) as i32 }
    #[inline] fn span_from_mark(&self) -> Span { Span::new(self.mark_start, self.pos) }
    #[inline] fn emit(&mut self, event: crate::event::Event<'a>) { self.events.push(event); }

    fn is_label_start(&self, b: u8) -> bool {
        matches!(b, b'a'..=b'z' | b'A'..=b'Z' | b'_') ||
        (b >= 0x80 && self.is_unicode_letter_at(self.pos))
    }
    fn is_label_continue(&self, b: u8) -> bool {
        matches!(b, b'a'..=b'z' | b'A'..=b'Z' | b'0'..=b'9' | b'_' | b'-') ||
        (b >= 0x80 && self.is_unicode_letter_or_number_at(self.pos))
    }
    fn is_unicode_letter_at(&self, pos: usize) -> bool {
        if let Some(slice) = self.input.get(pos..) {
            if let Ok(s) = std::str::from_utf8(slice) {
                if let Some(c) = s.chars().next() {
                    return unicode_xid::UnicodeXID::is_xid_start(c);
                }
            }
        }
        false
    }
    fn is_unicode_letter_or_number_at(&self, pos: usize) -> bool {
        if let Some(slice) = self.input.get(pos..) {
            if let Ok(s) = std::str::from_utf8(slice) {
                if let Some(c) = s.chars().next() {
                    return unicode_xid::UnicodeXID::is_xid_continue(c);
                }
            }
        }
        false
    }

    fn emit_typed_value(&mut self) {
        let bytes = self.term();
        let span = self.span_from_mark();
        if bytes == b"null" || bytes == b"nil" || bytes == b"~" {
            self.emit(crate::event::Event::NilValue { span });
            return;
        }
        if bytes == b"true" {
            self.emit(crate::event::Event::BoolValue { value: true, span });
            return;
        }
        if bytes == b"false" {
            self.emit(crate::event::Event::BoolValue { value: false, span });
            return;
        }
        if let Some(event) = self.try_parse_number_event(bytes, span) {
            self.emit(event);
            return;
        }
        self.emit(crate::event::Event::StringValue { value: bytes, span });
    }

    fn try_parse_number_event(&self, bytes: &'a [u8], span: Span) -> Option<crate::event::Event<'a>> {
        use crate::Value;
        match Value::parse(bytes) {
            Value::Integer(i) => Some(crate::event::Event::IntegerValue { value: i, span }),
            Value::Float(f) => Some(crate::event::Event::FloatValue { value: f, span }),
            Value::Rational { numerator, denominator } => {
                Some(crate::event::Event::RationalValue { numerator, denominator, span })
            }
            Value::Complex { real, imag } => {
                Some(crate::event::Event::ComplexValue { real, imag, span })
            }
            _ => None,
        }
    }

    // The batch parser will include the same generated state machine functions
    // but operating on the batch types. For now, we'll keep this as a stub
    // and implement it properly once the streaming version works.
    fn parse_document(&mut self) {
        // TODO: Generate batch version of state machine
        // For now, this is a placeholder that will need to be filled in
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_streaming_parser_creation() {
        let parser = StreamingParser::new(64);
        assert!(parser.is_done() == false);
        assert_eq!(parser.available(), 0);
    }

    #[test]
    fn test_streaming_parser_simple_text() {
        let mut parser = StreamingParser::new(64);

        // Feed some simple text
        let result = parser.feed(b"Hello world\n");
        println!("Feed result: {:?}", result);
        println!("Events available: {}", parser.available());

        // Finish parsing
        parser.finish();

        // Check what events we got
        let mut events = Vec::new();
        while let Some(event) = parser.read() {
            println!("Event: {:?}", event);
            events.push(event);
        }

        println!("Total events: {}", events.len());
        assert!(!events.is_empty(), "Should have at least one event");
    }

    #[test]
    fn test_streaming_parser_element() {
        let mut parser = StreamingParser::new(64);

        // Feed an element
        let result = parser.feed(b"|div Hello\n");
        println!("Feed result: {:?}", result);

        parser.finish();

        let mut events = Vec::new();
        while let Some(event) = parser.read() {
            println!("Event: {:?}", event);
            events.push(event);
        }

        println!("Total events: {}", events.len());

        // Should have ElementStart, Text, ElementEnd
        let has_element_start = events.iter().any(|e| matches!(e, StreamingEvent::ElementStart { .. }));
        assert!(has_element_start, "Should have ElementStart event");
    }
}
